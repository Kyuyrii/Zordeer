#!/usr/bin/env python3
# -*- coding: UTF-8 -*-

import sys
import os
import locale
import json
import toml
import subprocess
import atexit
import shutil
import requests
import tarfile
import io
import threading
import time
import psutil
import uuid
import re
import webbrowser
import random
import csv
from pathlib import Path

# Translation System
try:
    locale.setlocale(locale.LC_ALL, '')
    LANG, _ = locale.getlocale(locale.LC_CTYPE)
except locale.Error:
    LANG = 'en_US'

if not LANG:
    LANG = 'en_US'

__version__ = "0.4"
__creator__ = "<a href='https://github.com/Kyuyrii'>Kyuyrii</a>"

BUILTIN_TRANSLATIONS = {
    'en_US': {
        "ABOUT_TEXT_HTML": """<b>Zordeer</b><br>
        Version: {__version__}<br><br>
        A launcher for games that run via Wine/Proton.<br>
        License: <a href='https://www.gnu.org/licenses/gpl-3.0.html.en'>GPLv3</a><br>
        Created by {__creator__}""",
        "ABOUT_ZORDEER": "About Zordeer",
        "ADD_FILES": "Add files",
        "ADD_VARIABLES_BUTTON": "Add variables",
        "AFFECTED_INVOCATIONS": "Summons that will be affected",
        "ALREADY_UPDATED": "You are on the latest version.",
        "API_FAIL": "API error:\n{e}",
        "API_KEY_SAVE_FIRST": "Save your API KEY in the Zordeer settings first.",
        "ALL_INVOCATIONS": "All invocations",
        "ANIMARIUM_PREFIX_PLACEHOLDER": "Empty = animarium_prefix",
        "APP_NAME": "Zordeer",
        "ARTS_LOAD_ERROR": "[DEBUG] Failed to load arts: {error}",
        "AUTO_TRANSFER_BUTTON": "Automatic mode",
        "AUTO_TRANSFER_EXPLAIN": "Do you want to try downloading hero artwork and icons for all the summons that don't have them?<br>After the download, they will be applied automatically.",
        "AUTO_TRANSFER_FINISHED": "Automatic transfer completed",
        "AUTO_TRANSFER_GENERAL_ERROR": "General error in {inv_name}: {error}",
        "AUTO_TRANSFER_NO_MISSING_ARTS": "All invocations already have hero art and icon",
        "AUTOMATIC_RUN": "Automatic installation (If the installer supports it)",
        "BROWSE_BUTTON": "Browse",
        "CANCEL_BUTTON": "Cancel",
        "CHANGES_SAVED": "Changes have been saved.",
        "CHECK_UPDATE_BUTTON": "¿Update?",
        "CLEAN_RUN": "Clean run (Prevents issues with certain installers)",
        "CLEAR_LIST": "Clear list",
        "CLOSE_ZORDEER": "Close Zordeer",
        "CONFIRM": "Confirm",
        "CONFIRM_AND_RUN": "Start execution",
        "CONFIRM_CLOSE_MESSAGE": "Do you want to end the current invocation and close Zordeer?",
        "CONTENT": "Content",
        "CREATE_INVOCATION": "Create invocation",
        "CREATE_MULTIPLE_INVOCATIONS": "Create multiple invocations",
        "DEBUG_REAL_INVOCATION_INITIATED": "[DEBUG] Invocation initiated as PID {pid}",
        "DEBUG_TEMP_FILE_REMOVED": "[DEBUG] Temporary file removed: {path}",
        "DEFAULT_QT_STYLE": "- System default -",
        "DEFAULT_RUNNER": "Default runner",
        "DEFAULT_RUNNER_INDEFINITE": "Default runner not defined",
        "DEFAULT_UMU_INDEFINITE": "The version of the UMU launcher to be used has not been defined.",
        "DELETE_PREFIX_CHECKBOX": "Delete the prefix folder",
        "DELETE_PREFIX_ANYWAY": "Delete prefix folder anyway",
        "DELETE_PREFIXES_ANYWAY": "Delete prefixes folders anyway",
        "DELETE_INVOCATION_CONFIRM_MESSAGE": "Are you sure you want to remove the invocation '{name}'?",
        "DELETE_INVOCATIONS_CONFIRM_MESSAGE": "Are you sure you want to remove the selected invocations?",
        "DESELECT_ALL_IN_MULTIPLE_EDIT": "None",
        "DESKTOP_FOLDER": "Desktop folder",
        "DONE": "Done",
        "DO_NOT_CHANGE": "[Do not change]",
        "DO_NOT_DELETE_PREFIX": "Keep prefix folder",
        "DO_NOT_DELETE_PREFIXES": "Keep prefix folders",
        "DUPLICATE_NAME_IN_LIST": "There is already another invocation in the list with the name: {name}",
        "EDIT_MULTIPLE_INVOCATIONS": "Edit multiple invocations",
        "ENTER_GAME_NAME": "Enter a game name.",
        "ENVIRONMENT_VARS": "Variables",
        "ERROR": "Error",
        "ERROR_CREATING_FILE": "Error creating {file}: {error}",
        "ERROR_CREATING_SHORTCUTS_LOCATION": "This location could not be used:<br>{location}<br>Check its existence and permissions",
        "ERROR_LOADING_FILE": "Error loading file {file}: {error}",
        "ERROR_MOVING_SHORTCUTS": "Error moving the .desktop files {file}: {error}",
        "ERROR_REMOVING_FILE": "Error removing {file}: {error}",
        "ERROR_RUNNER": "Could not find the runner at: {path}",
        "ERROR_TRANSFERRING_URL": "Error transferring {url}: {error}",
        "EXEC_PATH_INVALID_CONFIRM": "The executable selected for this invocation appears to be invalid:<br>\"{path}\"<br>Running it may cause problems. Continue?",
        "EXEC_PATH_NOT_FOUND": "The executable for this invocation was not found:<br>\"{path}\"",
        "EXECUTABLE_FILE_FILTER": "Executables (*.exe *.msi *.iso);;All Files (*)",
        "EXECUTABLE_PATH": "Executable",
        "EXECUTION_MODE": "Execution mode",
        "EXTRAS": "Extras",
        "EXTRACTING": "Extracting: {name}",
        "FAILED_UPDATE_TOML": "Could not update invocation information: {error}",
        "FORCE_OPENGL": "Force OpenGL (If Vulkan is the default)",
        "FPS_DXVK_HUD": "DXVK HUD (DirectX 9/10/11 via Vulkan)",
        "FPS_GALLIUM_HUD": "Gallium HUD (If it runs via OpenGL)",
        "FPS_MANGOHUD": "MangoHUD (DirectX 12 via Vulkan)",
        "GAME_NAME": "Game Name",
        "GAMEMODE": "Use Feral gamemode",
        "ICON_WIDTH_CLASSIC": "Icon size (Classic)",
        "ICON_WIDTH_GRID": "Icon size (Grid)",
        "IMAGE_FILTER": "Image Files (*.jpg *.jpeg *.png *.webp);;All Files (*)",
        "INDEFINITE": "- Indefinite -",
        "INVALID_PREFIX_ERROR": "Invalid prefix, check if the prefix folder exists.",
        "INVOCATION": "Invocation",
        "INVOCATION_ALREADY_ACTIVE": "End current invocation and start the selected one?",
        "INVOCATION_ALREADY_EXISTS": "There is already an invocation with that name in the list. Choose another.",
        "INVOCATION_ARGS": "Arguments",
        "INVOCATION_ART_PATH": "Art",
        "INVOCATION_GUI_PATH": "Icon GUI",
        "INVOCATION_INFO_ERROR": "Could not access executable or find information about this invocation.",
        "INVOCATION_INFO_LOADED": "Invocation info loaded successfully for: {name}",
        "INVOCATION_INFO_VIEWER_TITLE": "Invocations information",
        "INVOCATION_LANGUAGE": "Language (Locale)",
        "INVOCATION_NAME": "Name",
        "INVOCATION_IN_MULTIPLE_CREATE_ALREADY_EXISTS": "The invocation '{name}' already exists, use another name.",
        "INVOCATION_START_ERROR": "An error occurred while trying to start the invocation: {error}",
        "INVOCATION_STARTED": "Zordeer - Invocation started: {invocation_name}",
        "ISO_ALREADY_MOUNTED": "ISO is already mounted at {mount}",
        "ISO_LOOP_DELETE_FAILED": "Failed to delete loop device {device}:\n{error}",
        "ISO_MOUNT_FAILED": "Failed to mount ISO:\n{error}",
        "ISO_MOUNT_POINT_NOT_FOUND": "Failed to determine ISO mount point",
        "ISO_MOUNTED_EXE_FOUND": "Executable found in ISO {iso}: {exe}",
        "ISO_NO_EXE_FOUND": "No .exe file found in the ISO",
        "ISO_UNMOUNTED": "ISO unmounted and loop device {device} released",
        "ISO_UNMOUNT_FAILED": "Failed to unmount ISO on device {device}:\n{error}",
        "ISO_UNMOUNT_EXCEPTION": "Unexpected error while unmounting ISO:\n{error}",
        "LANGUAGE": "Language",
        "LANGUAGE_SET_ERROR": "[Error] Failed to set LC_ALL: {error}",
        "LAYOUT_MODE": "Layout mode",
        "LAYOUT_MODE_CLASSIC": "Classic",
        "LAYOUT_MODE_GRID": "Grid",
        "LAYOUT_MODE_LIST": "List",
        "LAYOUT_MODE_CLASSIC_BARE": "Classic (bare)",
        "LAYOUT_MODE_GRID_BARE": "Grid (bare)",
        "LAYOUT_MODE_LIST_BARE": "List (bare)",
        "LOAD_HEROES": "Load heroes",
        "LOAD_ICONS": "Load icons",
        "LOAD_VERSIONS": "Load versions",
        "LOOP_DEVICE_CREATION_FAILED": "Failed to create loop device:\n{error}",
        "LOOP_DEVICE_NOT_FOUND": "Loop device not found",
        "MANAGE_SHORTCUTS": "Manage shortcuts",
        "MANDATORY_FIELD_ERROR": "It is mandatory that the invocation has a name.",
        "MANDATORY_FIELDS_ERROR": "Name and executable are mandatory.",
        "MARK_LISTED": "Check listed",
        "MENU_FOLDER": "Menu folder",
        "MODIFY_INVOCATION": "Modify invocation",
        "MOVE_SHORTCUTS_CONFIRM": "Do you want to move shortcuts from \"{old}\" to \"{new}\"?",
        "MULTIPLE_INVOCATION_EDITOR": "Multiple invocation editor",
        "MULTIPLE_INVOCATION_CREATOR": "Creator of multiple invocations",
        "MULTIPLE_INVOCATION_REMOVER": "Multiple invocation remover",
        "NAME": "Name",
        "NAME_INVALID": "The name is invalid, select another.",
        "NAME_INVALID_IN_MULTIPLE": "The name '{name}' is invalid, select another.",
        "NEW_VERSION_AVAILABLE": "New version found: '{version}'.<br>Do you want to go to the repository?",
        "NO_BUTTON": "No",
        "NO_IMAGES": "No images found.",
        "NO_EXEC_PATH": "An executable file has not been selected for this invocation.<br>Running it may cause problems. Continue?",
        "NO_EXECUTABLE_SELECTED": "You have not selected executables",
        "NO_FILES_EXTRACTED": "No files were extracted from the runner archive.",
        "NO_GAME_SELECTED_ERROR": "No game selected",
        "NO_INVOCATION_SELECTED_ERROR": "No invocations found, add one to the list.",
        "NO_INVOCATION_SELECTED_MULTIPLE": "No invocation selected",
        "NO_INVOCATIONS_FOUND": "No invocations were found.",
        "NO_PYQT6_FOUND_ERROR": "PyQt6 not found.",
        "NO_RESULTS": "No results.",
        "NO_RUNNER_SELECTED_ERROR": "Please select a runner to transfer.",
        "NO_TAGS_FOUND": "No tags found in the repository.",
        "NORMAL_RUN": "Normal run",
        "OK_BUTTON": "OK",
        "OPEN_EXEC_PATH": "Open executable folder",
        "OPEN_PATH_ERROR": "Could not find this path on your device:<br>{path}",
        "OPEN_PREFIX_PATH": "Open prefix folder",
        "OPEN_REPO": "Open repository",
        "PLACEHOLDER_FOR_LANGUAGE": "- No language chosen -",
        "PLACEHOLDER_FOR_RUNNER": "- Default runner -",
        "PREFIX_PATH_NOT_FOUND": "The prefix for this invocation was not found:<br>\"{path}\"",
        "PREFIX_REMOTION_INFORMATION": "Prefix that would be deleted",
        "PREFIXES_REMOTION_INFORMATION": "Prefixes that would be deleted",
        "PREFIX_IN_USE_MESSAGE": "The prefix is ​​being used by other invocations.",
        "PREFIXES_IN_USE_MESSAGE": "Prefixes are being used by other invocations.",
        "PREFIX_PATH": "Prefix",
        "QT_STYLE": "QT style",
        "REMOVE": "Remove",
        "REMOVE_MULTIPLE_INVOCATIONS": "Remove multiple invocations",
        "REMOVE_SELECTED": "Remove selected",
        "REMOVE_RUNNER_ERROR": "Unable to remove the runner: {error}",
        "RENAME_PREFIX_QUESTION": "The invocation name changed from \"{old}\" to \"{new}\".<br>Do you want to rename the prefix folder?",
        "RESET_BUTTON_MULTIPLE_EDIT": "Reset",
        "RUN_IN_PREFIX": "Run in prefix",
        "RUN_IN_PREFIX_DONE": "Run in prefix completed.",
        "RUN_IN_PREFIX_INVOCATION_NAME": "Run in the prefix of: {invocation_name}",
        "RUN_IN_PREFIX_TEMP_FILE_REMOVED": "[Run in prefix] Temporary invocation removed: {temp_file}",
        "RUN_IN_PREFIX_WAITING": "Waiting for the user to stop the current execution",
        "RUNNER_APPLIED_ALL": "Runner applied to all invocations on the list",
        "RUNNER_APPLY_ALL_UPDATE_ERROR": "[RunnerApplyAll] Error updating {fname}: {e}",
        "RUNNER_EXISTS_WARNING": "The files for '{name}' exist locally.<br>Do you want to remove them and transfer them again?",
        "RUNNER_REMOVED_SUCCESS": "Runner '{name}' removed successfully!",
        "RUNNER_VERSION": "Runner",
        "RUNNING_COMMAND": "Running command: {command}",
        "RUNNING_IN_BACKGROUND": "Started in the background",
        "RUNNING_IN_PREFIX": "Running in prefix ({name}): {exe}  silent={silent}",
        "SAVE_BUTTON": "Save",
        "SEE_DATA": "View data",
        "SEARCH": "Search",
        "SELECT": "Select",
        "SELECT_ALL_IN_MULTIPLE_EDIT": "All",
        "SELECT_AT_LEAST_ONE_IMAGE": "Select at least one image.",
        "SELECT_EXECUTABLE": "Select executable",
        "SELECTED_EXECUTABLES": "Selected executables",
        "SELECTED_INVOCATIONS": "Selected Invocations",
        "SELECT_AVAILABLE_RUNNER_CONFIRM": "The selected runner appears to be absent.<br>Save anyway?",
        "SELECT_INVOCATION_ART": "Select art",
        "SELECT_INVOCATION_GUI": "Select gui icon",
        "SELECT_PREFIX_TITLE": "Select prefix",
        "SETTINGS_SAVED_RESTART": "Changes saved.<br>Restart Zordeer to apply visual changes.",
        "SGDB_API_KEY_LABEL": "SteamGridDB API Key",
        "SHORTCUTS_MANAGER_TITLE": "Shortcut Manager",
        "SHORTCUTS_OF_DESKTOP": "Desktop shortcuts",
        "SHORTCUTS_OF_MENU": "Menu shortcuts",
        "SHORTCUTS_PATHS": "Paths",
        "SHORTCUTS_SAVED": "Updated shortcuts",
        "SHOW_FPS_OPTION": "Show FPS",
        "SHOW_FPS_OPTION_HUD": "Selected HUD",
        "START_INVOCATION": "Start invocation",
        "START_RANDOM_INVOCATION": "Random invocation",
        "STARTING_INVOCATION": "Starting invocation: {name}",
        "STOP_ACCESS_ERROR": "[Stop] Error accessing process: {error}",
        "STOP_CURRENT": "Close/Next",
        "STOP_INVOCATION": "Stop invocation",
        "STOP_INVOCATION_SUCCESS": "[Stop] Invocation terminated successfully.",
        "STOP_KILL_ERROR": "[Stop] Error killing process {pid}: {error}",
        "STOP_KILL_PROCESS": "[Stop] Killing process {pid} ({exe})",
        "STOP_NO_INVOCATION_ACTIVE": "[Stop] No invocation active.",
        "STOP_NO_PROCESS_FOUND": "[Stop] No invocation process found to terminate.",
        "STOP_PROCESS_SUCCESS": "[Stop] Process {pid} terminated successfully.",
        "STORE": "Store",
        "SYMLINK_CREATED": "Symlink created: {symlink} -> {prefix}",
        "SYMLINK_ERROR": "Error creating symlink for Proton: {error}",
        "TEMP_FILES_REMOVED": "Temporary files removed: {count}",
        "TRANSFER": "Transfer",
        "TRANSFER_AND_INSTALL_SUCCESS": "'{name}' was successfully transferred and extracted!",
        "TRANSFER_ARTS": "Arts",
        "TRANSFER_ARTS_TITLE": "Steamgriddb arts transfer",
        "TRANSFER_CANCELED": "Transfer canceled",
        "TRANSFER_ERROR": "Transfer error",
        "TRANSFER_FAILED": "Transfer failed: {error}",
        "TRANSFER_RUNNERS": "Runners/UMU",
        "TRANSFER_RUNNERS_TITLE": "Runners/UMU transfer",
        "TRANSFER_SUMMARY": "Transferred to:\n{dir}",
        "TRANSFERRING_RUNNER": "Transferring: {name}",
        "UMU_DATABASE": "UMU Game Database",
        "UMU_DATABASE_BUTTON": "Database",
        "UMU_DATABASE_LOAD_ERROR": "Error loading UMU database: {error}",
        "UMU_DATABASE_NOT_FOUND": "The UMU database was not found in:<br>\"{path}\"",
        "UMU_DATABASE_WINE_NOT_SUPPORTED": "UMU database is not available for Wine.<br>Use a Proton runner.",
        "UMU_NOT_FOUND": "UMU not found in:<br>{path}",
        "UMU_VERSION": "UMU version",
        "UNMARK_LISTED": "Uncheck listed",
        "UPDATE_ERROR": "Error checking for updates:<br>{error}",
        "UPDATE_SHORTCUTS": "Update shortcuts",
        "UNAVAILABLE": "Unavailable",
        "USE_ANIMARIUM_PREFIX": "Use animarium_prefix",
        "USE_ANIMARIUM_PREFIX_FOR_ALL": "Use the animarium_prefix on all invocations",
        "USE_AUTO_PREFIX_FOR_ALL": "Set prefixes based on drive_c folder (If exists)",
        "USE_MS_LANGUAGE_CODE": "Use Microsoft language code",
        "USE_ON_ALL": "Use on all",
        "USE_UMU_LAUNCHER": "Use UMU launcher (Proton only)",
        "USE_UMU_LAUNCHER_TOOLTIP": "Transfers files in the background.<br>The first run may take some time.",
        "USING_PYQT6": "Using PyQt6",
        "WINE_NOT_FOUND": "Wine was not found, please check if it is installed",
        "WINECFG_BUTTON": "Winecfg",
        "YES_BUTTON": "Yes",
        "ZORDEER_CLOSED": "Zordeer closed. Finalizing processes...",
        "ZORDEER_SETTINGS": "Zordeer preferences",
        "ZORDEER_TRAY_TOGGLE": "Change visibility",
    },
    'pt_BR': {
        "ABOUT_TEXT_HTML": """<b>Zordeer</b><br>
        Versão: {__version__}<br><br>
        Um launcher para jogos que rodam via Wine/Proton.<br>
        Licença: <a href='https://www.gnu.org/licenses/gpl-3.0.html'>GPLv3</a><br>
        Criado por {__creator__}""",
        "ABOUT_ZORDEER": "Sobre o Zordeer",
        "ADD_FILES": "Adicionar arquivos",
        "ADD_VARIABLES_BUTTON": "Adicionar variáveis",
        "AFFECTED_INVOCATIONS": "Invocações que serão afetadas",
        "ALREADY_UPDATED": "Você está na versão mais recente.",
        "API_FAIL": "Erro de API:\n{e}",
        "API_KEY_SAVE_FIRST": "Salve sua API KEY nas configurações do Zordeer primeiro.",
        "ALL_INVOCATIONS": "Todas as invocações",
        "ANIMARIUM_PREFIX_PLACEHOLDER": "Vazio = animarium_prefix",
        "APP_NAME": "Zordeer",
        "ARTS_LOAD_ERROR": "[DEBUG] Falha ao carregar artes: {error}",
        "AUTO_TRANSFER_BUTTON": "Modo automático",
        "AUTO_TRANSFER_EXPLAIN": "Deseja tentar baixar artes hero e ícones para todas as invocações que não possuem?<br>Após a transferência, elas serão aplicadas automaticamente.",
        "AUTO_TRANSFER_FINISHED": "Transferência automática finalizada",
        "AUTO_TRANSFER_GENERAL_ERROR": "Erro geral em {inv_name}: {error}",
        "AUTO_TRANSFER_NO_MISSING_ARTS": "Todas as invocações já possuem arte hero e ícone",
        "AUTOMATIC_RUN": "Instalação automática (Caso o instalador suporte)",
        "BROWSE_BUTTON": "Procurar",
        "CANCEL_BUTTON": "Cancelar",
        "CHANGES_SAVED": "As alterações foram salvas.",
        "CHECK_UPDATE_BUTTON": "¿Atualização?",
        "CLEAN_RUN": "Execução limpa (Evita problemas com certos instaladores)",
        "CLEAR_LIST": "Limpar lista",
        "CLOSE_ZORDEER": "Fechar Zordeer",
        "CONFIRM": "Confirmar",
        "CONFIRM_AND_RUN": "Iniciar execução",
        "CONFIRM_CLOSE_MESSAGE": "Deseja encerrar a invocação atual e fechar o Zordeer?",
        "CONTENT": "Conteúdo",
        "CREATE_INVOCATION": "Criar invocação",
        "CREATE_MULTIPLE_INVOCATIONS": "Criar várias invocações",
        "DEBUG_REAL_INVOCATION_INITIATED": "[DEBUG] Invocação iniciada como PID {pid}",
        "DEBUG_TEMP_FILE_REMOVED": "[DEBUG] Arquivo temporário removido: {path}",
        "DEFAULT_QT_STYLE": "- Padrão do sistema -",
        "DEFAULT_RUNNER": "Runner padrão",
        "DEFAULT_RUNNER_INDEFINITE": "Runner padrão não definido",
        "DEFAULT_UMU_INDEFINITE": "A versão do UMU launcher a ser usada não foi definida.",
        "DELETE_PREFIX_CHECKBOX": "Excluir a pasta prefixo",
        "DELETE_PREFIX_ANYWAY": "Excluir pasta prefixo mesmo assim",
        "DELETE_PREFIXES_ANYWAY": "Excluir pastas prefixo mesmo assim",
        "DELETE_INVOCATION_CONFIRM_MESSAGE": "Tem certeza de que deseja remover a invocação '{name}'?",
        "DELETE_INVOCATIONS_CONFIRM_MESSAGE": "Tem certeza de que deseja remover as invocações selecionadas?",
        "DESELECT_ALL_IN_MULTIPLE_EDIT": "Nenhuma",
        "DESKTOP_FOLDER": "Pasta área de trabalho",
        "DONE": "Concluído",
        "DO_NOT_CHANGE": "[Não mudar]",
        "DO_NOT_DELETE_PREFIX": "Manter pasta prefixo",
        "DO_NOT_DELETE_PREFIXES": "Manter pastas prefixo",
        "DUPLICATE_NAME_IN_LIST": "Já existe outra invocação na lista com o nome: {name}",
        "EDIT_MULTIPLE_INVOCATIONS": "Editar várias invocações",
        "ENTER_GAME_NAME": "Digite o nome de um jogo.",
        "ENVIRONMENT_VARS": "Variáveis",
        "ERROR": "Erro",
        "ERROR_CREATING_FILE": "Erro ao criar {file}: {error}",
        "ERROR_CREATING_SHORTCUTS_LOCATION": "Não foi possível usar essa localização:<br>{location}<br>Verifique sua existência e suas permissões",
        "ERROR_LOADING_FILE": "Erro ao carregar arquivo {file}: {error}",
        "ERROR_MOVING_SHORTCUTS": "Erro ao mover os arquivos .desktop {file}: {error}",
        "ERROR_REMOVING_FILE": "Erro ao remover {file}: {error}",
        "ERROR_RUNNER": "Não foi possível encontrar o runner em: {path}",
        "ERROR_TRANSFERRING_URL": "Erro ao transferir {url}: {error}",
        "EXEC_PATH_INVALID_CONFIRM": "O executável escolhido para essa invocação parece inválido:<br>\"{path}\"<br>Executar ela pode gerar problemas. Continuar?",
        "EXEC_PATH_NOT_FOUND": "O executável dessa invocação não foi encontrado:<br>\"{path}\"",
        "EXECUTABLE_FILE_FILTER": "Executáveis (*.exe *.msi *.iso);;Todos os arquivos (*)",
        "EXECUTABLE_PATH": "Executável",
        "EXECUTION_MODE": "Modo de execução",
        "EXTRAS": "Extras",
        "EXTRACTING": "Extraindo: {name}",
        "FAILED_UPDATE_TOML": "Não foi possível atualizar as informações da invocação: {error}",
        "FORCE_OPENGL": "Forçar OpenGL (Se Vulkan for o padrão)",
        "FPS_DXVK_HUD": "DXVK HUD (DirectX 9/10/11 via Vulkan)",
        "FPS_GALLIUM_HUD": "Gallium HUD (Caso rode via OpenGL)",
        "FPS_MANGOHUD": "MangoHUD (DirectX 12 via Vulkan)",
        "GAME_NAME": "Nome do Jogo",
        "GAMEMODE": "Usar Feral gamemode",
        "ICON_WIDTH_CLASSIC": "Tamanho do ícone (Clássico)",
        "ICON_WIDTH_GRID": "Tamanho do ícone (Grade)",
        "IMAGE_FILTER": "Arquivos de imagem (*.jpg *.jpeg *.png *.webp);;Todos os arquivos (*)",
        "INDEFINITE": "- Indefinido -",
        "INVALID_PREFIX_ERROR": "Prefixo inválido, verifique se a pasta do prefixo existe.",
        "INVOCATION": "Invocação",
        "INVOCATION_ALREADY_ACTIVE": "Encerrar invocação atual e iniciar a selecionada?",
        "INVOCATION_ALREADY_EXISTS": "Já existe uma invocação com esse nome na lista. Escolha outro.",
        "INVOCATION_ARGS": "Argumentos",
        "INVOCATION_ART_PATH": "Arte",
        "INVOCATION_GUI_PATH": "Ícone GUI",
        "INVOCATION_INFO_ERROR": "Não foi possível acessar o executável ou encontrar informações sobre esta invocação.",
        "INVOCATION_INFO_LOADED": "Informações da invocação carregadas com sucesso: {name}",
        "INVOCATION_INFO_VIEWER_TITLE": "Informações das invocações",
        "INVOCATION_LANGUAGE": "Idioma (Localidade)",
        "INVOCATION_NAME": "Nome",
        "INVOCATION_IN_MULTIPLE_CREATE_ALREADY_EXISTS": "A invocação '{name}' já existe, use outro nome.",
        "INVOCATION_START_ERROR": "Ocorreu um erro ao tentar iniciar a invocação: {error}",
        "INVOCATION_STARTED": "Zordeer - Invocação iniciada: {invocation_name}",
        "ISO_ALREADY_MOUNTED": "ISO já está montada em {mount}",
        "ISO_LOOP_DELETE_FAILED": "Falha ao remover loop device {device}:\n{error}",
        "ISO_MOUNT_FAILED": "Falha ao montar ISO:\n{error}",
        "ISO_MOUNT_POINT_NOT_FOUND": "Falha ao determinar o diretório de montagem da ISO",
        "ISO_MOUNTED_EXE_FOUND": "Executável encontrado na ISO {iso}: {exe}",
        "ISO_NO_EXE_FOUND": "Nenhum .exe encontrado na ISO",
        "ISO_UNMOUNTED": "ISO desmontada e loop device {device} liberado",
        "ISO_UNMOUNT_FAILED": "Falha ao desmontar ISO no dispositivo {device}:\n{error}",
        "ISO_UNMOUNT_EXCEPTION": "Erro inesperado ao desmontar ISO:\n{error}",
        "LANGUAGE": "Idioma",
        "LANGUAGE_SET_ERROR": "[Erro] Falha ao definir LC_ALL: {error}",
        "LAYOUT_MODE": "Modo do layout",
        "LAYOUT_MODE_CLASSIC": "Clássico",
        "LAYOUT_MODE_GRID": "Grade",
        "LAYOUT_MODE_LIST": "Lista",
        "LAYOUT_MODE_CLASSIC_BARE": "Clássico (bare)",
        "LAYOUT_MODE_GRID_BARE": "Grade (bare)",
        "LAYOUT_MODE_LIST_BARE": "Lista (bare)",
        "LOAD_HEROES": "Carregar heroes",
        "LOAD_ICONS": "Carregar ícones",
        "LOAD_VERSIONS": "Carregar versões",
        "LOOP_DEVICE_CREATION_FAILED": "Falha ao criar loop device:\n{error}",
        "LOOP_DEVICE_NOT_FOUND": "Loop device não encontrado",
        "MANAGE_SHORTCUTS": "Gerenciar atalhos",
        "MANDATORY_FIELD_ERROR": "É obrigatório que a invocação tenha um nome.",
        "MANDATORY_FIELDS_ERROR": "Nome e executável são obrigatórios.",
        "MARK_LISTED": "Marcar listados",
        "MENU_FOLDER": "Pasta menu",
        "MODIFY_INVOCATION": "Modificar invocação",
        "MOVE_SHORTCUTS_CONFIRM": "Deseja mover os atalhos de \"{old}\" para \"{new}\"?",
        "MULTIPLE_INVOCATION_EDITOR": "Editor de multiplas invocações",
        "MULTIPLE_INVOCATION_CREATOR": "Criador de múltiplas invocações",
        "MULTIPLE_INVOCATION_REMOVER": "Removedor de múltiplas invocações",
        "NAME": "Nome",
        "NAME_INVALID": "O nome é inválido, selecione outro.",
        "NAME_INVALID_IN_MULTIPLE": "O nome '{name}' é inválido, selecione outro.",
        "NEW_VERSION_AVAILABLE": "Nova versão encontrada: '{version}'.<br>Deseja ir para o repositório?",
        "NO_BUTTON": "Não",
        "NO_IMAGES": "Nenhuma imagem encontrada.",
        "NO_EXEC_PATH": "Um executável não foi escolhido para essa invocação.<br>Executar ela pode gerar problemas. Continuar?",
        "NO_EXECUTABLE_SELECTED": "Você não selecionou executáveis",
        "NO_FILES_EXTRACTED": "Nenhum arquivo foi extraído do pacote do runner.",
        "NO_GAME_SELECTED_ERROR": "Nenhum jogo selecionado",
        "NO_INVOCATION_SELECTED_ERROR": "Nenhuma invocação encontrada, adicione uma à lista.",
        "NO_INVOCATION_SELECTED_MULTIPLE": "Nenhuma invocação selecionada",
        "NO_INVOCATIONS_FOUND": "Nenhuma invocação foi encontrada.",
        "NO_PYQT6_FOUND_ERROR": "PyQt6 não encontrado.",
        "NO_RESULTS": "Nenhum resultado.",
        "NO_RUNNER_SELECTED_ERROR": "Por favor, selecione um runner para baixar.",
        "NO_TAGS_FOUND": "Nenhuma tag encontrada no repositório.",
        "NORMAL_RUN": "Execução normal",
        "OK_BUTTON": "OK",
        "OPEN_EXEC_PATH": "Abrir pasta do executável",
        "OPEN_PATH_ERROR": "Não foi possível encontrar esse caminho no seu dispositivo:<br>{path}",
        "OPEN_PREFIX_PATH": "Abrir pasta prefixo",
        "OPEN_REPO": "Abrir repositório",
        "PLACEHOLDER_FOR_LANGUAGE": "- Sem idioma escolhido -",
        "PLACEHOLDER_FOR_RUNNER": "- Runner padrão -",
        "PREFIX_PATH_NOT_FOUND": "O prefixo dessa invocação não foi encontrado:<br>\"{path}\"",
        "PREFIX_REMOTION_INFORMATION": "Prefixo que seria apagado",
        "PREFIXES_REMOTION_INFORMATION": "Prefixos que seriam apagados",
        "PREFIX_IN_USE_MESSAGE": "O prefixo está sendo usado por outras invocações.",
        "PREFIXES_IN_USE_MESSAGE": "Os prefixos estão sendo usados por várias invocações.",
        "PREFIX_PATH": "Prefixo",
        "QT_STYLE": "Estilo do QT",
        "REMOVE": "Remover",
        "REMOVE_MULTIPLE_INVOCATIONS": "Remover várias invocações",
        "REMOVE_SELECTED": "Remover selecionado",
        "REMOVE_RUNNER_ERROR": "Não foi possível remover o runner: {error}",
        "RENAME_PREFIX_QUESTION": "O nome de invocação mudou de \"{old}\" para \"{new}\".<br>Deseja renomear a pasta prefixo?",
        "RESET_BUTTON_MULTIPLE_EDIT": "Resetar",
        "RUN_IN_PREFIX": "Executar no prefixo",
        "RUN_IN_PREFIX_DONE": "Executar no prefixo foi concluído.",
        "RUN_IN_PREFIX_INVOCATION_NAME": "Executar no prefixo da: {invocation_name}",
        "RUN_IN_PREFIX_TEMP_FILE_REMOVED": "[Executar no prefixo] Invocação temporária removida: {temp_file}",
        "RUN_IN_PREFIX_WAITING": "Esperando o usuário parar a execução atual",
        "RUNNER_APPLIED_ALL": "Runner aplicado a todas as invocações da lista",
        "RUNNER_APPLY_ALL_UPDATE_ERROR": "[RunnerApplyAll] Erro ao atualizar {fname}: {e}",
        "RUNNER_EXISTS_WARNING": "Os arquivos do '{name}' existem localmente.<br>Deseja removê-los e transferir novamente?",
        "RUNNER_REMOVED_SUCCESS": "Runner '{name}' foi removido com sucesso!",
        "RUNNER_VERSION": "Runner",
        "RUNNING_COMMAND": "Executando comando: {command}",
        "RUNNING_IN_BACKGROUND": "Iniciado em segundo plano",
        "RUNNING_IN_PREFIX": "Executando no prefixo ({name}): {exe}  silent={silent}",
        "SAVE_BUTTON": "Salvar",
        "SEE_DATA": "Ver dados",
        "SEARCH": "Pesquisar",
        "SELECT": "Selecionar",
        "SELECT_ALL_IN_MULTIPLE_EDIT": "Todas",
        "SELECT_AT_LEAST_ONE_IMAGE": "Selecione pelo menos uma imagem.",
        "SELECT_EXECUTABLE": "Selecionar executável",
        "SELECT_AVAILABLE_RUNNER_CONFIRM": "O runner escolhido parece estar ausente.<br>Salvar mesmo assim?",
        "SELECT_INVOCATION_ART": "Selecionar arte",
        "SELECT_INVOCATION_GUI": "Selecionar ícone gui",
        "SELECT_PREFIX_TITLE": "Selecionar prefixo",
        "SELECTED_EXECUTABLES": "Executáveis selecionados",
        "SELECTED_INVOCATIONS": "Invocações selecionadas",
        "SETTINGS_SAVED_RESTART": "Alterações salvas.<br>Reinicie o Zordeer para aplicar as mudanças visuais.",
        "SGDB_API_KEY_LABEL": "Chave da API SteamGridDB",
        "SHORTCUTS_MANAGER_TITLE": "Gerenciador de atalhos",
        "SHORTCUTS_OF_DESKTOP": "Atalhos da área da trabalho",
        "SHORTCUTS_OF_MENU": "Atalhos do menu",
        "SHORTCUTS_PATHS": "Caminhos",
        "SHORTCUTS_SAVED": "Atalhos atualizados",
        "SHOW_FPS_OPTION": "Exibir FPS",
        "SHOW_FPS_OPTION_HUD": "HUD selecionado",
        "START_INVOCATION": "Iniciar invocação",
        "START_RANDOM_INVOCATION": "Invocação aleatória",
        "STARTING_INVOCATION": "Iniciando invocação: {name}",
        "STOP_ACCESS_ERROR": "[Parar] Erro ao acessar processo: {error}",
        "STOP_CURRENT": "Encerrar/Avançar",
        "STOP_INVOCATION": "Encerrar invocação",
        "STOP_INVOCATION_SUCCESS": "[Parar] Invocação encerrada com sucesso.",
        "STOP_KILL_ERROR": "[Parar] Erro ao encerrar processo {pid}: {error}",
        "STOP_KILL_PROCESS": "[Parar] Encerrando processo {pid} ({exe})",
        "STOP_NO_INVOCATION_ACTIVE": "[Parar] Nenhuma invocação ativa.",
        "STOP_NO_PROCESS_FOUND": "[Parar] Nenhum processo de invocação encontrado para encerrar.",
        "STOP_PROCESS_SUCCESS": "[Parar] Processo {pid} encerrado com sucesso.",
        "STORE": "Loja",
        "SYMLINK_CREATED": "Link simbólico criado: {symlink} -> {prefix}",
        "SYMLINK_ERROR": "Erro ao criar link simbólico para Proton: {error}",
        "TEMP_FILES_REMOVED": "Arquivos temporários removidos: {count}",
        "TRANSFER": "Transferir",
        "TRANSFER_AND_INSTALL_SUCCESS": "'{name}' foi transferido e extraído com sucesso!",
        "TRANSFER_ARTS": "Artes",
        "TRANSFER_ARTS_TITLE": "Transferidor de artes do Steamgriddb",
        "TRANSFER_CANCELED": "Transferência cancelada",
        "TRANSFER_ERROR": "Erro na transferência",
        "TRANSFER_FAILED": "Falha na transferência: {error}",
        "TRANSFER_RUNNERS": "Runners/UMU",
        "TRANSFER_RUNNERS_TITLE": "Transferidor de runners/UMU",
        "TRANSFER_SUMMARY": "Transferido para:\n{dir}",
        "TRANSFERRING_RUNNER": "Transferindo: {name}",
        "UMU_DATABASE": "Banco de Dados UMU",
        "UMU_DATABASE_BUTTON": "Database",
        "UMU_DATABASE_LOAD_ERROR": "Erro ao carregar banco de dados UMU: {error}",
        "UMU_DATABASE_NOT_FOUND": "O banco de dados do UMU não foi encontrado em:<br>\"{path}\"",
        "UMU_DATABASE_WINE_NOT_SUPPORTED": "Banco de dados UMU não está disponível para Wine.<br>Use um runner Proton.",
        "UMU_NOT_FOUND": "UMU não encontrado em:<br>{path}",
        "UMU_VERSION": "Versão do UMU",
        "UNMARK_LISTED": "Desmarcar listados",
        "UPDATE_ERROR": "Erro ao verificar atualizações:<br>{error}",
        "UPDATE_SHORTCUTS": "Atualizar atalhos",
        "UNAVAILABLE": "Indisponível",
        "USE_ANIMARIUM_PREFIX": "Usar o animarium_prefix",
        "USE_ANIMARIUM_PREFIX_FOR_ALL": "Usar o animarium_prefix em todas as invocações",
        "USE_AUTO_PREFIX_FOR_ALL": "Definir prefixos com base na pasta drive_c (Caso exista)",
        "USE_MS_LANGUAGE_CODE": "Usar código de idioma da Microsoft",
        "USE_ON_ALL": "Usar em todas",
        "USE_UMU_LAUNCHER": "Usar UMU launcher (Somente Proton)",
        "USE_UMU_LAUNCHER_TOOLTIP": "Transfere arquivos em segundo plano.<br>A primeira execução pode demorar.",
        "USING_PYQT6": "Usando PyQt6",
        "WINE_NOT_FOUND": "Wine não foi encontrado, verifique se ele está instalado",
        "WINECFG_BUTTON": "Winecfg",
        "YES_BUTTON": "Sim",
        "ZORDEER_CLOSED": "Zordeer fechado. Finalizando processos...",
        "ZORDEER_SETTINGS": "Preferências do Zordeer",
        "ZORDEER_TRAY_TOGGLE": "Alterar visibilidade",
    }
}

# Loads translations from external TOML files.
def load_external_translations():
    external_translations = {}
    supported_languages = {"English USA": "en_US", "Português Brasil": "pt_BR"}
    
    # Translation folders
    translation_dirs = [
        Path.home() / "AppsFiles" / "Zordeer" / "translation",
        Path("/usr/share/zordeer/translation"),
        Path(__file__).parent / "translation",
        Path(sys.argv[0]).parent / "translation"
    ]
    
    for trans_dir in translation_dirs:
        if trans_dir.exists():
            for toml_file in trans_dir.glob("zordeer-translation-*.toml"):
                try:
                    lang_code = toml_file.stem.replace("zordeer-translation-", "")
                    with open(toml_file, 'r', encoding='utf-8') as f:
                        lang_data = toml.load(f)
                    
                    # Add to translations
                    external_translations[lang_code] = lang_data
                    
                    # Adds to supported languages
                    lang_name = lang_data.get("language_name", lang_code)
                    supported_languages[lang_name] = lang_code
                    
                    print(f"Loaded translation: {lang_name} ({lang_code})")
                    
                except Exception as e:
                    print(f"Error loading translation {toml_file}: {e}")
    
    return external_translations, supported_languages

# Load external translations
EXTERNAL_TRANSLATIONS, SUPPORTED_LANGUAGES = load_external_translations()

# First, try the language configured in external translations.
def tr(key, **kwargs):
    # Get the translated string (from external or embedded translations)
    translated_string = None
    
    if LANG in EXTERNAL_TRANSLATIONS:
        translation_dict = EXTERNAL_TRANSLATIONS[LANG]
        translated_string = translation_dict.get(key)
    
    # Fallback to embedded translations if not found in external
    if not translated_string:
        translation_dict = BUILTIN_TRANSLATIONS.get(LANG, BUILTIN_TRANSLATIONS['en_US'])
        translated_string = translation_dict.get(key, BUILTIN_TRANSLATIONS['en_US'].get(key, key))
    
    # If we have a translated string, process special variables and formatting
    if translated_string:
        # Replace special variables
        translated_string = translated_string.replace("{__version__}", __version__)
        translated_string = translated_string.replace("{__creator__}", __creator__)
        
        # Apply formatting with any additional kwargs
        try:
            return translated_string.format(**kwargs)
        except KeyError:
            return translated_string
    
    # If no translation found, return the key itself
    return key

# PyQt6 Imports
try:
    from PyQt6.QtWidgets import (QApplication, QMainWindow, QWidget, QVBoxLayout, QListWidget, QPushButton, QMessageBox, QToolBar, QDialog, QGridLayout, QLabel, QLineEdit, QHBoxLayout, QFileDialog, QComboBox, QCheckBox, QListWidgetItem, QStyleFactory, QProgressBar, QButtonGroup, QSplitter, QScrollArea, QRadioButton, QAbstractItemView, QTreeWidget, QTreeWidgetItem, QSystemTrayIcon, QMenu, QListView, QSpinBox, QTextEdit)
    from PyQt6.QtCore import Qt, QThread, pyqtSignal, QSize, QTimer, QEvent, QTranslator, QLibraryInfo
    from PyQt6.QtGui import QAction, QIcon, QPixmap, QPainter, QPalette, QColor, QTextCharFormat, QTextCursor
    from PyQt6.QtNetwork import QLocalServer, QLocalSocket
    print(tr("USING_PYQT6"))
except ImportError:
    print(tr("NO_PYQT6_FOUND_ERROR"))
    sys.exit(1)

# Zordeer settings (TOML)
# $HOME/AppsFiles/Zordeer/config/zordeer-settings.toml
CONFIG_DIR = Path.home() / "AppsFiles" / "Zordeer" / "config"
SETTINGS_PATH = CONFIG_DIR / "zordeer-settings.toml"

def detect_default_settings() -> dict:
    """Provides default settings for first-time creation."""
    return {
        "design": {
            "qt_style": "indefinite",
            "language": LANG if LANG else "en_US",
            "layout_mode": "classic",
            "icon_width_classic": 420,
            "icon_width_grid": 300,
            "toolbar_position": "top",
            "search_bar_visible": False,
        },
        "window": {
            "isMaximized": "",
            "isFullScreen": "",
            "start_minimized": "",
            "windowSize": [780, 640],
        },
        "shortcut": {
            "menu_dir": "",
            "desktop_dir": "",
            "zordeer_command": "zordeer",
        },
        "other": {
            "default_runner": "indefinite",
            "umu_version": "indefinite",
            "sgdb_apikey": "",
        }
    }

def load_settings() -> dict:
    """Loads settings, uses indefinite if saved style is unavailable."""
    defaults = detect_default_settings()

    try:
        with open(SETTINGS_PATH, "r", encoding="utf-8") as f:
            data = toml.load(f)
    except Exception:
        # First creation: save default settings
        save_settings(defaults)
        return defaults

    # Remove outdated or unknown top-level keys
    for key in list(data.keys()):
        if key not in defaults:
            del data[key]

    # Ensure missing top-level sections exist
    for key, value in defaults.items():
        data.setdefault(key, value)

    # Ensure missing keys inside each section
    for section in defaults:
        for key, value in defaults[section].items():
            data[section].setdefault(key, value)

    # Remove outdated keys inside sections
    for section in defaults:
        for key in list(data[section].keys()):
            if key not in defaults[section]:
                del data[section][key]

    # Validate qt_style
    current_style = data["design"]["qt_style"]
    if current_style != "indefinite" and current_style not in QStyleFactory.keys():
        data["design"]["qt_style"] = "indefinite"

    save_settings(data)
    return data

def save_settings(data: dict) -> None:
    """Saves settings in TOML."""
    CONFIG_DIR.mkdir(parents=True, exist_ok=True)
    with open(SETTINGS_PATH, "w", encoding="utf-8") as f:
        toml.dump(data, f)

class SettingsDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle(tr("ZORDEER_SETTINGS"))
        self.setMinimumSize(400, 260)

        self.settings = load_settings()

        layout = QGridLayout(self)

        # Qt Style Choice
        style_label = QLabel(tr("QT_STYLE"))
        self.style_combo = QComboBox()
        self.style_combo.addItem(tr("DEFAULT_QT_STYLE"))
        self.style_combo.addItems(QStyleFactory.keys())
        saved_style = self.settings["design"].get("qt_style", "indefinite")
        if saved_style == "indefinite":
            self.style_combo.setCurrentText(tr("DEFAULT_QT_STYLE"))
        else:
            self.style_combo.setCurrentText(saved_style)
        layout.addWidget(style_label, 0, 0)
        layout.addWidget(self.style_combo, 0, 1)

        # Language Choice
        lang_label = QLabel(tr("LANGUAGE"))
        self.lang_combo = QComboBox()
        self.lang_combo.addItems(SUPPORTED_LANGUAGES.keys())
        saved_lang = self.settings["design"].get("language", LANG)
        lang_codes = list(SUPPORTED_LANGUAGES.values())
        if saved_lang in lang_codes:
            self.lang_combo.setCurrentIndex(lang_codes.index(saved_lang))
        else:
            self.lang_combo.setCurrentIndex(0)
        layout.addWidget(lang_label, 1, 0)
        layout.addWidget(self.lang_combo, 1, 1)

        # Visualization Choice
        layout_mode_label = QLabel(tr("LAYOUT_MODE"))
        self.layout_mode_combo = QComboBox()
        self.layout_mode_combo.addItems([
            tr("LAYOUT_MODE_CLASSIC"),
            tr("LAYOUT_MODE_CLASSIC_BARE"),
            tr("LAYOUT_MODE_GRID"),
            tr("LAYOUT_MODE_GRID_BARE"),
            tr("LAYOUT_MODE_LIST"),
            tr("LAYOUT_MODE_LIST_BARE")
        ])
        saved_layout_mode = self.settings["design"].get("layout_mode", "classic")
        index_map = {"classic": 0, "classic-bare": 1, "grid": 2, "grid-bare": 3, "list": 4, "list-bare": 5}
        self.layout_mode_combo.setCurrentIndex(index_map.get(saved_layout_mode, 0))
        layout.addWidget(layout_mode_label, 2, 0)
        layout.addWidget(self.layout_mode_combo, 2, 1)

        # Icon Width for Classic
        classic_width_label = QLabel(tr("ICON_WIDTH_CLASSIC"))
        self.classic_width_input = QSpinBox()
        self.classic_width_input.setRange(100, 2000)
        self.classic_width_input.setValue(self.settings["design"].get("icon_width_classic", 420))
        layout.addWidget(classic_width_label, 3, 0)
        layout.addWidget(self.classic_width_input, 3, 1)

        # Icon Width for Grid
        grid_width_label = QLabel(tr("ICON_WIDTH_GRID"))
        self.grid_width_input = QSpinBox()
        self.grid_width_input.setRange(100, 2000)
        self.grid_width_input.setValue(self.settings["design"].get("icon_width_grid", 300))
        layout.addWidget(grid_width_label, 4, 0)
        layout.addWidget(self.grid_width_input, 4, 1)

        # Default Runner Choice
        runner_label = QLabel(tr("DEFAULT_RUNNER"))
        self.runner_combo = QComboBox()
        self.populate_runners_settings()
        # Select the correctly saved runner.
        saved_runner = self.settings["other"].get("default_runner", "")
        index = self.runner_combo.findText(saved_runner)
        if index == -1 and saved_runner and saved_runner.lower() != "indefinite":
            # Try selecting the "UNAVAILABLE" version.
            unavailable_text = f"{saved_runner} ({tr("UNAVAILABLE")})"
            index = self.runner_combo.findText(unavailable_text)
        if index != -1:
            self.runner_combo.setCurrentIndex(index)
        else:
            # If you didn't find anything, use a placeholder.
            self.runner_combo.setCurrentText(tr("INDEFINITE"))
        layout.addWidget(runner_label, 5, 0)
        layout.addWidget(self.runner_combo, 5, 1)

        # UMU Launcher Choice
        umu_label = QLabel(tr("UMU_VERSION"))
        self.umu_combo = QComboBox()
        self.populate_umu_versions()
        # Select the correctly saved UMU version
        saved_umu = self.settings["other"].get("umu_version", "")
        index = self.umu_combo.findText(saved_umu)
        if index == -1 and saved_umu and saved_umu.lower() != "indefinite":
            # Try selecting the "UNAVAILABLE" version.
            unavailable_text = f"{saved_umu} ({tr("UNAVAILABLE")})"
            index = self.umu_combo.findText(unavailable_text)
        if index != -1:
            self.umu_combo.setCurrentIndex(index)
        else:
            # If you didn't find anything, use a placeholder.
            self.umu_combo.setCurrentText(tr("INDEFINITE"))
        layout.addWidget(umu_label, 6, 0)
        layout.addWidget(self.umu_combo, 6, 1)

        # SGDB API Key
        api_label = QLabel(tr("SGDB_API_KEY_LABEL"))
        self.api_input = QLineEdit()
        self.api_input.setEchoMode(QLineEdit.EchoMode.Password)
        self.api_input.setText(self.settings["other"].get("sgdb_apikey", ""))
        layout.addWidget(api_label, 7, 0)
        layout.addWidget(self.api_input, 7, 1)

        # Save button
        save_btn = QPushButton(tr("SAVE_BUTTON"))
        save_btn.clicked.connect(self.save_and_close)
        layout.addWidget(save_btn, 8, 1, alignment=Qt.AlignmentFlag.AlignRight)

        self.setLayout(layout)

    def keyPressEvent(self, event):
        if event.key() in (Qt.Key.Key_Return, Qt.Key.Key_Enter):
            # Prevents Enter from triggering something that is not selected
            return
        super().keyPressEvent(event)

    def save_and_close(self):
        selected_runner = self.runner_combo.currentText()
        selected_umu = self.umu_combo.currentText()

        # Runner validation
        if tr("UNAVAILABLE") in selected_runner:
            reply = QMessageBox.question(
                self,
                tr("APP_NAME"),
                tr("SELECT_AVAILABLE_RUNNER_CONFIRM"),
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )
            if reply == QMessageBox.StandardButton.No:
                return

        # UMU validation
        if tr("UNAVAILABLE") in selected_umu:
            reply = QMessageBox.question(
                self,
                tr("APP_NAME"),
                tr("SELECT_AVAILABLE_UMU_CONFIRM"),
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )
            if reply == QMessageBox.StandardButton.No:
                return

        unavailable_text = f" ({tr("UNAVAILABLE")})"
        if unavailable_text in selected_runner:
            selected_runner = selected_runner.replace(unavailable_text, "")

        if unavailable_text in selected_umu:
            selected_umu = selected_umu.replace(unavailable_text, "")

        self.settings["design"]["qt_style"] = self.style_combo.currentText()
        selected_index = self.lang_combo.currentIndex()
        self.settings["design"]["language"] = list(SUPPORTED_LANGUAGES.values())[selected_index]
        self.settings["design"]["layout_mode"] = ["classic", "classic-bare", "grid", "grid-bare", "list", "list-bare"][self.layout_mode_combo.currentIndex()]
        if selected_runner == tr("INDEFINITE"):
            self.settings["other"]["default_runner"] = "indefinite"
        else:
            self.settings["other"]["default_runner"] = selected_runner
        self.settings["other"]["sgdb_apikey"] = self.api_input.text().strip()
        if selected_umu == tr("INDEFINITE"):
            self.settings["other"]["umu_version"] = "indefinite"
        else:
            self.settings["other"]["umu_version"] = selected_umu

        # Save the icon widths
        self.settings["design"]["icon_width_classic"] = self.classic_width_input.value()
        self.settings["design"]["icon_width_grid"] = self.grid_width_input.value()

        save_settings(self.settings)
        QMessageBox.information(self, tr("APP_NAME"), tr("SETTINGS_SAVED_RESTART"))
        self.accept()

    def populate_runners_settings(self):
        runners_path = Path.home() / "AppsFiles" / "Zordeer" / "runner"
        runners_path.mkdir(parents=True, exist_ok=True)
        available_runners = sorted([d.name for d in runners_path.iterdir() if d.is_dir()], reverse=True)

        items = [tr("INDEFINITE")]

        # Add Wine only if wine command is found
        if shutil.which("wine"):
            items.append("Wine")

        items += available_runners

        # Add current runner from settings if it's not in the folder
        saved_runner = self.settings["other"].get("default_runner", "")
        if saved_runner and saved_runner not in items and saved_runner.lower() != "indefinite":
            items.append(f"{saved_runner} ({tr("UNAVAILABLE")})")

        self.runner_combo.clear()
        self.runner_combo.addItems(items)

    def populate_umu_versions(self):
        umu_path = Path.home() / "AppsFiles" / "Zordeer" / "umu-launcher"
        umu_path.mkdir(parents=True, exist_ok=True)
        
        # Check if each folder has the umu-run file
        available_umu = sorted([
            d.name for d in umu_path.iterdir() 
            if d.is_dir() and (d / "umu-run").exists()
        ], reverse=True)

        items = [tr("INDEFINITE")]
        items += available_umu

        # Add current UMU version from settings if it's not in the folder
        saved_umu = self.settings["other"].get("umu_version", "")
        if saved_umu and saved_umu not in items and saved_umu.lower() != "indefinite":
            items.append(f"{saved_umu} ({tr("UNAVAILABLE")})")

        self.umu_combo.clear()
        self.umu_combo.addItems(items)

# Transfer Worker Thread
class TransferWorker(QThread):
    progress = pyqtSignal(int)
    message = pyqtSignal(str)
    finished = pyqtSignal(str)
    error = pyqtSignal(str)

    def __init__(self, url, runner_name, runners_dir, parent=None):
        super().__init__(parent)
        self.url = url
        self.runner_name = runner_name
        self.runners_dir = Path(runners_dir)
        self.cancelled = False
        self.finished_transfer = False


    def cancel(self):
        self.cancelled = True

    def run(self):
        try:
            self.message.emit(tr("TRANSFERRING_RUNNER", name=Path(self.url).name))
            response = requests.get(self.url, stream=True, timeout=30)
            response.raise_for_status()

            total_size = int(response.headers.get('content-length', 0))
            bytes_transferred = 0

            temp_file = io.BytesIO()
            for chunk in response.iter_content(chunk_size=8192):
                if self.cancelled and not self.finished_transfer:
                    self.message.emit(tr("TRANSFER_CANCELED"))
                    return

                temp_file.write(chunk)
                bytes_transferred += len(chunk)
                if total_size > 0:
                    self.progress.emit(min(int(bytes_transferred / total_size * 100), 100))

            temp_file.seek(0)

            self.message.emit(tr("EXTRACTING", name=Path(self.url).name))

            if "umu" in self.runner_name.lower() or "UMU" in self.runner_name:
                base_dir = self.runners_dir.parent / "umu-launcher"
            else:
                base_dir = self.runners_dir
            
            base_dir.mkdir(parents=True, exist_ok=True)
            runner_destination_path = base_dir / self.runner_name
            initial_files = set(base_dir.iterdir())

            # Open the tar
            with tarfile.open(fileobj=temp_file, mode="r:*") as tf:
                members = list(tf.getmembers())

                # Automatically detect the root folder containing the files
                root_dirs = set()
                for m in members:
                    if m.isdir() and any(mm.name.startswith(m.name.rstrip('/') + '/') for mm in members if mm.isfile()):
                        root_dirs.add(m.name.rstrip('/'))

                # If not found, use all files
                if not root_dirs:
                    selected_members = members
                else:
                    # Select all files within the first detected folder
                    root = sorted(root_dirs)[0]
                    selected_members = [m for m in members if m.name.startswith(root + '/')]

                # Python 3.14+: safer extraction
                tf.extractall(path=base_dir, members=selected_members, filter="data")

            final_files = set(base_dir.iterdir())
            new_entries = list(final_files - initial_files)

            if not new_entries:
                self.error.emit(tr("NO_FILES_EXTRACTED"))
                return

            # Move the detected folder to the runner destination path
            extracted_path = new_entries[0]
            if extracted_path != runner_destination_path:
                if runner_destination_path.exists():
                    shutil.rmtree(runner_destination_path)
                shutil.move(str(extracted_path), str(runner_destination_path))

            self.finished_transfer = True
            self.finished.emit(tr("TRANSFER_AND_INSTALL_SUCCESS", name=Path(self.url).name))

        except requests.exceptions.RequestException as e:
            self.error.emit(tr("TRANSFER_FAILED", error=str(e)))
        except tarfile.TarError as e:
            self.error.emit(tr("TRANSFER_ERROR", error=str(e)))
        except Exception as e:
            self.error.emit(tr("TRANSFER_ERROR", error=str(e)))

class RunnerTransferDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle(tr("TRANSFER_RUNNERS_TITLE"))
        self.resize(450, 420)
        self.setMinimumSize(400, 200)
        self.parent = parent

        main_layout = QVBoxLayout(self)

        # Runner selection layout
        selection_layout = QHBoxLayout()
        self.runner_combo = QComboBox()
        self.runner_combo.addItems(["Proton-GE", "Proton-Sarek", "Proton-EM", "Proton-CachyOS", "UMU-launcher"])
        selection_layout.addWidget(self.runner_combo)
        main_layout.addLayout(selection_layout)

        buttons_layout = QHBoxLayout()

        # Button to open the repository of the selected runner
        self.repo_button = QPushButton(tr("OPEN_REPO"))
        self.repo_button.clicked.connect(self.open_runner_repo)
        buttons_layout.addWidget(self.repo_button)

        # Button to manually load releases
        self.load_button = QPushButton(tr("LOAD_VERSIONS"))
        self.load_button.clicked.connect(self.handle_load_versions)
        buttons_layout.addWidget(self.load_button)

        main_layout.addLayout(buttons_layout)

        # Scroll area for versions
        self.scroll = QScrollArea()
        self.scroll.setWidgetResizable(True)

        self.container = QWidget()
        self.layout = QVBoxLayout(self.container)
        self.layout.setContentsMargins(6, 6, 6, 6)
        self.layout.setSpacing(4)
        self.scroll.setWidget(self.container)

        main_layout.addWidget(self.scroll)

        # Button group for radio buttons
        self.button_group = QButtonGroup(self)
        self.button_group.setExclusive(True)
        self.button_group.buttonToggled.connect(self.update_transfer_button_state)

        # Transfer button always visible
        self.transfer_button = QPushButton(tr("TRANSFER"))
        self.transfer_button.clicked.connect(self.start_transfer)
        self.transfer_button.setEnabled(False)  # Disabled until something is selected
        main_layout.addWidget(self.transfer_button)

        # Fixed progress bar at the bottom
        self.progress_bar = QProgressBar()
        self.progress_bar.setMinimum(0)
        self.progress_bar.setMaximum(100)
        self.progress_bar.setValue(0)
        main_layout.addWidget(self.progress_bar)

        # Map of runner URLs
        self.runner_urls = {
            "Proton-GE": "https://api.github.com/repos/GloriousEggroll/proton-ge-custom/releases",
            "Proton-Sarek": "https://api.github.com/repos/pythonlover02/Proton-Sarek/releases",
            "Proton-EM": "https://api.github.com/repos/Etaash-mathamsetty/Proton/releases",
            "Proton-CachyOS": "https://api.github.com/repos/CachyOS/proton-cachyos/releases",
            "UMU-launcher": "https://api.github.com/repos/Open-Wine-Components/umu-launcher/releases",
        }

    def open_runner_repo(self):
        selected_runner = self.runner_combo.currentText()
        urls = {
            "Proton-GE": "https://github.com/GloriousEggroll/proton-ge-custom",
            "Proton-Sarek": "https://github.com/pythonlover02/Proton-Sarek",
            "Proton-EM": "https://github.com/Etaash-mathamsetty/Proton",
            "Proton-CachyOS": "https://github.com/CachyOS/proton-cachyos",
            "UMU-launcher": "https://github.com/Open-Wine-Components/umu-launcher",
        }
        url = urls.get(selected_runner)
        if url:
            import webbrowser
            webbrowser.open(url)

    def closeEvent(self, event):
        if hasattr(self, "worker") and self.worker.isRunning() and not self.worker.finished_transfer:
            self.worker.cancel()
        event.accept()

    def keyPressEvent(self, event):
        if event.key() in (Qt.Key.Key_Return, Qt.Key.Key_Enter):
            return
        super().keyPressEvent(event)

    def handle_load_versions(self):
        runner_type = self.runner_combo.currentText()
        self.load_releases(runner_type)

    def load_releases(self, runner_type):
        url = self.runner_urls[runner_type]

        try:
            response = requests.get(url, timeout=(5, 30))
            response.raise_for_status()
            releases = response.json()

            # Clear existing items
            for btn in self.button_group.buttons():
                self.button_group.removeButton(btn)
                btn.deleteLater()

            while self.layout.count():
                it = self.layout.takeAt(0)
                w = it.widget()
                if w:
                    w.deleteLater()

            first_rb = None

            for release in releases[:30]:
                for asset in release.get('assets', []):
                    display_name = None

                    if runner_type == "UMU-launcher":
                        if asset['name'].endswith('-zipapp.tar'):
                            display_name = asset['name']
                    else:
                        if asset['name'].endswith(('.tar.gz', '.tar.xz')):
                            display_name = asset['name']

                    if display_name:
                        rb = QRadioButton(display_name)
                        rb.setProperty("runner_data", {
                            'tag_name': release['tag_name'],
                            'url': asset['browser_download_url'],
                            'display_name': display_name
                        })

                        self.button_group.addButton(rb)
                        self.layout.addWidget(rb)

                        if first_rb is None:
                            first_rb = rb

            if first_rb:
                first_rb.setChecked(True)

            self.update_transfer_button_state()

        except requests.exceptions.RequestException as e:
            QMessageBox.critical(self, tr("APP_NAME"), tr("TRANSFER_ERROR") + f"\n{e}")

    def update_transfer_button_state(self):
        self.transfer_button.setEnabled(self.button_group.checkedButton() is not None)

    def start_transfer(self):
        checked = self.button_group.checkedButton()
        if not checked:
            QMessageBox.warning(self, tr("APP_NAME"), tr("NO_VERSION_SELECTED_ERROR"))
            return

        item_data = checked.property("runner_data")
        tag_name = item_data['tag_name']
        url = item_data['url']

        selected_runner = self.runner_combo.currentText()
        
        if selected_runner == "UMU-launcher":
            runner_folder_name = f"umu-{tag_name}"
            base_dir = Path.home() / "AppsFiles" / "Zordeer" / "umu-launcher"
        else:
            formatted_tag = tag_name.replace('GE-Proton-', '').replace('GE-Proton', '')
            if selected_runner == "Proton-GE":
                runner_folder_name = f"Proton-GE-{formatted_tag}"
            else:
                file_name = Path(url).name
                runner_folder_name = file_name.replace(".tar.gz", "").replace(".tar.xz", "")
            base_dir = Path.home() / "AppsFiles" / "Zordeer" / "runner"

        runner_path = base_dir / runner_folder_name

        if runner_path.exists():
            reply = QMessageBox.question(
                self,
                tr("APP_NAME"),
                tr("RUNNER_EXISTS_WARNING", name=item_data['display_name']),
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )
            if reply == QMessageBox.StandardButton.No:
                return

            try:
                shutil.rmtree(runner_path)
            except Exception as e:
                QMessageBox.critical(self, tr("APP_NAME"), tr("REMOVE_RUNNER_ERROR", error=str(e)))
                return

        # Disable window during transfer
        self.setEnabled(False)
        self.progress_bar.setValue(0)

        self.worker = TransferWorker(url, runner_folder_name, base_dir)
        self.worker.progress.connect(self.progress_bar.setValue)
        self.worker.message.connect(lambda msg: print(msg))
        self.worker.finished.connect(
            lambda msg: [
                self.progress_bar.setValue(100),
                self.setEnabled(True),
                QMessageBox.information(self, tr("APP_NAME"), msg),
                self.progress_bar.setValue(0)
            ]
        )
        self.worker.error.connect(
            lambda msg: [
                QMessageBox.critical(self, tr("APP_NAME"), msg),
                self.setEnabled(True)
            ]
        )
        self.worker.start()

class AddInvocationDialog(QDialog):
    # Defining a custom signal that doesn't need arguments
    invocation_saved = pyqtSignal()
    
    def __init__(self, parent=None, invocation_data=None):
        super().__init__(parent)
        self.DEFAULT_PREFIX_NAME = "animarium_prefix"
        self.invocation_data = invocation_data
        
        if self.invocation_data:
            self.setWindowTitle(tr("MODIFY_INVOCATION"))
        else:
            self.setWindowTitle(tr("CREATE_INVOCATION"))
            
        self.resize(600, 400)
        
        self.main_layout = QGridLayout(self)
        
        self.name_label = QLabel(tr("INVOCATION_NAME"))
        self.name_input = QLineEdit()

        # Only connect update_prefix_path if it is "Add Invocation"
        if not self.invocation_data:  
            self.name_input.textChanged.connect(self.update_prefix_path)

        self.main_layout.addWidget(self.name_label, 0, 0)
        self.main_layout.addWidget(self.name_input, 0, 1, 1, 2)

        self.runner_label = QLabel(tr("RUNNER_VERSION"))
        self.runner_input = QComboBox()
        self.populate_runners()
        self.main_layout.addWidget(self.runner_label, 1, 0)
        self.main_layout.addWidget(self.runner_input, 1, 1, 1, 2)

        self.exec_path_label = QLabel(tr("EXECUTABLE_PATH"))
        self.exec_path_input = QLineEdit()
        self.exec_button = QPushButton(tr("BROWSE_BUTTON"))
        self.exec_button.clicked.connect(self.select_executable)
        
        self.main_layout.addWidget(self.exec_path_label, 2, 0)
        self.main_layout.addWidget(self.exec_path_input, 2, 1)
        self.main_layout.addWidget(self.exec_button, 2, 2)

        self.prefix_path_label = QLabel(tr("PREFIX_PATH"))
        self.prefix_path_input = QLineEdit()
        self.prefix_path_input.setPlaceholderText(tr("ANIMARIUM_PREFIX_PLACEHOLDER"))
        self.prefix_button = QPushButton(tr("BROWSE_BUTTON"))
        self.prefix_button.clicked.connect(self.select_prefix)
        
        self.main_layout.addWidget(self.prefix_path_label, 3, 0)
        self.main_layout.addWidget(self.prefix_path_input, 3, 1)
        self.main_layout.addWidget(self.prefix_button, 3, 2)

        self.invocation_art_label = QLabel(tr("INVOCATION_ART_PATH"))
        self.invocation_art_input = QLineEdit()

        self.invocation_art_button = QPushButton(tr("BROWSE_BUTTON"))
        self.invocation_art_button.clicked.connect(self.select_invocation_art)

        self.main_layout.addWidget(self.invocation_art_label, 4, 0)
        self.main_layout.addWidget(self.invocation_art_input, 4, 1)
        self.main_layout.addWidget(self.invocation_art_button, 4, 2)

        self.invocation_gui_label = QLabel(tr("INVOCATION_GUI_PATH"))
        self.invocation_gui_input = QLineEdit()

        self.invocation_gui_button = QPushButton(tr("BROWSE_BUTTON"))
        self.invocation_gui_button.clicked.connect(self.select_invocation_gui)

        self.main_layout.addWidget(self.invocation_gui_label, 5, 0)
        self.main_layout.addWidget(self.invocation_gui_input, 5, 1)
        self.main_layout.addWidget(self.invocation_gui_button, 5, 2)

        self.language_label = QLabel(tr("INVOCATION_LANGUAGE"))
        self.language_input = QComboBox()
        self.language_input.addItems([
            tr("PLACEHOLDER_FOR_LANGUAGE"),
            'English USA (en_US.UTF-8)',
            'Português Brasil (pt_BR.UTF-8)',
            'Português Portugal (pt_PT.UTF-8)',
            'Español España (es_ES.UTF-8)',
            'Español México (es_MX.UTF-8)',
            'Français (fr_FR.UTF-8)',
            'Deutsch (de_DE.UTF-8)',
            'Italiano (it_IT.UTF-8)',
            'Русский (ru_RU.UTF-8)',
            'Українська (uk_UA.UTF-8)',
            'Polski (pl_PL.UTF-8)',
            'Česky (cs_CZ.UTF-8)',
            'Slovenčina (sk_SK.UTF-8)',
            'Magyar (hu_HU.UTF-8)',
            'Română (ro_RO.UTF-8)',
            'Nederlands (nl_NL.UTF-8)',
            'Svenska (sv_SE.UTF-8)',
            'Norsk Bokmål (nb_NO.UTF-8)',
            'Dansk (da_DK.UTF-8)',
            'Suomi (fi_FI.UTF-8)',
            'Ελληνικά (el_GR.UTF-8)',
            'Български (bg_BG.UTF-8)',
            '日本語 (ja_JP.UTF-8)',
            '한국어 (ko_KR.UTF-8)',
            '简体中文 (zh_CN.UTF-8)',
            '繁體中文 (zh_TW.UTF-8)',
            'العربية (ar_SA.UTF-8)',
            'فارسی (fa_IR.UTF-8)',
            'Türkçe (tr_TR.UTF-8)',
            'हिन्दी (hi_IN.UTF-8)',
            'ไทย (th_TH.UTF-8)',
            'עברית (he_IL.UTF-8)',
        ])
        self.main_layout.addWidget(self.language_label, 6, 0)
        self.main_layout.addWidget(self.language_input, 6, 1, 1, 2)

        self.ms_language_code_checkbox = QCheckBox(tr("USE_MS_LANGUAGE_CODE"))
        self.ms_language_code_checkbox.setChecked(False)
        self.main_layout.addWidget(self.ms_language_code_checkbox, 7, 0, 1, 3)

        self.force_opengl_layout = QHBoxLayout()
        self.force_opengl_checkbox = QCheckBox(tr("FORCE_OPENGL"))
        self.force_opengl_checkbox.setChecked(False)
        self.main_layout.addWidget(self.force_opengl_checkbox, 8, 0, 1, 3)

        self.gamemode_checkbox = QCheckBox(tr("GAMEMODE"))
        self.gamemode_checkbox.setChecked(True)
        self.main_layout.addWidget(self.gamemode_checkbox, 9, 0, 1, 3)

        self.umu_checkbox = QCheckBox(tr("USE_UMU_LAUNCHER"))
        self.umu_checkbox.setChecked(False)
        self.umu_checkbox.setToolTip(tr("USE_UMU_LAUNCHER_TOOLTIP"))
        self.umu_checkbox.stateChanged.connect(self.toggle_umu_button)
        self.main_layout.addWidget(self.umu_checkbox, 10, 0, 1, 3)

        self.umu_search_button = QPushButton(tr("UMU_DATABASE_BUTTON"))
        self.umu_search_button.clicked.connect(self.open_umu_search)
        self.umu_search_button.setEnabled(False)
        self.main_layout.addWidget(self.umu_search_button, 10, 2)

        self.fps_layout = QHBoxLayout()
        self.show_fps_checkbox = QCheckBox(tr("SHOW_FPS_OPTION"))
        self.show_fps_checkbox.setChecked(False)
        self.fps_hud_combo = QComboBox()
        self.fps_hud_options = [("FPS_GALLIUM_HUD", tr("FPS_GALLIUM_HUD")), ("FPS_DXVK_HUD", tr("FPS_DXVK_HUD")), ("FPS_MANGOHUD", tr("FPS_MANGOHUD"))]
        self.fps_hud_combo.clear()
        for id, text in self.fps_hud_options:
            self.fps_hud_combo.addItem(text, id)  # Text is displayed, id is stored
        self.show_fps_checkbox.stateChanged.connect(self.update_fps_hud_state)
        self.fps_layout.addWidget(self.show_fps_checkbox)
        self.fps_layout.addWidget(self.fps_hud_combo)
        self.fps_hud_combo.setEnabled(False)
        self.main_layout.addLayout(self.fps_layout, 11, 0, 1, 3)

        self.env_vars_label = QLabel(tr("ENVIRONMENT_VARS"))
        self.env_vars_input = QLineEdit()
        self.main_layout.addWidget(self.env_vars_label, 12, 0)
        self.main_layout.addWidget(self.env_vars_input, 12, 1, 1, 2)

        self.invocation_args_label = QLabel(tr("INVOCATION_ARGS"))
        self.invocation_args_input = QLineEdit()
        self.main_layout.addWidget(self.invocation_args_label, 13, 0)
        self.main_layout.addWidget(self.invocation_args_input, 13, 1, 1, 2)
        
        self.buttons_layout = QHBoxLayout()
        
        self.remove_invocation_button = QPushButton(tr("REMOVE"))
        
        self.save_button = QPushButton(tr("SAVE_BUTTON"))
        self.save_button.clicked.connect(self.save_and_accept)
        
        # Add delete buttons only if the dialog is for editing
        if self.invocation_data:
            # Remove button
            self.buttons_layout.addWidget(self.remove_invocation_button)
            self.remove_invocation_button.clicked.connect(self.delete_invocation)
            # Winecfg button
            self.winecfg_button = QPushButton(tr("WINECFG_BUTTON"))
            self.buttons_layout.addWidget(self.winecfg_button)
            self.winecfg_button.clicked.connect(self.open_winecfg)

        self.buttons_layout.addStretch()
        self.buttons_layout.addWidget(self.save_button)
        
        self.main_layout.addLayout(self.buttons_layout, 14, 0, 1, 3)
        
        if self.invocation_data:
            self.load_invocation_data()

    def toggle_umu_button(self, state):
        self.umu_search_button.setEnabled(self.umu_checkbox.isChecked())

    def open_umu_search(self):
        current_env_vars = self.env_vars_input.text()

        # Uses the selected runner; if empty, uses the default.
        runner_name = self.runner_input.currentText().strip()
        if runner_name == tr("PLACEHOLDER_FOR_RUNNER"):
            runner_name = ""
        
        dialog = UMUGameSearchDialog(self, runner_name, current_env_vars)
        if dialog.exec() == QDialog.DialogCode.Accepted:
            self.env_vars_input.setText(dialog.selected_env_vars)

    def keyPressEvent(self, event):
        if event.key() in (Qt.Key.Key_Return, Qt.Key.Key_Enter):
            # Prevents Enter from triggering something that is not selected
            return
        super().keyPressEvent(event)

    def update_fps_hud_state(self, state):
        self.fps_hud_combo.setEnabled(self.show_fps_checkbox.isChecked())

    def load_invocation_data(self):
        """Populates the form with invocation data for editing."""
        self.name_input.setText(self.invocation_data.get('name', ''))
        self.exec_path_input.setText(self.invocation_data.get('exec_path', ''))
        self.prefix_path_input.setText(self.invocation_data.get('prefix_path', ''))
        self.invocation_art_input.setText(self.invocation_data.get('art_path', ''))
        self.invocation_gui_input.setText(self.invocation_data.get('gui_path', ''))
        
        env_vars_text = self.invocation_data.get('env_vars', '').strip()
        self.env_vars_input.setText(env_vars_text)

        self.invocation_args_input.setText(self.invocation_data.get('invocation_args', ''))
        
        runner = self.invocation_data.get('runner', '')
        index_runner = self.runner_input.findText(runner)
        if index_runner != -1:
            self.runner_input.setCurrentIndex(index_runner)
        
        # Fix: Search for the full language string
        language = self.invocation_data.get('language', '')
        index_lang = self.language_input.findText(language)
        if index_lang != -1:
            self.language_input.setCurrentIndex(index_lang)

        use_ms_language_code = self.invocation_data.get("use_ms_language_code", False)
        self.ms_language_code_checkbox.setChecked(use_ms_language_code)
            
        force_opengl = self.invocation_data.get('force_opengl', False)
        self.force_opengl_checkbox.setChecked(force_opengl)
        
        use_gamemode = self.invocation_data.get('use_gamemode', True)
        self.gamemode_checkbox.setChecked(use_gamemode)

        use_umu = self.invocation_data.get('use_umu', False)
        self.umu_checkbox.setChecked(use_umu)

        show_fps = self.invocation_data.get('show_fps', False)
        self.show_fps_checkbox.setChecked(show_fps)
        self.update_fps_hud_state(Qt.CheckState.Checked if show_fps else Qt.CheckState.Unchecked)
        
        fps_hud_type = self.invocation_data.get('fps_hud_type', '')
        index_hud = self.fps_hud_combo.findData(fps_hud_type)  # Search by "id"
        if index_hud != -1:
            self.fps_hud_combo.setCurrentIndex(index_hud)

    def update_prefix_path(self, name):
        """Generates a default prefix path based on the invocation name."""
        invocation_dir = name.replace(" ", "_").lower()
        if invocation_dir:
            default_path = Path.home() / "AppsFiles" / "Zordeer" / "invocation" / invocation_dir
            self.prefix_path_input.setText(str(default_path))

    def populate_runners(self):
        """Lists the available runner options and adds a warning if the runner chosen for the invocation is no longer available."""
        runners_path = Path.home() / "AppsFiles" / "Zordeer" / "runner"
        runners_path.mkdir(parents=True, exist_ok=True)

        available_runners = sorted([d.name for d in runners_path.iterdir() if d.is_dir()], reverse=True)

        items = [tr("PLACEHOLDER_FOR_RUNNER")]

        # Add Wine only if wine command is found
        if shutil.which("wine"):
            items.append("Wine")

        items += available_runners

        # Adds the current runner with a warning if it's not available.
        if self.invocation_data:
            current_runner = self.invocation_data.get("runner", "")
            if current_runner and current_runner not in items:
                items.append(f"{current_runner} ({tr("UNAVAILABLE")})")

        self.runner_input.clear()
        self.runner_input.addItems(items)

        # Select the correct runner.
        if self.invocation_data:
            runner_to_select = self.invocation_data.get("runner", "")
            index = self.runner_input.findText(runner_to_select)
            if index == -1 and runner_to_select:
                index = self.runner_input.findText(f"{runner_to_select} ({tr("UNAVAILABLE")})")
            if index != -1:
                self.runner_input.setCurrentIndex(index)

    def select_executable(self):
        # Paths in order of priority
        drive_c = Path(self.prefix_path_input.text().strip()) / "drive_c"
        prefix = Path(self.prefix_path_input.text().strip())
        invocations = Path(self.parent().zordeer_dir) / "invocation"

        # Choose the first one that exists
        start_dir = drive_c if drive_c.exists() else prefix if prefix.exists() else invocations

        file_path, _ = QFileDialog.getOpenFileName(
            self,
            tr("SELECT_EXECUTABLE"),
            str(start_dir),
            tr("EXECUTABLE_FILE_FILTER")
        )

        if file_path:
            self.exec_path_input.setText(file_path)

    def select_prefix(self):
        invocations_dir = Path(self.parent().zordeer_dir) / "invocation"
        invocations_dir.mkdir(parents=True, exist_ok=True)

        dir_path = QFileDialog.getExistingDirectory(
            self,
            tr("SELECT_PREFIX_TITLE"),
            str(invocations_dir)
        )
        if dir_path:
            self.prefix_path_input.setText(dir_path)

    def select_invocation_art(self):
        heroes_dir = Path(self.parent().zordeer_dir) / "sgdb" / "heroes"
        heroes_dir.mkdir(parents=True, exist_ok=True)

        file_path, _ = QFileDialog.getOpenFileName(
            self,
            tr("SELECT_INVOCATION_ART"),
            str(heroes_dir),
            tr("IMAGE_FILTER")
        )
        if file_path:
            self.invocation_art_input.setText(file_path)

    def select_invocation_gui(self):
        icons_dir = Path(self.parent().zordeer_dir) / "sgdb" / "icons"
        icons_dir.mkdir(parents=True, exist_ok=True)

        file_path, _ = QFileDialog.getOpenFileName(
            self,
            tr("SELECT_INVOCATION_GUI"),
            str(icons_dir),
            tr("IMAGE_FILTER")
        )
        if file_path:
            self.invocation_gui_input.setText(file_path)

    def get_form_data(self):
        """Gets data from the form fields."""
        selected_runner = self.runner_input.currentText()
        if selected_runner == tr("PLACEHOLDER_FOR_RUNNER"):
            selected_runner = ""
        
        selected_lang = self.language_input.currentText()
        if selected_lang == tr("PLACEHOLDER_FOR_LANGUAGE"):
            selected_lang = ""
            
        env_vars_text = self.env_vars_input.text().strip()
        
        force_opengl = self.force_opengl_checkbox.isChecked()
        use_gamemode = self.gamemode_checkbox.isChecked()
        use_umu = self.umu_checkbox.isChecked()
        show_fps = self.show_fps_checkbox.isChecked()
        fps_hud_type = self.fps_hud_combo.currentData()  # Get the "id", not the text
        use_ms_language_code = self.ms_language_code_checkbox.isChecked()

        prefix_text = self.prefix_path_input.text().strip()
        if not prefix_text:  # If empty, use default
            prefix_text = str(Path.home() / "AppsFiles" / "Zordeer" / "invocation" / self.DEFAULT_PREFIX_NAME)

        art_path = self.invocation_art_input.text().strip()
        if not art_path:
            art_path = self.resolve_default_art_path(self.name_input.text())

        gui_path = self.invocation_gui_input.text().strip()
        if not gui_path:
            gui_path = self.resolve_default_gui_path(self.name_input.text())

        return {
            "name": self.name_input.text(),
            "runner": selected_runner,
            "exec_path": self.exec_path_input.text(),
            "prefix_path": prefix_text,
            "art_path": art_path,
            "gui_path": gui_path,
            "language": selected_lang,
            "use_ms_language_code": use_ms_language_code,
            "force_opengl": force_opengl,
            "use_gamemode": use_gamemode,
            "use_umu": use_umu,
            "show_fps": show_fps,
            "fps_hud_type": fps_hud_type,
            "env_vars": env_vars_text,
            "invocation_args": self.invocation_args_input.text(),
        }

    def resolve_default_art_path(self, invocation_name: str) -> str:
        heroes_dir = Path.home() / "AppsFiles" / "Zordeer" / "sgdb" /"heroes"
        for folder in heroes_dir.iterdir():
            if folder.is_dir() and folder.name.lower() == invocation_name.lower():
                for ext in ("*.jpg", "*.jpeg", "*.png", "*webp"):
                    images = list(folder.glob(ext))
                    if images:
                        return str(images[0])
        return ""

    def resolve_default_gui_path(self, invocation_name: str) -> str:
        icons_dir = Path.home() / "AppsFiles" / "Zordeer" / "sgdb" / "icons"
        for folder in icons_dir.iterdir():
            if folder.is_dir() and folder.name.lower() == invocation_name.lower():
                for ext in ("*.jpg", "*.jpeg", "*.png", "*webp"):
                    images = list(folder.glob(ext))
                    if images:
                        return str(images[0])
        return ""

    def save_and_accept(self):
        """Validates fields, saves data to file, and updates paths if the name changes."""
        invocation_data = self.get_form_data()

        # Runner validation
        selected_runner = invocation_data.get("runner", "")
        if tr("UNAVAILABLE") in selected_runner:
            reply = QMessageBox.question(
                self,
                tr("APP_NAME"),
                tr("SELECT_AVAILABLE_RUNNER_CONFIRM"),
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )
            if reply == QMessageBox.StandardButton.No:
                return

        old_safe_name = ""
        if self.invocation_data:
            old_safe_name = self.invocation_data.get('name', '').replace(" ", "_").lower()

        required_fields = ["name"]
        if all(invocation_data.get(field) for field in required_fields):
            prefix_path = Path(invocation_data["prefix_path"])
            if not prefix_path.exists():
                try:
                    prefix_path.mkdir(parents=True, exist_ok=True)
                except Exception:
                    pass

            config_dir = Path.home() / "AppsFiles" / "Zordeer" / "config"
            art_dir = Path.home() / "AppsFiles" / "Zordeer" / "art"
            gui_dir = Path.home() / "AppsFiles" / "Zordeer" / "art" / "gui"
            
            try:
                config_dir.mkdir(parents=True, exist_ok=True)
                art_dir.mkdir(parents=True, exist_ok=True)
                gui_dir.mkdir(parents=True, exist_ok=True)
            except Exception:
                pass

            # Normalize name
            safe_invocation_name = invocation_data["name"].replace(" ", "_").lower()
            invocation_file_path = config_dir / f"invocation-info-{safe_invocation_name}.toml"

            # Check for duplicate invocation name
            if (
                invocation_file_path.exists() and
                (not self.invocation_data or self.invocation_data.get("name", "").lower() != invocation_data["name"].lower())
            ):
                QMessageBox.warning(
                    self,
                    tr("APP_NAME"),
                    tr("INVOCATION_ALREADY_EXISTS")
                )
                return

            # Handle artwork copy / rename
            if invocation_data.get("art_path") and (not self.invocation_data or invocation_data["art_path"] != self.invocation_data.get("art_path")):
                # User selected a new image
                if self.invocation_data:
                    old_safe_name = self.invocation_data.get('name', '').replace(" ", "_").lower()
                    # Remove all old images for this invocation, regardless of extension
                    for old_file in art_dir.glob(f"{old_safe_name}.*"):
                        try:
                            old_file.unlink()
                        except Exception:
                            pass

                # Copy new image to art_dir
                art_path = Path(invocation_data["art_path"])
                art_extension = art_path.suffix.lower()
                new_art_path = art_dir / f"{safe_invocation_name}{art_extension}"
                try:
                    shutil.copyfile(art_path, new_art_path)
                    invocation_data["art_path"] = str(new_art_path)
                except Exception:
                    invocation_data["art_path"] = ""
            elif self.invocation_data and self.invocation_data.get("art_path"):
                # No new image selected, rename old art if invocation name changed
                old_art_path = Path(self.invocation_data['art_path'])
                if old_art_path.exists():
                    old_safe_name = self.invocation_data.get('name', '').replace(" ", "_").lower()
                    if old_safe_name != safe_invocation_name:
                        try:
                            new_art_path = art_dir / f"{safe_invocation_name}{old_art_path.suffix.lower()}"
                            old_art_path.rename(new_art_path)
                            invocation_data["art_path"] = str(new_art_path)
                        except Exception:
                            invocation_data["art_path"] = str(old_art_path)

            # Handle gui gui copy / rename
            if invocation_data.get("gui_path") and (not self.invocation_data or invocation_data["gui_path"] != self.invocation_data.get("gui_path")):
                # User selected a new image
                if self.invocation_data:
                    old_safe_name = self.invocation_data.get('name', '').replace(" ", "_").lower()
                    # Remove all old images for this invocation, regardless of extension
                    for old_file in gui_dir.glob(f"{old_safe_name}.*"):
                        try:
                            old_file.unlink()
                        except Exception:
                            pass

                # Copy new image to gui_dir
                gui_path = Path(invocation_data["gui_path"])
                gui_extension = gui_path.suffix.lower()
                new_gui_path = gui_dir / f"{safe_invocation_name}{gui_extension}"
                try:
                    shutil.copyfile(gui_path, new_gui_path)
                    invocation_data["gui_path"] = str(new_gui_path)
                except Exception:
                    invocation_data["gui_path"] = ""
            elif self.invocation_data and self.invocation_data.get("gui_path"):
                # No new image selected, rename old gui if invocation name changed
                old_gui_path = Path(self.invocation_data['gui_path'])
                if old_gui_path.exists():
                    old_safe_name = self.invocation_data.get('name', '').replace(" ", "_").lower()
                    if old_safe_name != safe_invocation_name:
                        try:
                            new_gui_path = gui_dir / f"{safe_invocation_name}{old_gui_path.suffix.lower()}"
                            old_gui_path.rename(new_gui_path)
                            invocation_data["gui_path"] = str(new_gui_path)
                        except Exception:
                            invocation_data["gui_path"] = str(old_gui_path)

            # Handle prefix folder rename if it's safe
            if self.invocation_data:
                old_prefix_path = Path(self.invocation_data.get('prefix_path', '')).resolve()
                current_prefix_path = Path(invocation_data.get('prefix_path', '')).resolve()
                old_exec_path = Path(self.invocation_data.get('exec_path', '')).resolve() if self.invocation_data.get('exec_path') else None

                # Only attempt rename if the user has not manually changed the prefix
                if old_prefix_path == current_prefix_path:
                    # Only rename if the folder exists and its name matches the old invocation name
                    if old_prefix_path.exists() and old_prefix_path.name.lower() == old_safe_name:
                        used_by_other = False
                        # Check if any other invocation is using the same prefix folder
                        for f in config_dir.glob("invocation-info-*.toml"):
                            old_inv_file = config_dir / f"invocation-info-{old_safe_name}.toml"
                            if f == old_inv_file:
                                continue  # Skip the current invocation file
                            try:
                                with open(f, encoding="utf-8") as tf:
                                    data = toml.load(tf)
                                    other_prefix = Path(data.get('prefix_path', '')).resolve()
                                    other_exec = Path(data.get('exec_path', '')).resolve() if data.get('exec_path') else None

                                    # Block rename if:
                                    # - Another invocation uses the same prefix folder
                                    # - Another invocation has an executable inside this prefix
                                    if (
                                        other_prefix == old_prefix_path or
                                        (other_exec and other_exec.is_relative_to(old_prefix_path))
                                    ):
                                        used_by_other = True
                                        break
                            except Exception:
                                pass  # Ignore any errors reading other invocation files

                        # Rename the prefix folder if no other invocation is using it
                        if not used_by_other:
                            # Skip rename prompt if the invocation name didn't actually change
                            if safe_invocation_name == old_safe_name:
                                invocation_data["prefix_path"] = str(old_prefix_path)
                            else:
                                reply = QMessageBox.question(
                                    self,
                                    tr("APP_NAME"),
                                    tr("RENAME_PREFIX_QUESTION", old=self.invocation_data.get("name", old_safe_name), new=invocation_data.get("name", safe_invocation_name)),
                                    QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                                    QMessageBox.StandardButton.No
                                )

                                if reply == QMessageBox.StandardButton.Yes:
                                    new_prefix_path = old_prefix_path.parent / safe_invocation_name
                                    try:
                                        old_prefix_path.rename(new_prefix_path)
                                        invocation_data["prefix_path"] = str(new_prefix_path)

                                        # Update exec_path if it's inside the old prefix folder
                                        if old_exec_path and old_exec_path.is_relative_to(old_prefix_path):
                                            relative_exec = old_exec_path.relative_to(old_prefix_path)
                                            new_exec_path = new_prefix_path / relative_exec
                                            invocation_data["exec_path"] = str(new_exec_path)

                                    except Exception:
                                        # Keep old path if rename fails
                                        invocation_data["prefix_path"] = str(old_prefix_path)
                                else:
                                    invocation_data["prefix_path"] = str(old_prefix_path)
                        else:
                            # Another invocation is using this prefix, keep current path
                            invocation_data["prefix_path"] = str(old_prefix_path)
                    else:
                        # Folder name doesn't match old invocation name, keep current path
                        invocation_data["prefix_path"] = str(old_prefix_path)
                else:
                    # User manually changed the prefix, do not rename
                    invocation_data["prefix_path"] = str(current_prefix_path)

            # Prevents the text "UNAVAILABLE" from being added to the saved runner's name.
            runner_value = invocation_data.get("runner", "")
            unavailable_text = f" ({tr("UNAVAILABLE")})"
            if unavailable_text in runner_value:
                invocation_data["runner"] = runner_value.replace(unavailable_text, "")

            # Save TOML
            try:
                with open(invocation_file_path, 'w', encoding="utf-8") as tf:
                    toml.dump(invocation_data, tf)
            except Exception as e:
                print(e)
                QMessageBox.critical(
                    self,
                    tr("APP_NAME"),
                    tr("NAME_INVALID", error=str(e))
                )
                return  # The old TOML remains intact.

            # Remove old TOML only if name changed
            if self.invocation_data:
                old_safe_name = self.invocation_data.get('name', '').replace(" ", "_").lower()
                new_safe_name = safe_invocation_name
                if old_safe_name != new_safe_name:
                    old_invocation_file_path = config_dir / f"invocation-info-{old_safe_name}.toml"
                    if old_invocation_file_path.exists():
                        old_invocation_file_path.unlink()

            # Emit signal and close
            self.invocation_saved.emit()
            self.accept()
        else:
            QMessageBox.warning(self, tr("CREATE_INVOCATION"), tr("MANDATORY_FIELD_ERROR"))

    def delete_invocation(self):
        """Removes the invocation and optionally its data/prefix."""
        invocation_name = self.name_input.text().strip()

        # Confirmation dialog with checkbox
        msg = QMessageBox(self)
        msg.setIcon(QMessageBox.Icon.Warning)
        msg.setWindowTitle(tr("REMOVE"))
        msg.setText(tr("DELETE_INVOCATION_CONFIRM_MESSAGE", name=invocation_name))
        msg.setStandardButtons(QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)

        msg.button(QMessageBox.StandardButton.Yes).setText(tr("YES_BUTTON"))
        msg.button(QMessageBox.StandardButton.No).setText(tr("NO_BUTTON"))

        delete_data_cb = QCheckBox(tr("DELETE_PREFIX_CHECKBOX"))
        msg.setCheckBox(delete_data_cb)

        if msg.exec() != QMessageBox.StandardButton.Yes:
            return

        # Path to the TOML file
        config_dir = Path.home() / "AppsFiles" / "Zordeer" / "config"
        safe_name = invocation_name.replace(" ", "_").lower()
        invocation_file = config_dir / f"invocation-info-{safe_name}.toml"

        if not invocation_file.exists():
            QMessageBox.critical(self, tr("APP_NAME"), tr("INVOCATION_INFO_ERROR"))
            return

        # Load data
        with open(invocation_file, encoding='utf-8') as f:
            invocation_data = toml.load(f)

        prefix_path = invocation_data.get('prefix_path')
        prefix_in_use_by_others = []

        # Checks if the prefix is ​​being used by other invocations
        if prefix_path:
            for f in config_dir.glob("invocation-info-*.toml"):
                if f == invocation_file:
                    continue
                try:
                    with open(f, encoding="utf-8") as toml_file:
                        data = toml.load(toml_file)
                        other_prefix = data.get('prefix_path')
                        if other_prefix and Path(other_prefix).resolve() == Path(prefix_path).resolve():
                            prefix_in_use_by_others.append(data.get('name', 'Unknown'))
                except Exception:
                    pass

        # If the user marked for deletion and the prefix is ​​in use
        if delete_data_cb.isChecked() and prefix_in_use_by_others:
            dialog = QDialog(self)
            dialog.setWindowTitle(tr("REMOVE"))
            dialog.resize(400, 300)
            layout = QVBoxLayout(dialog)

            # Main message
            msg_label = QLabel(tr("PREFIX_IN_USE_MESSAGE"))
            msg_label.setWordWrap(True)
            layout.addWidget(msg_label)

            # QTreeWidget to show affected invocations
            tree_widget = QTreeWidget()
            tree_widget.setHeaderLabels([tr("PREFIX_REMOTION_INFORMATION")])
            tree_widget.setColumnCount(1)
            tree_widget.setRootIsDecorated(True)
            tree_widget.setSelectionMode(QTreeWidget.SelectionMode.NoSelection)

            # Prefix that would be removed
            prefix_item = QTreeWidgetItem([prefix_path])
            tree_widget.addTopLevelItem(prefix_item)

            # Affected invocations
            affected_item = QTreeWidgetItem([tr("AFFECTED_INVOCATIONS")])
            prefix_item.addChild(affected_item)

            # Invocations that use this prefix
            for inv in prefix_in_use_by_others:
                inv_item = QTreeWidgetItem([inv])
                affected_item.addChild(inv_item)

            # Expands by default to be visible
            tree_widget.expandAll()

            layout.addWidget(tree_widget)

            # Radiobuttons
            keep_radio = QRadioButton(tr("DO_NOT_DELETE_PREFIX"))
            force_radio = QRadioButton(tr("DELETE_PREFIX_ANYWAY"))
            keep_radio.setChecked(True)
            layout.addWidget(keep_radio)
            layout.addWidget(force_radio)

            # Confirm button
            buttons_layout = QHBoxLayout()
            confirm_button = QPushButton(tr("CONFIRM"))
            buttons_layout.addWidget(confirm_button)
            layout.addLayout(buttons_layout)

            confirm_button.clicked.connect(dialog.accept)

            if dialog.exec() != QDialog.DialogCode.Accepted:
                return

            if keep_radio.isChecked():
                delete_data_cb.setChecked(False)

        # Remove TOML
        invocation_file.unlink()

        # Remove prefix if checkbox is checked
        if delete_data_cb.isChecked():
            if prefix_path:
                prefix_path_obj = Path(prefix_path)
                if prefix_path_obj.exists() and prefix_path_obj.is_dir():
                    try:
                        shutil.rmtree(prefix_path_obj)
                    except Exception as e:
                        QMessageBox.warning(self, tr("APP_NAME"), tr("DELETE_DATA_ERROR", error=str(e)))

        # Remove artwork if it exists
        art = invocation_data.get('art_path')
        if art:
            art_path = Path(art)
            if art_path.exists() and art_path.is_file():
                try:
                    art_path.unlink()
                except Exception:
                    pass

        # Remove gui icon if it exists
        gui = invocation_data.get('gui_path')
        if gui:
            gui_path = Path(gui)
            if gui_path.exists() and gui_path.is_file():
                try:
                    gui_path.unlink()
                except Exception:
                    pass

        # Refresh the list and close
        self.parent().load_invocations()
        self.accept()

    def open_winecfg(self):
        prefix_path = Path(self.prefix_path_input.text().strip())
        if not prefix_path.exists():
            QMessageBox.warning(self, tr("APP_NAME"), tr("INVALID_PREFIX_ERROR"))
            return

        selected_runner = self.runner_input.currentText().strip()
        runner_name = selected_runner

        if runner_name.lower() != "wine":
            # Proton path
            runners_path = Path(self.parent().zordeer_dir) / "runner"
            proton_script = runners_path / runner_name / "proton"
            if not proton_script.exists():
                default_runner = load_settings().get("default_runner", "Wine")
                runner_name = default_runner
                if runner_name.lower() != "wine":
                    proton_script = runners_path / runner_name / "proton"
                    if not proton_script.exists():
                        runner_name = "Wine"

        env = os.environ.copy()

        if runner_name.lower() == "wine":
            wine_path = shutil.which("wine")
            if not wine_path:
                QMessageBox.critical(self, tr("APP_NAME"), tr("WINE_NOT_FOUND"))
                return
            cmd = [wine_path, "winecfg"]
            env["WINEPREFIX"] = str(prefix_path)
        else:
            cmd = [str(proton_script), "run", "winecfg"]
            env["STEAM_COMPAT_DATA_PATH"] = str(prefix_path)
            env["STEAM_COMPAT_CLIENT_INSTALL_PATH"] = str(Path.home() / "AppsFiles" / "Zordeer" / ".steam" / "steam")
            env["STEAM_EXTRA_COMPAT_TOOLS_PATHS"] = str(proton_script.parent)

        subprocess.Popen(cmd, env=env)

class UMUGameSearchDialog(QDialog):
    def __init__(self, parent=None, runner_name="", current_env_vars=""):
        super().__init__(parent)
        self.runner_name = runner_name
        self.current_env_vars = current_env_vars
        self.setWindowTitle(tr("UMU_DATABASE"))
        self.resize(500, 300)
        
        self.main_layout = QVBoxLayout(self)
        
        # Search bar
        self.search_input = QLineEdit()
        self.search_input.setPlaceholderText(tr("SEARCH"))
        self.search_input.textChanged.connect(self.search_games)
        self.main_layout.addWidget(self.search_input)
        
        # Game list
        self.tree_widget = QTreeWidget()
        self.tree_widget.setHeaderLabels([tr("GAME_NAME"), tr("STORE")])
        self.tree_widget.setColumnCount(2)
        
        # Column size
        self.tree_widget.setColumnWidth(0, 350)
        self.tree_widget.setColumnWidth(1, 120)

        self.main_layout.addWidget(self.tree_widget)
        
        # Add button
        self.buttons_layout = QHBoxLayout()
        self.add_button = QPushButton(tr("ADD_VARIABLES_BUTTON"))
        self.add_button.clicked.connect(self.add_selected)
        self.buttons_layout.addStretch()
        self.buttons_layout.addWidget(self.add_button)
        
        self.main_layout.addLayout(self.buttons_layout)

        self.should_show = self.pre_validate()

        if not self.should_show:
            self.deleteLater()

    # Perform all checks before displaying the window.
    def pre_validate(self):
        # If runner is empty, use the default runner.
        if not self.runner_name:
            settings = load_settings()
            self.runner_name = settings["other"].get("default_runner", "").strip()
        
        # Verification for runner "indefinite"
        if not self.runner_name or self.runner_name.lower() == "indefinite":
            QMessageBox.warning(self.parent(), tr("APP_NAME"), tr("DEFAULT_RUNNER_INDEFINITE"))
            return False
        
        # Verification for runner "Wine"
        if self.runner_name.lower() == "wine":
            QMessageBox.information(self.parent(), tr("APP_NAME"), tr("UMU_DATABASE_WINE_NOT_SUPPORTED"))
            return False
        
        csv_path = Path.home() / "AppsFiles" / "Zordeer" / "runner" / self.runner_name / "protonfixes" / "umu-database.csv"
        
        if not csv_path.exists():
            QMessageBox.warning(self.parent(), tr("APP_NAME"), tr("UMU_DATABASE_NOT_FOUND", path=str(csv_path)))
            return False
        
        # Try loading the data.
        try:
            self.games_data = []
            with open(csv_path, 'r', encoding='utf-8') as f:
                reader = csv.reader(f)
                next(reader, None)  # Ignore header "TITLE,STORE,CODENAME,UMU_ID"
                
                for row in reader:
                    if len(row) >= 4:  # It needs to have a name, store, codename, and UMU_ID.
                        self.games_data.append({
                            'name': row[0],
                            'store': row[1],
                            'umu_id': row[3]  # Fourth column = UMU_ID
                        })
            # Load the list
            self.search_games()
            return True
        except Exception as e:
            QMessageBox.critical(self.parent(), tr("APP_NAME"), tr("UMU_DATABASE_LOAD_ERROR", error=str(e)))
            return False

    # Override the exec command to prevent the window from opening if the validations are not passed.
    def exec(self):
        if not self.should_show:
            return QDialog.DialogCode.Rejected
        # Call search_games to ensure the list is populated
        if hasattr(self, 'games_data'):
            self.search_games()
        return super().exec()

    # Override the show to prevent the window from opening if validations are not passed.
    def show(self):
        if not self.should_show:
            return
        # Call search_games to ensure the list is populated
        if hasattr(self, 'games_data'):
            self.search_games()
        super().show()

    def keyPressEvent(self, event):
        if event.key() in (Qt.Key.Key_Return, Qt.Key.Key_Enter):
            self.add_selected()
            return
        super().keyPressEvent(event)

    # It filters games based on the search text and selects them automatically.
    def search_games(self):
        if not hasattr(self, 'games_data') or not self.games_data:
            return
            
        search_text = self.search_input.text().lower().strip()
        self.tree_widget.clear()
        
        filtered_games = []
        for game in self.games_data:
            if not search_text or search_text in game['name'].lower():
                filtered_games.append(game)
        
        # Add filtered games
        for game in filtered_games:
            item = QTreeWidgetItem([game['name'], game['store']])
            item.setData(0, Qt.ItemDataRole.UserRole, game['umu_id'])
            item.setData(1, Qt.ItemDataRole.UserRole, game['store'])
            self.tree_widget.addTopLevelItem(item)
        
        # Selects automatically
        if filtered_games:
            first_item = self.tree_widget.topLevelItem(0)
            if first_item:
                self.tree_widget.setCurrentItem(first_item)
                first_item.setSelected(True)

    # Adds the selected game to the environment variables.
    def add_selected(self):
        selected_items = self.tree_widget.selectedItems()
        if not selected_items:
            first_item = self.tree_widget.topLevelItem(0)
            if first_item:
                selected_items = [first_item]
            else:
                QMessageBox.warning(self, tr("APP_NAME"), tr("NO_GAME_SELECTED_ERROR"))
                return
        
        item = selected_items[0]
        umu_id = item.data(0, Qt.ItemDataRole.UserRole)
        store = item.data(1, Qt.ItemDataRole.UserRole)
        
        if umu_id and store:
            new_vars = f"GAMEID={umu_id} STORE={store}"
            
            if self.current_env_vars.strip():
                env_vars_text = f"{self.current_env_vars} {new_vars}"
            else:
                env_vars_text = new_vars
            
            self.selected_env_vars = env_vars_text
            self.accept()

class MultipleCreateInvocationsDialog(QDialog):
    invocations_saved = pyqtSignal()

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle(tr("MULTIPLE_INVOCATION_CREATOR"))
        self.resize(700, 500)

        self.main_layout = QVBoxLayout(self)

        # Runner and Language layout (grid)
        top_grid = QGridLayout()

        # Runner
        runner_label = QLabel(tr("RUNNER_VERSION"))
        self.runner_combo = QComboBox()
        self.populate_runners()
        top_grid.addWidget(runner_label, 0, 0)
        top_grid.addWidget(self.runner_combo, 0, 1)

        # Language and combobox
        language_label = QLabel(tr("INVOCATION_LANGUAGE"))
        self.language_input = QComboBox()
        self.language_input.addItems([
            tr("PLACEHOLDER_FOR_LANGUAGE"),
            'English (en_US.UTF-8)',
            'Português Brasil (pt_BR.UTF-8)',
            'Português Portugal (pt_PT.UTF-8)',
            'Español España (es_ES.UTF-8)',
            'Español México (es_MX.UTF-8)',
            'Français (fr_FR.UTF-8)',
            'Deutsch (de_DE.UTF-8)',
            'Italiano (it_IT.UTF-8)',
            'Русский (ru_RU.UTF-8)',
            'Українська (uk_UA.UTF-8)',
            'Polski (pl_PL.UTF-8)',
            'Česky (cs_CZ.UTF-8)',
            'Slovenčina (sk_SK.UTF-8)',
            'Magyar (hu_HU.UTF-8)',
            'Română (ro_RO.UTF-8)',
            'Nederlands (nl_NL.UTF-8)',
            'Svenska (sv_SE.UTF-8)',
            'Norsk Bokmål (nb_NO.UTF-8)',
            'Dansk (da_DK.UTF-8)',
            'Suomi (fi_FI.UTF-8)',
            'Ελληνικά (el_GR.UTF-8)',
            'Български (bg_BG.UTF-8)',
            '日本語 (ja_JP.UTF-8)',
            '한국어 (ko_KR.UTF-8)',
            '简体中文 (zh_CN.UTF-8)',
            '繁體中文 (zh_TW.UTF-8)',
            'العربية (ar_SA.UTF-8)',
            'فارسی (fa_IR.UTF-8)',
            'Türkçe (tr_TR.UTF-8)',
            'हिन्दी (hi_IN.UTF-8)',
            'ไทย (th_TH.UTF-8)',
            'עברית (he_IL.UTF-8)',
        ])
        top_grid.addWidget(language_label, 1, 0)
        top_grid.addWidget(self.language_input, 1, 1)

        self.main_layout.addLayout(top_grid)

        # Checkbox animarium_prefix
        self.animarium_prefix_cb = QCheckBox(tr("USE_ANIMARIUM_PREFIX_FOR_ALL"))
        self.main_layout.addWidget(self.animarium_prefix_cb)

        self.auto_prefix_cb = QCheckBox(tr("USE_AUTO_PREFIX_FOR_ALL"))
        self.main_layout.addWidget(self.auto_prefix_cb)

        self.animarium_prefix_cb.stateChanged.connect(
            lambda state: self.auto_prefix_cb.setDisabled(state == Qt.CheckState.Checked.value)
        )
        self.auto_prefix_cb.stateChanged.connect(
            lambda state: self.animarium_prefix_cb.setDisabled(state == Qt.CheckState.Checked.value)
        )

        # TreeWidget for multiple invocations
        self.file_list = QTreeWidget()
        self.file_list.setColumnCount(1)
        self.file_list.setHeaderHidden(True)
        self.file_list.setExpandsOnDoubleClick(True)
        self.main_layout.addWidget(self.file_list)

        # Add/Remove File Buttons
        btn_layout = QHBoxLayout()
        self.add_files_button = QPushButton(tr("ADD_FILES"))
        self.add_files_button.clicked.connect(self.add_files)
        self.remove_item_button = QPushButton(tr("REMOVE_SELECTED"))
        self.remove_item_button.clicked.connect(self.remove_selected_item)
        btn_layout.addWidget(self.add_files_button)
        btn_layout.addWidget(self.remove_item_button)
        self.main_layout.addLayout(btn_layout)

        # Save button
        save_layout = QHBoxLayout()
        self.save_button = QPushButton(tr("SAVE_BUTTON"))
        self.save_button.clicked.connect(self.save_multiple)
        save_layout.addStretch()
        save_layout.addWidget(self.save_button)
        self.main_layout.addLayout(save_layout)

        self.paths = []

    # Utility functions

    def keyPressEvent(self, event):
        if event.key() in (Qt.Key.Key_Return, Qt.Key.Key_Enter):
            # Prevents Enter from triggering something that is not selected
            return
        super().keyPressEvent(event)

    def populate_runners(self):
        runners_path = Path.home() / "AppsFiles" / "Zordeer" / "runner"
        runners_path.mkdir(parents=True, exist_ok=True)
        runners = [d.name for d in runners_path.iterdir() if d.is_dir()]

        self.runner_combo.clear()

        items = [tr("PLACEHOLDER_FOR_RUNNER")]

        if shutil.which("wine"):
            items.append("Wine")

        items += sorted(runners, reverse=True)

        self.runner_combo.addItems(items)

    def add_files(self):
        files, _ = QFileDialog.getOpenFileNames(self, tr("SELECT_EXECUTABLE"), "", tr("EXECUTABLE_FILE_FILTER"))
        for f in files:
            self.add_file_item(f)

    def remove_selected_item(self):
        selected = self.file_list.currentItem()
        if selected and hasattr(selected, "path"):
            index = self.file_list.indexOfTopLevelItem(selected)
            self.file_list.takeTopLevelItem(index)
            self.paths.remove(selected.path)

    def add_file_item(self, path):
        if path in self.paths:
            return
        self.paths.append(path)

        # Internal widget for options
        item_widget = QWidget()
        layout = QVBoxLayout(item_widget)
        layout.setContentsMargins(2, 2, 2, 2)
        layout.setSpacing(4)

        # Invocation name
        name_layout = QHBoxLayout()
        name_label = QLabel(tr("INVOCATION_NAME"))
        name_input = QLineEdit(Path(path).stem)
        name_layout.addWidget(name_label)
        name_layout.addWidget(name_input)
        layout.addLayout(name_layout)

        # Prefix
        prefix_layout = QHBoxLayout()
        prefix_label = QLabel(tr("PREFIX_PATH"))
        prefix_input = QLineEdit(
            str(Path.home() / "AppsFiles" / "Zordeer" / "invocation" / Path(path).stem.replace(" ", "_").lower())
        )
        prefix_button = QPushButton(tr("BROWSE_BUTTON"))
        prefix_layout.addWidget(prefix_label)
        prefix_layout.addWidget(prefix_input)
        prefix_layout.addWidget(prefix_button)
        layout.addLayout(prefix_layout)

        name_input.textChanged.connect(
            lambda text, inp=prefix_input: inp.setText(
                str(Path.home() / "AppsFiles" / "Zordeer" / "invocation" / text.replace(" ", "_").lower())
            )
        )
        prefix_button.clicked.connect(lambda _, inp=prefix_input: self.select_prefix_folder(inp))

        # Checkboxes
        ms_lang_cb = QCheckBox(tr("USE_MS_LANGUAGE_CODE"))
        ms_lang_cb.setChecked(False)
        layout.addWidget(ms_lang_cb)

        force_opengl_cb = QCheckBox(tr("FORCE_OPENGL"))
        force_opengl_cb.setChecked(False)
        layout.addWidget(force_opengl_cb)

        gamemode_cb = QCheckBox(tr("GAMEMODE"))
        gamemode_cb.setChecked(True)
        layout.addWidget(gamemode_cb)

        umu_cb = QCheckBox(tr("USE_UMU_LAUNCHER"))
        umu_cb.setChecked(False)
        layout.addWidget(umu_cb)

        # FPS HUD
        fps_layout = QHBoxLayout()
        show_fps_cb = QCheckBox(tr("SHOW_FPS_OPTION"))
        fps_hud_combo = QComboBox()
        fps_hud_options = [
            ("FPS_GALLIUM_HUD", tr("FPS_GALLIUM_HUD")),
            ("FPS_DXVK_HUD", tr("FPS_DXVK_HUD")),
            ("FPS_MANGOHUD", tr("FPS_MANGOHUD"))
        ]
        for id, text in fps_hud_options:
            fps_hud_combo.addItem(text, id)
        fps_hud_combo.setEnabled(False)
        show_fps_cb.stateChanged.connect(lambda s, combo=fps_hud_combo: combo.setEnabled(s))
        fps_layout.addWidget(show_fps_cb)
        fps_layout.addWidget(fps_hud_combo)
        layout.addLayout(fps_layout)

        # QTreeWidgetItem with child containing widget
        parent_item = QTreeWidgetItem(self.file_list)
        parent_item.setText(0, Path(path).name)
        child_item = QTreeWidgetItem(parent_item)
        child_item.setFlags(child_item.flags() & ~Qt.ItemFlag.ItemIsSelectable)
        self.file_list.setItemWidget(child_item, 0, item_widget)
        parent_item.setExpanded(True)

        # Save references
        parent_item.path = path
        parent_item.name_input = name_input
        parent_item.prefix_input = prefix_input
        parent_item.ms_lang_cb = ms_lang_cb
        parent_item.force_opengl_cb = force_opengl_cb
        parent_item.gamemode_cb = gamemode_cb
        parent_item.umu_cb = umu_cb
        parent_item.show_fps_cb = show_fps_cb
        parent_item.fps_hud_combo = fps_hud_combo

    def select_prefix_folder(self, line_edit: QLineEdit):
        dir_path = QFileDialog.getExistingDirectory(
            self,
            tr("SELECT_PREFIX_TITLE"),
            str(Path.home() / "AppsFiles" / "Zordeer" / "invocation")
        )
        if dir_path:
            line_edit.setText(dir_path)

    def save_multiple(self):
        # Runner and item validation
        runner = self.runner_combo.currentText()
        if self.file_list.topLevelItemCount() == 0:
            QMessageBox.warning(self, tr("CREATE_INVOCATION"), tr("MANDATORY_FIELDS_ERROR"))
            return

        # If the user does not select a runner, it will be saved as empty.
        if runner == tr("PLACEHOLDER_FOR_RUNNER"):
            runner = ""

        config_dir = Path.home() / "AppsFiles" / "Zordeer" / "config"
        art_dir = Path.home() / "AppsFiles" / "Zordeer" / "art"
        gui_dir = Path.home() / "AppsFiles" / "Zordeer" / "art" / "gui"
        config_dir.mkdir(parents=True, exist_ok=True)
        art_dir.mkdir(parents=True, exist_ok=True)
        gui_dir.mkdir(parents=True, exist_ok=True)

        # Name and duplicate validation
        existing_names = set()
        for i in range(self.file_list.topLevelItemCount()):
            item = self.file_list.topLevelItem(i)
            name = item.name_input.text().strip()

            # Empty name
            if not name:
                QMessageBox.warning(self, tr("APP_NAME"), tr("MANDATORY_FIELDS_ERROR"))
                return

            safe_name = name.replace(" ", "_").lower()

            # Duplicate in own list
            if safe_name in existing_names:
                QMessageBox.warning(
                    self,
                    tr("APP_NAME"),
                    tr("DUPLICATE_NAME_IN_LIST", name=name)
                )
                return
            existing_names.add(safe_name)

            # Duplicate in filesystem
            test_path = config_dir / f"invocation-info-{safe_name}.toml"
            if test_path.exists():
                QMessageBox.warning(
                    self,
                    tr("APP_NAME"),
                    tr("INVOCATION_IN_MULTIPLE_CREATE_ALREADY_EXISTS", name=name)
                )
                return

            # Test if you can write the file
            try:
                with open(test_path, 'w', encoding="utf-8") as f:
                    toml.dump({}, f)
                test_path.unlink()
            except Exception as e:
                QMessageBox.critical(
                    self,
                    tr("APP_NAME"),
                    tr("NAME_INVALID_IN_MULTIPLE", name=name, error=str(e))
                )
                return

        selected_lang = self.language_input.currentText()
        if selected_lang == tr("PLACEHOLDER_FOR_LANGUAGE"):
            selected_lang = ""

        for i in range(self.file_list.topLevelItemCount()):
            item = self.file_list.topLevelItem(i)
            name = item.name_input.text().strip()
            safe_name = name.replace(" ", "_").lower()
            file_path = config_dir / f"invocation-info-{safe_name}.toml"

            # Determine prefix
            if self.auto_prefix_cb.isChecked():
                prefix_path = Path(item.path)
                while prefix_path != prefix_path.parent:
                    if prefix_path.name.lower() == "drive_c":
                        prefix_path = prefix_path.parent
                        break
                    prefix_path = prefix_path.parent
                else:
                    # If you can't find 'drive_c', use the manual prefix
                    prefix_path = Path(item.prefix_input.text())
                prefix_path.mkdir(parents=True, exist_ok=True)
            elif self.animarium_prefix_cb.isChecked():
                prefix_path = Path.home() / "AppsFiles" / "Zordeer" / "invocation" / "animarium_prefix"
                prefix_path.mkdir(parents=True, exist_ok=True)
            else:
                prefix_path = Path(item.prefix_input.text())
                prefix_path.mkdir(parents=True, exist_ok=True)

            # Determining the path of art
            art_path = getattr(item, "art_path", "")
            if not art_path:
                heroes_dir = Path.home() / "AppsFiles" / "Zordeer" / "sgdb" / "heroes"
                for folder in heroes_dir.iterdir():
                    if folder.is_dir() and folder.name.lower() == name.lower():
                        for ext in ("*.jpg", "*.jpeg", "*.png", "*.webp"):
                            images = list(folder.glob(ext))
                            if images:
                                art_path = str(images[0])
                                break
                    if art_path:
                        break

            # Copy art to art_dir if it exists
            if art_path:
                art_src = Path(art_path)
                if art_src.exists():
                    ext = art_src.suffix.lower()
                    dest_path = art_dir / f"{safe_name}{ext}"
                    try:
                        if not dest_path.exists():
                            shutil.copyfile(art_src, dest_path)
                        art_path = str(dest_path)
                    except Exception:
                        art_path = ""

            # Determining the path of gui icon
            gui_path = getattr(item, "gui_path", "")
            if not gui_path:
                icons_dir = Path.home() / "AppsFiles" / "Zordeer" / "sgdb" / "icons"
                for folder in icons_dir.iterdir():
                    if folder.is_dir() and folder.name.lower() == name.lower():
                        for ext in ("*.jpg", "*.jpeg", "*.png", "*.webp"):
                            images = list(folder.glob(ext))
                            if images:
                                gui_path = str(images[0])
                                break
                    if gui_path:
                        break

            # Copy gui to gui_dir if it exists
            if gui_path:
                gui_src = Path(gui_path)
                if gui_src.exists():
                    ext = gui_src.suffix.lower()
                    dest_path = gui_dir / f"{safe_name}{ext}"
                    try:
                        if not dest_path.exists():
                            shutil.copyfile(gui_src, dest_path)
                        gui_path = str(dest_path)
                    except Exception:
                        gui_path = ""

            # Save TOML
            try:
                with open(file_path, 'w', encoding="utf-8") as f:
                    toml.dump({
                        "name": name,
                        "runner": runner,
                        "exec_path": item.path,
                        "prefix_path": str(prefix_path),
                        "art_path": art_path,
                        "gui_path": gui_path,
                        "language": selected_lang,
                        "use_ms_language_code": item.ms_lang_cb.isChecked(),
                        "force_opengl": item.force_opengl_cb.isChecked(),
                        "use_gamemode": item.gamemode_cb.isChecked(),
                        "use_umu": item.umu_cb.isChecked(),
                        "show_fps": item.show_fps_cb.isChecked(),
                        "fps_hud_type": item.fps_hud_combo.currentData() or "",
                        "env_vars": "",
                        "invocation_args": ""
                    }, f)
            except Exception as e:
                QMessageBox.critical(self, tr("APP_NAME"), tr("FAILED_UPDATE_TOML", error=str(e)))
                return

        self.invocations_saved.emit()
        self.accept()

    def save_invocation_data(self, data):
        config_dir = Path.home() / "AppsFiles" / "Zordeer" / "config"
        config_dir.mkdir(parents=True, exist_ok=True)
        safe_name = data["name"].replace(" ", "_").lower()
        file_path = config_dir / f"invocation-info-{safe_name}.toml"
        if file_path.exists():
            return
        with open(file_path, 'w', encoding="utf-8") as f:
            toml.dump(data, f)

class MultipleRemoveInvocationDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle(tr("MULTIPLE_INVOCATION_REMOVER"))
        self.resize(340, 400)
        self.parent_ref = parent

        self.main_layout = QVBoxLayout(self)

        # Search bar
        self.search_input = QLineEdit()
        self.search_input.setPlaceholderText(tr("SEARCH"))
        self.search_input.textChanged.connect(self.update_invocation_list)
        self.main_layout.addWidget(self.search_input)

        # Scroll area with invocations
        self.scroll_area = QScrollArea()
        self.scroll_area.setWidgetResizable(True)
        self.scroll_content = QWidget()
        self.scroll_layout = QVBoxLayout(self.scroll_content)
        self.scroll_content.setLayout(self.scroll_layout)
        self.scroll_layout.setContentsMargins(6, 6, 6, 6)
        self.scroll_layout.setSpacing(4)
        self.scroll_area.setWidget(self.scroll_content)
        self.main_layout.addWidget(self.scroll_area)

        # Checkbox to delete prefix
        self.delete_prefix_checkbox = QCheckBox(tr("DELETE_PREFIX_CHECKBOX"))
        self.delete_prefix_checkbox.setChecked(False)
        self.main_layout.addWidget(self.delete_prefix_checkbox)

        # Select All / Deselect All buttons
        btn_layout = QHBoxLayout()
        self.select_all_btn = QPushButton(tr("SELECT_ALL_IN_MULTIPLE_EDIT"))
        self.deselect_all_btn = QPushButton(tr("DESELECT_ALL_IN_MULTIPLE_EDIT"))
        self.select_all_btn.clicked.connect(self.select_all_invocations)
        self.deselect_all_btn.clicked.connect(self.deselect_all_invocations)
        btn_layout.addWidget(self.select_all_btn)
        btn_layout.addWidget(self.deselect_all_btn)
        self.main_layout.addLayout(btn_layout)

        # Remove button
        self.remove_button = QPushButton(tr("REMOVE"))
        self.remove_button.clicked.connect(self.remove_selected_invocations)
        self.main_layout.addWidget(self.remove_button)

        # Dictionary invocation_name -> checkbox
        self.invocation_checkboxes = {}
        self.load_invocations()

    def select_all_invocations(self):
        for i in range(self.scroll_layout.count()):
            widget = self.scroll_layout.itemAt(i).widget()
            if isinstance(widget, QCheckBox) and not widget.isHidden():
                widget.setChecked(True)

    def deselect_all_invocations(self):
        for i in range(self.scroll_layout.count()):
            widget = self.scroll_layout.itemAt(i).widget()
            if isinstance(widget, QCheckBox) and not widget.isHidden():
                widget.setChecked(False)

    def keyPressEvent(self, event):
        if event.key() in (Qt.Key.Key_Return, Qt.Key.Key_Enter):
            # Prevents Enter from triggering something that is not selected
            return
        super().keyPressEvent(event)

    def load_invocations(self):
        """Loads all existing invocations in alphabetical order."""
        config_dir = Path.home() / "AppsFiles" / "Zordeer" / "config"
        self.invocation_checkboxes.clear()

        # Clean layout
        while self.scroll_layout.count():
            item = self.scroll_layout.takeAt(0)
            widget = item.widget()
            if widget:
                widget.deleteLater()

        # Sort files by name (alphabetical)
        invocation_files = sorted(config_dir.glob("invocation-info-*.toml"), key=lambda p: p.stem.lower())

        for invocation_file in invocation_files:
            try:
                with open(invocation_file, encoding="utf-8") as f:
                    invocation_data = toml.load(f)
                name = invocation_data.get("name", invocation_file.stem)
                checkbox = QCheckBox(name)
                checkbox.invocation_file = invocation_file
                checkbox.prefix_path = invocation_data.get("prefix_path")
                checkbox.art_path = invocation_data.get("art_path")
                checkbox.gui_path = invocation_data.get("gui_path")

                self.scroll_layout.addWidget(checkbox)
                self.invocation_checkboxes[name] = checkbox
            except Exception:
                continue

        self.scroll_layout.addStretch()

    def update_invocation_list(self, text):
        """Filters invocations by the text entered in the search."""
        text = text.lower()
        for name, checkbox in self.invocation_checkboxes.items():
            checkbox.setVisible(text in name.lower())

    def remove_selected_invocations(self):
        to_remove = [cb for cb in self.invocation_checkboxes.values() if cb.isChecked()]
        if not to_remove:
            QMessageBox.warning(self, tr("APP_NAME"), tr("NO_INVOCATION_SELECTED_MULTIPLE"))
            return

        msg = QMessageBox(self)
        msg.setIcon(QMessageBox.Icon.Warning)
        msg.setWindowTitle(tr("MULTIPLE_INVOCATION_REMOVER"))
        msg.setText(tr("DELETE_INVOCATIONS_CONFIRM_MESSAGE"))
        msg.setStandardButtons(QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
        msg.button(QMessageBox.StandardButton.Yes).setText(tr("YES_BUTTON"))
        msg.button(QMessageBox.StandardButton.No).setText(tr("NO_BUTTON"))

        if msg.exec() != QMessageBox.StandardButton.Yes:
            return

        config_dir = Path.home() / "AppsFiles" / "Zordeer" / "config"
        art_dir = Path.home() / "AppsFiles" / "Zordeer" / "art"
        gui_dir = Path.home() / "AppsFiles" / "Zordeer" / "art" / "gui"

        # Checking prefixes in use
        prefix_usages = {}
        if self.delete_prefix_checkbox.isChecked():
            for cb in to_remove:
                if not cb.prefix_path:
                    continue
                prefix_path_obj = Path(cb.prefix_path)
                if not prefix_path_obj.exists() or not prefix_path_obj.is_dir():
                    continue

                selected_using = []
                affected_using = []
                for f in config_dir.glob("invocation-info-*.toml"):
                    try:
                        with open(f, encoding="utf-8") as toml_file:
                            data = toml.load(toml_file)
                            other_prefix = data.get('prefix_path')
                            if other_prefix and Path(other_prefix).resolve() == prefix_path_obj.resolve():
                                name = data.get("name", f.stem)
                                if name in [c.text() for c in to_remove]:
                                    selected_using.append(name)
                                else:
                                    affected_using.append(name)
                    except Exception:
                        pass

                if affected_using:
                    prefix_usages[str(prefix_path_obj)] = {
                        "selected": selected_using,
                        "affected": affected_using,
                    }

        force_delete = False
        keep_in_use = False
        if prefix_usages:
            dialog = QDialog(self)
            dialog.setWindowTitle(tr("MULTIPLE_INVOCATION_REMOVER"))
            layout = QVBoxLayout(dialog)

            label = QLabel(tr("PREFIXES_IN_USE_MESSAGE"))
            label.setWordWrap(True)
            layout.addWidget(label)

            tree = QTreeWidget()
            tree.setHeaderLabels([tr("PREFIXES_REMOTION_INFORMATION")])
            tree.setSelectionMode(QAbstractItemView.SelectionMode.NoSelection)
            for prefix, info in prefix_usages.items():
                root = QTreeWidgetItem([prefix])

                selected_item = QTreeWidgetItem([tr("SELECTED_INVOCATIONS")])
                for name in info["selected"]:
                    QTreeWidgetItem(selected_item, [name])
                root.addChild(selected_item)

                affected_item = QTreeWidgetItem([tr("AFFECTED_INVOCATIONS")])
                for name in info["affected"]:
                    QTreeWidgetItem(affected_item, [name])
                root.addChild(affected_item)

                tree.addTopLevelItem(root)

            layout.addWidget(tree)

            rb_keep = QRadioButton(tr("DO_NOT_DELETE_PREFIXES"))
            rb_delete = QRadioButton(tr("DELETE_PREFIXES_ANYWAY"))
            rb_keep.setChecked(True)
            layout.addWidget(rb_keep)
            layout.addWidget(rb_delete)

            confirm_btn = QPushButton(tr("CONFIRM"))
            confirm_btn.clicked.connect(dialog.accept)
            layout.addWidget(confirm_btn)

            if dialog.exec() == QDialog.DialogCode.Accepted:
                force_delete = rb_delete.isChecked()
                keep_in_use = rb_keep.isChecked()
            else:
                return  # User closed the window, cancel everything

        # Effective removal
        for cb in to_remove:
            # Remove TOML
            try:
                if cb.invocation_file.exists():
                    cb.invocation_file.unlink()
            except Exception:
                pass

            # Remove artwork
            if cb.art_path:
                art_path = Path(cb.art_path)
                if art_path.exists() and art_path.is_file():
                    try:
                        art_path.unlink()
                    except Exception:
                        pass

            # Remove gui icon
            if cb.gui_path:
                gui_path = Path(cb.gui_path)
                if gui_path.exists() and gui_path.is_file():
                    try:
                        gui_path.unlink()
                    except Exception:
                        pass

            # Remove prefix if checkbox is checked
            if self.delete_prefix_checkbox.isChecked() and cb.prefix_path:
                prefix_path_obj = Path(cb.prefix_path)
                if prefix_path_obj.exists() and prefix_path_obj.is_dir():
                    try:
                        if str(prefix_path_obj) in prefix_usages:
                            if force_delete:
                                shutil.rmtree(prefix_path_obj)
                            elif keep_in_use:
                                continue  # Keeps
                        else:
                            # Unique prefix, can be deleted
                            shutil.rmtree(prefix_path_obj)
                    except Exception:
                        pass

        # Reload the list
        self.load_invocations()
        if self.parent_ref:
            self.parent_ref.load_invocations()
        
        self.accept()

class MultipleEditInvocationDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle(tr("MULTIPLE_INVOCATION_EDITOR"))
        self.resize(580, 480)
        self.parent_ref = parent

        # Main layout
        splitter = QSplitter(Qt.Orientation.Horizontal, self)
        splitter.setChildrenCollapsible(False)

        # Left: selection of invocations
        left_widget = QWidget()
        left_layout = QVBoxLayout(left_widget)

        self.search_input = QLineEdit()
        self.search_input.setPlaceholderText(tr("SEARCH"))
        self.search_input.textChanged.connect(self.update_invocation_list)
        left_layout.addWidget(self.search_input)

        # Runner filter
        self.runner_filter = QComboBox()
        self.runner_filter.addItem(tr("ALL_INVOCATIONS"))
        self.runner_filter.currentIndexChanged.connect(self.update_invocation_list)
        left_layout.addWidget(self.runner_filter)

        self.scroll_area = QScrollArea()
        self.scroll_area.setWidgetResizable(True)
        self.scroll_content = QWidget()
        self.scroll_layout = QVBoxLayout(self.scroll_content)
        self.scroll_layout.setContentsMargins(6, 6, 6, 6)
        self.scroll_layout.setSpacing(4)
        self.scroll_content.setLayout(self.scroll_layout)
        self.scroll_area.setWidget(self.scroll_content)
        left_layout.addWidget(self.scroll_area)

        # Select all / Deselect all
        btn_layout = QHBoxLayout()
        self.select_all_btn = QPushButton(tr("SELECT_ALL_IN_MULTIPLE_EDIT"))
        self.deselect_all_btn = QPushButton(tr("DESELECT_ALL_IN_MULTIPLE_EDIT"))
        self.select_all_btn.clicked.connect(self.select_all_invocations)
        self.deselect_all_btn.clicked.connect(self.deselect_all_invocations)
        btn_layout.addWidget(self.select_all_btn)
        btn_layout.addWidget(self.deselect_all_btn)
        left_layout.addLayout(btn_layout)

        # Information viewer
        self.view_invocations_btn = QPushButton(tr("SEE_DATA"))
        self.view_invocations_btn.clicked.connect(self.open_invocation_info_viewer)
        left_layout.addWidget(self.view_invocations_btn)

        # Right: Mass editing
        right_widget = QWidget()
        right_layout = QGridLayout(right_widget)
        splitter.addWidget(left_widget)
        splitter.addWidget(right_widget)

        splitter.setSizes([100, 380])

        main_layout = QVBoxLayout(self)
        main_layout.addWidget(splitter)

        row = 0

        # Runner
        self.runner_label = QLabel(tr("RUNNER_VERSION"))
        self.runner_combo = QComboBox()
        self.populate_runners()
        self.runner_combo.insertItem(0, tr("DO_NOT_CHANGE"))
        self.runner_combo.setCurrentIndex(0)
        right_layout.addWidget(self.runner_label, row, 0)
        right_layout.addWidget(self.runner_combo, row, 1, 1, 2)
        row += 1

        # Executable path
        self.exec_label = QLabel(tr("EXECUTABLE_PATH"))
        self.exec_input = QLineEdit(tr("DO_NOT_CHANGE"))
        self.exec_button = QPushButton(tr("BROWSE_BUTTON"))
        self.exec_button.clicked.connect(self.select_executable)
        right_layout.addWidget(self.exec_label, row, 0)
        right_layout.addWidget(self.exec_input, row, 1)
        right_layout.addWidget(self.exec_button, row, 2)
        row += 1

        # Prefix path
        self.prefix_label = QLabel(tr("PREFIX_PATH"))
        self.prefix_input = QLineEdit(tr("DO_NOT_CHANGE"))
        self.prefix_input.setPlaceholderText(tr("ANIMARIUM_PREFIX_PLACEHOLDER"))
        self.prefix_button = QPushButton(tr("BROWSE_BUTTON"))
        self.prefix_button.clicked.connect(self.select_prefix)
        right_layout.addWidget(self.prefix_label, row, 0)
        right_layout.addWidget(self.prefix_input, row, 1)
        right_layout.addWidget(self.prefix_button, row, 2)
        row += 1

        # Art path
        self.art_label = QLabel(tr("INVOCATION_ART_PATH"))
        self.art_input = QLineEdit(tr("DO_NOT_CHANGE"))
        self.art_button = QPushButton(tr("BROWSE_BUTTON"))
        self.art_button.clicked.connect(self.select_invocation_art)
        right_layout.addWidget(self.art_label, row, 0)
        right_layout.addWidget(self.art_input, row, 1)
        right_layout.addWidget(self.art_button, row, 2)
        row += 1

        # Gui path
        self.gui_label = QLabel(tr("INVOCATION_GUI_PATH"))
        self.gui_input = QLineEdit(tr("DO_NOT_CHANGE"))
        self.gui_button = QPushButton(tr("BROWSE_BUTTON"))
        self.gui_button.clicked.connect(self.select_invocation_gui)
        right_layout.addWidget(self.gui_label, row, 0)
        right_layout.addWidget(self.gui_input, row, 1)
        right_layout.addWidget(self.gui_button, row, 2)
        row += 1

        # Language
        self.lang_label = QLabel(tr("INVOCATION_LANGUAGE"))
        self.lang_combo = QComboBox()
        self.lang_combo.addItem(tr("PLACEHOLDER_FOR_LANGUAGE"))
        for lang in [
            'English (en_US.UTF-8)',
            'Português Brasil (pt_BR.UTF-8)',
            'Português Portugal (pt_PT.UTF-8)',
            'Español España (es_ES.UTF-8)',
            'Español México (es_MX.UTF-8)',
            'Français (fr_FR.UTF-8)',
            'Deutsch (de_DE.UTF-8)',
            'Italiano (it_IT.UTF-8)',
            'Русский (ru_RU.UTF-8)',
            'Українська (uk_UA.UTF-8)',
            'Polski (pl_PL.UTF-8)',
            'Česky (cs_CZ.UTF-8)',
            'Slovenčina (sk_SK.UTF-8)',
            'Magyar (hu_HU.UTF-8)',
            'Română (ro_RO.UTF-8)',
            'Nederlands (nl_NL.UTF-8)',
            'Svenska (sv_SE.UTF-8)',
            'Norsk Bokmål (nb_NO.UTF-8)',
            'Dansk (da_DK.UTF-8)',
            'Suomi (fi_FI.UTF-8)',
            'Ελληνικά (el_GR.UTF-8)',
            'Български (bg_BL.UTF-8)',
            '日本語 (ja_JP.UTF-8)',
            '한국어 (ko_KR.UTF-8)',
            '简体中文 (zh_CN.UTF-8)',
            '繁體中文 (zh_TW.UTF-8)',
            'العربية (ar_SA.UTF-8)',
            'فارسی (fa_IR.UTF-8)',
            'Türkçe (tr_TR.UTF-8)',
            'हिन्दी (hi_IN.UTF-8)',
            'ไทย (th_TH.UTF-8)',
            'עברית (he_IL.UTF-8)',
        ]:
            self.lang_combo.addItem(lang)
        self.lang_combo.insertItem(0, tr("DO_NOT_CHANGE"))
        self.lang_combo.setCurrentIndex(0)
        right_layout.addWidget(self.lang_label, row, 0)
        right_layout.addWidget(self.lang_combo, row, 1, 1, 2)
        row += 1

        # Checkboxes with tristate
        self.ms_lang_checkbox = QCheckBox(tr("USE_MS_LANGUAGE_CODE"))
        self.ms_lang_checkbox.setTristate(True)
        self.ms_lang_checkbox.setCheckState(Qt.CheckState.PartiallyChecked)
        right_layout.addWidget(self.ms_lang_checkbox, row, 0, 1, 3)
        row += 1

        self.force_opengl_checkbox = QCheckBox(tr("FORCE_OPENGL"))
        self.force_opengl_checkbox.setTristate(True)
        self.force_opengl_checkbox.setCheckState(Qt.CheckState.PartiallyChecked)
        right_layout.addWidget(self.force_opengl_checkbox, row, 0, 1, 3)
        row += 1

        self.gamemode_checkbox = QCheckBox(tr("GAMEMODE"))
        self.gamemode_checkbox.setTristate(True)
        self.gamemode_checkbox.setCheckState(Qt.CheckState.PartiallyChecked)
        right_layout.addWidget(self.gamemode_checkbox, row, 0, 1, 3)
        row += 1

        self.umu_checkbox = QCheckBox(tr("USE_UMU_LAUNCHER"))
        self.umu_checkbox.setTristate(True)
        self.umu_checkbox.setCheckState(Qt.CheckState.PartiallyChecked)
        right_layout.addWidget(self.umu_checkbox, row, 0, 1, 3)
        row += 1

        # FPS HUD
        self.show_fps_checkbox = QCheckBox(tr("SHOW_FPS_OPTION"))
        self.show_fps_checkbox.setTristate(True)
        self.show_fps_checkbox.setCheckState(Qt.CheckState.PartiallyChecked)
        self.fps_hud_combo = QComboBox()
        self.fps_hud_options = [("FPS_GALLIUM_HUD", tr("FPS_GALLIUM_HUD")), 
                                ("FPS_DXVK_HUD", tr("FPS_DXVK_HUD")),
                                ("FPS_MANGOHUD", tr("FPS_MANGOHUD"))]
        for id, text in self.fps_hud_options:
            self.fps_hud_combo.addItem(text, id)
        self.fps_hud_combo.setEnabled(False)
        self.show_fps_checkbox.stateChanged.connect(self.update_fps_hud_state)
        right_layout.addWidget(self.show_fps_checkbox, row, 0)
        right_layout.addWidget(self.fps_hud_combo, row, 1, 1, 3)
        row += 1

        # Env vars
        self.env_label = QLabel(tr("ENVIRONMENT_VARS"))
        self.env_input = QLineEdit(tr("DO_NOT_CHANGE"))
        right_layout.addWidget(self.env_label, row, 0)
        right_layout.addWidget(self.env_input, row, 1, 1, 2)
        row += 1

        # Invocation args
        self.args_label = QLabel(tr("INVOCATION_ARGS"))
        self.args_input = QLineEdit(tr("DO_NOT_CHANGE"))
        right_layout.addWidget(self.args_label, row, 0)
        right_layout.addWidget(self.args_input, row, 1, 1, 2)
        row += 1

        self.add_default_clear(self.exec_input)
        self.add_default_clear(self.prefix_input)
        self.add_default_clear(self.art_input)
        self.add_default_clear(self.gui_input)
        self.add_default_clear(self.env_input)
        self.add_default_clear(self.args_input)

        # Reset and save buttons
        self.reset_button = QPushButton(tr("RESET_BUTTON_MULTIPLE_EDIT"))
        self.reset_button.clicked.connect(self.reset_fields)

        self.save_button = QPushButton(tr("SAVE_BUTTON"))
        self.save_button.clicked.connect(self.apply_multiple_edit)

        buttons_layout = QHBoxLayout()
        buttons_layout.addStretch()
        buttons_layout.addWidget(self.reset_button)
        buttons_layout.addWidget(self.save_button)

        right_layout.addLayout(buttons_layout, row, 0, 1, 3)

        # Loads invocations
        self.invocation_checkboxes = {}
        self.load_invocations()
        self.update_runner_filter()

    # Auxiliary functions

    # Select or deselect innovations listed in the Invocation Viewer.
    def set_checked_state(self, inv_name, state: bool):
        for checkbox in self.invocation_checkboxes.values():
            try:
                if checkbox.text() == inv_name:
                    checkbox.setChecked(state)
            except Exception:
                continue

    def closeEvent(self, event):
        viewer = getattr(self, "invocation_info_viewer", None)
        if viewer and viewer.isVisible():
            viewer.close()
        super().closeEvent(event)

    def open_invocation_info_viewer(self):
        if getattr(self, "invocation_info_viewer", None) and self.invocation_info_viewer.isVisible():
            self.invocation_info_viewer.raise_()
            self.invocation_info_viewer.activateWindow()
            return

        self.invocation_info_viewer = InvocationInfoViewerDialog(self.parent_ref.zordeer_dir, self, multiple_edit_dialog=self)
        self.invocation_info_viewer.finished.connect(lambda _: setattr(self, "invocation_info_viewer", None))
        self.invocation_info_viewer.show()

    def keyPressEvent(self, event):
        if event.key() in (Qt.Key.Key_Return, Qt.Key.Key_Enter):
            # Prevents Enter from triggering something that is not selected
            return
        super().keyPressEvent(event)

    def add_default_clear(self, line_edit):
        original_keyPressEvent = line_edit.keyPressEvent

        def new_keyPressEvent(event):
            if line_edit.text() == tr("DO_NOT_CHANGE"):
                line_edit.clear()
            # Invoke normal QLineEdit behavior
            original_keyPressEvent(event)

        line_edit.keyPressEvent = new_keyPressEvent

    def eventFilter(self, obj, event):
        if isinstance(obj, QLineEdit) and event.type() == QEvent.Type.FocusIn:
            if obj.text() == tr("DO_NOT_CHANGE"):
                obj.clear()
        return super().eventFilter(obj, event)

    def update_runner_filter(self):
        """Updates the available runners in the filter based on the invocation-info files."""
        runners = set()
        for cb in self.invocation_checkboxes.values():
            try:
                with open(cb.invocation_file, encoding="utf-8") as f:
                    data = toml.load(f)
                runner = data.get("runner", "")
                if not runner:
                    runner = tr("PLACEHOLDER_FOR_RUNNER")
                runners.add(runner)
            except Exception:
                continue

        current = self.runner_filter.currentText()
        self.runner_filter.blockSignals(True)
        self.runner_filter.clear()
        self.runner_filter.addItem(tr("ALL_INVOCATIONS"))
        placeholder = tr("PLACEHOLDER_FOR_RUNNER")
        if placeholder in runners:
            self.runner_filter.addItem(placeholder)
            runners.remove(placeholder)
        if "Wine" in runners:
            self.runner_filter.addItem("Wine")
            runners.remove("Wine")
        for runner in sorted(runners, reverse=True):
            self.runner_filter.addItem(runner)
        # Keep the previous selection, if it still exists.
        index = self.runner_filter.findText(current)
        if index != -1:
            self.runner_filter.setCurrentIndex(index)
        self.runner_filter.blockSignals(False)

    def populate_runners(self):
        runners_path = Path.home() / "AppsFiles" / "Zordeer" / "runner"
        runners_path.mkdir(parents=True, exist_ok=True)
        runners = [d.name for d in runners_path.iterdir() if d.is_dir()]

        self.runner_combo.clear()

        items = [tr("PLACEHOLDER_FOR_RUNNER")]

        if shutil.which("wine"):
            items.append("Wine")

        items += sorted(runners, reverse=True)

        self.runner_combo.addItems(items)

    def update_fps_hud_state(self, state):
        self.fps_hud_combo.setEnabled(Qt.CheckState(state) == Qt.CheckState.Checked)

    def select_executable(self):
        invocations_dir = Path.home() / "AppsFiles" / "Zordeer" / "invocation"
        invocations_dir.mkdir(parents=True, exist_ok=True)

        file_path, _ = QFileDialog.getOpenFileName(
            self,
            tr("SELECT_EXECUTABLE"),
            str(invocations_dir),
            tr("EXECUTABLE_FILE_FILTER")
        )

        if file_path:
            self.exec_input.setText(file_path)

    def select_prefix(self):
        invocations_dir = Path.home() / "AppsFiles" / "Zordeer" / "invocation"
        invocations_dir.mkdir(parents=True, exist_ok=True)

        dir_path = QFileDialog.getExistingDirectory(
            self,
            tr("SELECT_PREFIX_TITLE"),
            str(invocations_dir)
        )
        if dir_path:
            self.prefix_input.setText(dir_path)

    def select_invocation_art(self):
        heroes_dir = Path.home() / "AppsFiles" / "Zordeer" / "sgdb" / "heroes"
        heroes_dir.mkdir(parents=True, exist_ok=True)

        file_path, _ = QFileDialog.getOpenFileName(
            self,
            tr("SELECT_INVOCATION_ART"),
            str(heroes_dir),
            tr("IMAGE_FILTER")
        )
        if file_path:
            self.art_input.setText(file_path)

    def select_invocation_gui(self):
        icons_dir = Path.home() / "AppsFiles" / "Zordeer" / "sgdb" / "icons"
        icons_dir.mkdir(parents=True, exist_ok=True)

        file_path, _ = QFileDialog.getOpenFileName(
            self,
            tr("SELECT_INVOCATION_ART"),
            str(icons_dir),
            tr("IMAGE_FILTER")
        )
        if file_path:
            self.gui_input.setText(file_path)

    def load_invocations(self):
        config_dir = Path.home() / "AppsFiles" / "Zordeer" / "config"
        self.invocation_checkboxes.clear()
        while self.scroll_layout.count():
            item = self.scroll_layout.takeAt(0)
            widget = item.widget()
            if widget:
                widget.deleteLater()
        invocation_files = sorted(config_dir.glob("invocation-info-*.toml"), key=lambda p: p.stem.lower())
        for invocation_file in invocation_files:
            try:
                with open(invocation_file, encoding="utf-8") as f:
                    data = toml.load(f)
                name = data.get("name", invocation_file.stem)
                cb = QCheckBox(name)
                cb.invocation_file = invocation_file
                self.scroll_layout.addWidget(cb)
                self.invocation_checkboxes[name] = cb
            except Exception:
                continue
        self.scroll_layout.addStretch()

    def update_invocation_list(self, _=None):
        search_text = self.search_input.text().lower()
        selected_runner = self.runner_filter.currentText()

        for name, cb in self.invocation_checkboxes.items():
            try:
                with open(cb.invocation_file, encoding="utf-8") as f:
                    data = toml.load(f)
                runner = data.get("runner", "")
                if not runner:
                    runner = tr("PLACEHOLDER_FOR_RUNNER")
            except Exception:
                runner = tr("PLACEHOLDER_FOR_RUNNER")

            matches_text = search_text in name.lower()
            matches_runner = (selected_runner == tr("ALL_INVOCATIONS")) or (runner == selected_runner)
            cb.setVisible(matches_text and matches_runner)

    def select_all_invocations(self):
        for cb in self.invocation_checkboxes.values():
            if cb.isVisible():
                cb.setChecked(True)

    def deselect_all_invocations(self):
        for cb in self.invocation_checkboxes.values():
            if cb.isVisible():
                cb.setChecked(False)

    def reset_fields(self):
        # Runner
        self.runner_combo.setCurrentIndex(0)

        # Executable / Prefix / Art / Gui
        self.exec_input.setText(tr("DO_NOT_CHANGE"))
        self.prefix_input.setText(tr("DO_NOT_CHANGE"))
        self.art_input.setText(tr("DO_NOT_CHANGE"))
        self.gui_input.setText(tr("DO_NOT_CHANGE"))

        # Language
        self.lang_combo.setCurrentIndex(0)

        # Checkboxes
        self.ms_lang_checkbox.setCheckState(Qt.CheckState.PartiallyChecked)
        self.force_opengl_checkbox.setCheckState(Qt.CheckState.PartiallyChecked)
        self.gamemode_checkbox.setCheckState(Qt.CheckState.PartiallyChecked)
        self.umu_checkbox.setCheckState(Qt.CheckState.PartiallyChecked)

        # FPS HUD
        self.show_fps_checkbox.setCheckState(Qt.CheckState.PartiallyChecked)
        self.fps_hud_combo.setCurrentIndex(0)
        self.fps_hud_combo.setEnabled(False)

        # Env vars / Args
        self.env_input.setText(tr("DO_NOT_CHANGE"))
        self.args_input.setText(tr("DO_NOT_CHANGE"))

    def resolve_default_art_path(self, invocation_name: str) -> str:
        heroes_dir = Path.home() / "AppsFiles" / "Zordeer" / "sgdb" / "heroes"
        for folder in heroes_dir.iterdir():
            if folder.is_dir() and folder.name.lower() == invocation_name.lower():
                for ext in ("*.jpg", "*.jpeg", "*.png", "*.webp"):
                    images = list(folder.glob(ext))
                    if images:
                        return str(images[0])
        return ""

    def resolve_default_gui_path(self, invocation_name: str) -> str:
        icons_dir = Path.home() / "AppsFiles" / "Zordeer" / "sgdb" / "icons"
        for folder in icons_dir.iterdir():
            if folder.is_dir() and folder.name.lower() == invocation_name.lower():
                for ext in ("*.jpg", "*.jpeg", "*.png", "*.webp"):
                    images = list(folder.glob(ext))
                    if images:
                        return str(images[0])
        return ""

    # Apply changes
    def apply_multiple_edit(self):
        selected = [cb for cb in self.invocation_checkboxes.values() if cb.isChecked()]
        if not selected:
            QMessageBox.warning(self, tr("APP_NAME"), tr("NO_INVOCATION_SELECTED_MULTIPLE"))
            return

        for cb in selected:
            with open(cb.invocation_file, encoding="utf-8") as f:
                data = toml.load(f)

            # Apply fields
            # Runner
            runner = self.runner_combo.currentText()
            if runner != tr("DO_NOT_CHANGE"):
                data["runner"] = "" if runner == tr("PLACEHOLDER_FOR_RUNNER") else runner

            # Executable
            exec_path = self.exec_input.text()
            if exec_path != tr("DO_NOT_CHANGE"):
                data["exec_path"] = exec_path

            # Prefix
            prefix_text = self.prefix_input.text().strip()
            if prefix_text != tr("DO_NOT_CHANGE"):
                if prefix_text == "":
                    # Uses the standard prefix animarium_prefix
                    prefix_path = Path.home() / "AppsFiles" / "Zordeer" / "invocation" / "animarium_prefix"
                    prefix_path.mkdir(parents=True, exist_ok=True)
                    data["prefix_path"] = str(prefix_path)
                else:
                    data["prefix_path"] = prefix_text

            # Art
            art_input_text = self.art_input.text().strip()
            if art_input_text != tr("DO_NOT_CHANGE"):
                if not art_input_text:
                    art_input_text = self.resolve_default_art_path(data["name"])

                if art_input_text:
                    try:
                        art_dir = Path.home() / "AppsFiles" / "Zordeer" / "art"
                        art_dir.mkdir(parents=True, exist_ok=True)
                        ext = Path(art_input_text).suffix.lower()
                        new_art_path = art_dir / f"{data['name'].replace(' ', '_').lower()}{ext}"
                        shutil.copyfile(art_input_text, new_art_path)
                        data["art_path"] = str(new_art_path)
                    except FileNotFoundError:
                        pass

            # Gui
            gui_input_text = self.gui_input.text().strip()
            if gui_input_text != tr("DO_NOT_CHANGE"):
                if not gui_input_text:
                    gui_input_text = self.resolve_default_gui_path(data["name"])

                if gui_input_text:
                    try:
                        gui_dir = Path.home() / "AppsFiles" / "Zordeer" / "art" / "gui"
                        gui_dir.mkdir(parents=True, exist_ok=True)
                        ext = Path(gui_input_text).suffix.lower()
                        new_gui_path = gui_dir / f"{data['name'].replace(' ', '_').lower()}{ext}"
                        shutil.copyfile(gui_input_text, new_gui_path)
                        data["gui_path"] = str(new_gui_path)
                    except FileNotFoundError:
                        pass

            # Language
            lang = self.lang_combo.currentText()
            if lang != tr("DO_NOT_CHANGE"):
                data["language"] = lang

            # Checkboxes
            def apply_checkbox(cb_widget, key):
                state = cb_widget.checkState()
                if state != Qt.CheckState.PartiallyChecked:
                    data[key] = (state == Qt.CheckState.Checked)
            apply_checkbox(self.ms_lang_checkbox, "use_ms_language_code")
            apply_checkbox(self.force_opengl_checkbox, "force_opengl")
            apply_checkbox(self.gamemode_checkbox, "use_gamemode")
            apply_checkbox(self.umu_checkbox, "use_umu")

            # FPS HUD
            if self.show_fps_checkbox.checkState() == Qt.CheckState.Checked:
                data["show_fps"] = True
                data["fps_hud_type"] = self.fps_hud_combo.currentData()
            elif self.show_fps_checkbox.checkState() == Qt.CheckState.Unchecked:
                data["show_fps"] = False
                data["fps_hud_type"] = self.fps_hud_combo.currentData()

            # Env vars
            env_vars = self.env_input.text()
            if env_vars != tr("DO_NOT_CHANGE"):
                data["env_vars"] = env_vars.strip()

            # Invocation args
            args = self.args_input.text()
            if args != tr("DO_NOT_CHANGE"):
                data["invocation_args"] = args.strip()

            # Save TOML
            with open(cb.invocation_file, "w", encoding="utf-8") as f:
                toml.dump(data, f)

        if self.parent_ref:
            self.update_runner_filter()
            self.update_invocation_list(self.search_input.text())
            self.parent_ref.load_invocations()

        QMessageBox.information(
            self,
            tr("MULTIPLE_INVOCATION_EDITOR"),
            tr("CHANGES_SAVED")
        )

        # Updates the right panel of the InvocationInfoViewerDialog.
        if hasattr(self, "invocation_info_viewer") and self.invocation_info_viewer:
            self.invocation_info_viewer.reload_current_selection()

class InvocationInfoViewerDialog(QDialog):
    def __init__(self, zordeer_dir=None, parent=None, multiple_edit_dialog=None):
        super().__init__(parent)
        self.multiple_edit_dialog = multiple_edit_dialog
        self.setWindowTitle(tr("INVOCATION_INFO_VIEWER_TITLE"))
        self.setAttribute(Qt.WidgetAttribute.WA_DeleteOnClose, True)
        if parent is not None:
            self.destroyed.connect(lambda: setattr(parent, "invocation_info_viewer", None))
        self.resize(580, 480)

        # Zordeer Directory
        self.zordeer_dir = Path(zordeer_dir) if zordeer_dir else Path.home() / "AppsFiles" / "Zordeer"
        self.invocations = self.load_invocations()

        # Left widget: Search, combobox, list
        left_widget = QWidget()
        left_layout = QVBoxLayout(left_widget)
        left_layout.setContentsMargins(0, 0, 0, 0)

        # Search bar
        self.search_box = QLineEdit()
        self.search_box.setPlaceholderText(tr("SEARCH"))
        self.search_box.textChanged.connect(self.filter_invocations)
        left_layout.addWidget(self.search_box)

        # Combobox for search
        self.search_mode_combo = QComboBox()
        self.search_mode_combo.addItems([tr("NAME"), tr("CONTENT")])
        self.search_mode_combo.currentIndexChanged.connect(
            lambda _: self.filter_invocations(self.search_box.text())
        )
        left_layout.addWidget(self.search_mode_combo)

        # Scroll area for radio buttons
        self.scroll = QScrollArea()
        self.scroll.setWidgetResizable(True)
        self.container = QWidget()
        self.scroll_layout = QVBoxLayout(self.container)
        self.scroll_layout.setContentsMargins(6, 6, 6, 6)
        self.scroll_layout.setSpacing(4)
        self.scroll.setWidget(self.container)
        left_layout.addWidget(self.scroll)

        # mark/unmark listed buttons (added)
        self.btn_mark_listed = QPushButton(tr("MARK_LISTED"))
        self.btn_unmark_listed = QPushButton(tr("UNMARK_LISTED"))

        self.btn_mark_listed.clicked.connect(self.mark_listed)
        self.btn_unmark_listed.clicked.connect(self.unmark_listed)

        left_layout.addWidget(self.btn_mark_listed)
        left_layout.addWidget(self.btn_unmark_listed)

        # Radio button group
        self.button_group = QButtonGroup(self)
        self.button_group.setExclusive(True)
        self.button_group.buttonToggled.connect(self.handle_button_toggled)

        # Text box
        self.text_box = QTextEdit()
        self.text_box.setReadOnly(True)
        self.text_box.setAcceptRichText(True)
        self.text_box.setTextInteractionFlags(Qt.TextInteractionFlag.TextSelectableByMouse)

        # Styling
        palette = QApplication.palette()
        base_color = palette.color(QPalette.ColorRole.Base)
        text_color = palette.color(QPalette.ColorRole.Text)
        accent_color = palette.color(QPalette.ColorRole.Highlight)

        self.text_box.setStyleSheet(f"""
            QTextEdit {{
                background-color: {base_color.name()};
                color: {text_color.name()};
            }}
        """)

        # Qsplitter and main layout
        splitter = QSplitter(Qt.Orientation.Horizontal)
        splitter.addWidget(left_widget)
        splitter.addWidget(self.text_box)
        splitter.setChildrenCollapsible(False)

        splitter.setSizes([200, 460])

        main_layout = QHBoxLayout(self)
        main_layout.setContentsMargins(6, 6, 6, 6)
        main_layout.addWidget(splitter)

        self.radio_buttons = []
        self.create_invocation_buttons()

    # In the MultipleEditInvocationDialog, mark all the innovations that are visible
    def mark_listed(self):
        if not getattr(self, "multiple_edit_dialog", None):
            return

        listed = []
        for rb in self.radio_buttons:
            if rb.isVisible():
                listed.append(rb.text())

        for name in listed:
            self.multiple_edit_dialog.set_checked_state(name, True)

    # In the Multiple Edit Invocation Dialog, uncheck all the innovations that are visible
    def unmark_listed(self):
        if not getattr(self, "multiple_edit_dialog", None):
            return

        listed = []
        for rb in self.radio_buttons:
            if rb.isVisible():
                listed.append(rb.text())

        for name in listed:
            self.multiple_edit_dialog.set_checked_state(name, False)

    def keyPressEvent(self, event):
        if event.key() in (Qt.Key.Key_Return, Qt.Key.Key_Enter):
            # Prevents Enter from triggering something that is not selected
            return
        super().keyPressEvent(event)

    def closeEvent(self, event):
        # Notifies the MultipleEditInvocationDialog that this dialog has been closed.
        if hasattr(self.parent(), "invocation_info_viewer"):
            self.parent().invocation_info_viewer = None
        super().closeEvent(event)

    # Loads the available TOML files.
    def load_invocations(self) -> list[dict]:
        config_dir = self.zordeer_dir / "config"
        invocations = []
        if not config_dir.exists():
            return invocations

        for file in config_dir.glob("invocation-info-*.toml"):
            try:
                with open(file, "r", encoding="utf-8") as f:
                    inv = toml.load(f)
                    inv["__filename"] = file.name
                    invocations.append(inv)
            except Exception:
                pass
        return invocations

    # Create radio buttons
    def create_invocation_buttons(self):
        # Sort alphabetically
        self.invocations.sort(
            key=lambda i: (i.get("name") or i.get("display_name") or i.get("id") or "").lower()
        )

        first_rb = None
        for inv in self.invocations:
            filename = inv.get("__filename", "")
            display_name = inv.get("name") or inv.get("display_name") or inv.get("id")
            rb = QRadioButton(display_name)
            rb.setProperty("invocation_filename", filename)
            self.button_group.addButton(rb)
            self.scroll_layout.addWidget(rb)
            self.radio_buttons.append(rb)
            if first_rb is None:
                first_rb = rb

        self.scroll_layout.addStretch(1)

        # Initial Selection
        if first_rb:
            first_rb.setChecked(True)
            self.show_invocation_info_from_file(first_rb.property("invocation_filename"))

    # Search filter
    def filter_invocations(self, text: str):
        text = (text or "").strip().lower()
        first_visible = None
        search_mode = self.search_mode_combo.currentText()

        for rb in self.radio_buttons:
            filename = rb.property("invocation_filename")
            match = False

            if search_mode == tr("NAME"):
                match = text in rb.text().lower()
            else:  # Content
                file_path = self.zordeer_dir / "config" / filename
                if file_path.exists():
                    try:
                        with open(file_path, "r", encoding="utf-8") as f:
                            data = toml.load(f)
                        # Search for content only in these fields
                        for key in ["exec_path", "prefix_path", "language", "fps_hud_type", "env_vars", "invocation_args"]:
                            value = str(data.get(key, "")).lower()
                            if text in value:
                                match = True
                                break
                    except Exception:
                        match = False

            rb.setVisible(match)
            if match and first_visible is None:
                first_visible = rb

        if first_visible:
            first_visible.setChecked(True)

            checked = self.button_group.checkedButton()
            if checked:
                filename = checked.property("invocation_filename")
                self.show_invocation_info_from_file(filename)
        else:
            self.text_box.clear()

    # When a radio button is clicked
    def handle_button_toggled(self, button, checked: bool):
        if not checked or not button:
            return
        filename = button.property("invocation_filename")
        if filename:
            self.show_invocation_info_from_file(filename)

    # Display information by reading the TOML.
    def show_invocation_info_from_file(self, filename: str):
        file_path = self.zordeer_dir / "config" / filename
        if not file_path.exists():
            self.text_box.clear()
            return

        try:
            with open(file_path, "r", encoding="utf-8") as f:
                inv = toml.load(f)
        except Exception:
            self.text_box.clear()
            return

        self.text_box.clear()
        cursor = self.text_box.textCursor()
        palette = QApplication.palette()
        key_color = palette.color(QPalette.ColorRole.Highlight)
        value_color = palette.color(QPalette.ColorRole.Text)

        translations = {
            "name": tr("INVOCATION_NAME"),
            "runner": tr("RUNNER_VERSION"),
            "exec_path": tr("EXECUTABLE_PATH"),
            "prefix_path": tr("PREFIX_PATH"),
            "art_path": tr("INVOCATION_ART_PATH"),
            "gui_path": tr("INVOCATION_GUI_PATH"),
            "language": tr("INVOCATION_LANGUAGE"),
            "use_ms_language_code": tr("USE_MS_LANGUAGE_CODE"),
            "force_opengl": tr("FORCE_OPENGL"),
            "use_gamemode": tr("GAMEMODE"),
            "use_umu": tr("USE_UMU_LAUNCHER"),
            "show_fps": tr("SHOW_FPS_OPTION"),
            "fps_hud_type": tr("SHOW_FPS_OPTION_HUD"),
            "env_vars": tr("ENVIRONMENT_VARS"),
            "invocation_args": tr("INVOCATION_ARGS"),
        }

        value_translations = {
            "FPS_GALLIUM_HUD": tr("FPS_GALLIUM_HUD"),
            "FPS_DXVK_HUD": tr("FPS_DXVK_HUD"),
            "FPS_MANGOHUD": tr("FPS_MANGOHUD"),
        }

        for key, value in inv.items():
            if isinstance(value, bool):
                value = "✅" if value else "❌"

            if isinstance(value, str) and value in value_translations:
                value = value_translations[value]
                value = re.sub(r"\s*\(.*?\)", "", value).strip()

            key_label = translations.get(key, key)

            fmt_key = QTextCharFormat()
            fmt_key.setForeground(QColor(key_color))

            fmt_value = QTextCharFormat()
            fmt_value.setForeground(QColor(value_color))

            cursor.insertText(f"{key_label}: ", fmt_key)
            cursor.insertText(str(value) + "\n", fmt_value)

        self.text_box.moveCursor(QTextCursor.MoveOperation.Start)

    def reload_current_selection(self):
        search_text = self.search_box.text().strip()
        search_mode = self.search_mode_combo.currentText()

        # Reload all invocation files
        self.invocations = self.load_invocations()

        # Clear the scroll layout completely
        while self.scroll_layout.count():
            item = self.scroll_layout.takeAt(0)
            widget = item.widget()
            if widget:
                widget.deleteLater()

        self.radio_buttons.clear()
        self.button_group = QButtonGroup(self)
        self.button_group.setExclusive(True)
        self.button_group.buttonToggled.connect(self.handle_button_toggled)

        # Recreate buttons
        self.create_invocation_buttons()

        # Reapply filter (if there was any text)
        if search_text:
            self.search_mode_combo.setCurrentText(search_mode)
            self.filter_invocations(search_text)

class RunInPrefix(QDialog):
    def __init__(self, parent, invocation_name):
        super().__init__(parent)
        self.parent = parent  # Zordeer
        self.invocation_name = invocation_name
        self.setWindowTitle(tr("RUN_IN_PREFIX_INVOCATION_NAME", invocation_name=invocation_name))
        self.resize(500, 300)
        self._has_printed_waiting_message = False

        # Preventive cleanup: delete old leftovers
        config_dir = Path(self.parent.zordeer_dir) / "config"
        config_dir.mkdir(parents=True, exist_ok=True)

        for fname in config_dir.iterdir():
            if fname.name.endswith("_ztffrip.toml"):
                try:
                    fname.unlink()
                except Exception:
                    pass

        # Main layout
        layout = QVBoxLayout(self)

        # List of executables (Only names, no paths)
        self.exe_list = QTreeWidget()
        self.exe_list.setHeaderLabels([tr("SELECTED_EXECUTABLES")])
        self.exe_list.setColumnCount(1)
        self.exe_list.setRootIsDecorated(True)
        self.exe_list.setSelectionMode(QTreeWidget.SelectionMode.NoSelection)
        layout.addWidget(self.exe_list)

        # Top buttons (Browse / Clear)
        btn_top = QHBoxLayout()
        self.select_btn = QPushButton(tr("ADD_FILES"))
        self.clear_btn = QPushButton(tr("CLEAR_LIST"))
        btn_top.addWidget(self.select_btn)
        btn_top.addWidget(self.clear_btn)
        layout.addLayout(btn_top)

        # Execution mode section (radio buttons)
        layout.addWidget(QLabel(tr("EXECUTION_MODE")))

        self.radio_group = QButtonGroup(self)

        self.radio_clean = QRadioButton(tr("CLEAN_RUN"))               # Prevents env vars
        self.radio_automatic = QRadioButton(tr("AUTOMATIC_RUN"))       # Silent args like /VERYSILENT
        self.radio_normal = QRadioButton(tr("NORMAL_RUN"))             # Untouched TOML

        self.radio_group.addButton(self.radio_clean)
        self.radio_group.addButton(self.radio_automatic)
        self.radio_group.addButton(self.radio_normal)

        self.radio_clean.setChecked(True)  # Default selection

        # Group layout for radios
        radios_layout = QVBoxLayout()
        radios_layout.addWidget(self.radio_clean)
        radios_layout.addWidget(self.radio_automatic)
        radios_layout.addWidget(self.radio_normal)
        layout.addLayout(radios_layout)

        # Bottom buttons (Run / Stop)
        btn_bottom = QHBoxLayout()
        self.run_btn = QPushButton(tr("CONFIRM_AND_RUN"))
        self.force_stop_btn = QPushButton(tr("STOP_CURRENT"))

        if hasattr(self.parent, "stop_execution"):
            self.force_stop_btn.clicked.connect(self.parent.stop_execution)
        else:
            self.force_stop_btn.setEnabled(False)

        btn_bottom.addWidget(self.run_btn)
        btn_bottom.addWidget(self.force_stop_btn)
        layout.addLayout(btn_bottom)

        # Progress bar
        self.progress = QProgressBar()
        self.progress.setValue(0)
        layout.addWidget(self.progress)

        # Connections
        self.select_btn.clicked.connect(self.select_exes)
        self.clear_btn.clicked.connect(self.clear_list)
        self.run_btn.clicked.connect(self.start_execution)

        # Control variables
        self.exe_queue = []
        self.current_index = 0

        # TOML paths
        self.safe_invocation = self.invocation_name.replace(" ", "_").lower()
        self.real_toml_path = config_dir / f"invocation-info-{self.safe_invocation}.toml"
        self.temp_toml_path = config_dir / f"invocation-info-{self.safe_invocation}_ztffrip.toml"

        # Backup of the original TOML in memory (loaded in start_execution)
        self._original_toml = None

    def highlight_current_exe(self, exe_path):
        for i in range(self.exe_list.topLevelItemCount()):
            item = self.exe_list.topLevelItem(i)
            item_path = item.data(0, 0x0100)
            item.setSelected(item_path == exe_path)

    def keyPressEvent(self, event):
        if event.key() in (Qt.Key.Key_Return, Qt.Key.Key_Enter):
            # Prevents Enter from triggering something that is not selected
            return
        super().keyPressEvent(event)

    def clear_list(self):
        self.exe_list.clear()
        self.exe_queue = []
        self.current_index = 0

        self.progress.setValue(0)

    def select_exes(self):
        files, _ = QFileDialog.getOpenFileNames(
            self, tr("SELECT_EXECUTABLE"), "", tr("EXECUTABLE_FILE_FILTER")
        )
        for f in files:
            path_obj = Path(f)
            item = QTreeWidgetItem([path_obj.name])
            # Stores the full path to UserRole
            item.setData(0, 0x0100, str(path_obj))
            self.exe_list.addTopLevelItem(item)

    def start_execution(self):
        if self.exe_list.topLevelItemCount() == 0:
            QMessageBox.warning(self, tr("APP_NAME"), tr("NO_EXECUTABLE_SELECTED"))
            return

        self.set_execution_locked(True)

        # Load and store the original TOML once
        try:
            with open(self.real_toml_path, "r", encoding="utf-8") as f:
                self._original_toml = toml.load(f)
        except Exception as e:
            QMessageBox.critical(
                self,
                tr("APP_NAME"),
                tr("INVOCATION_INFO_ERROR", error=str(e))
            )
            return

        # Build queue
        self.exe_queue = [self.exe_list.topLevelItem(i).data(0, 0x0100)for i in range(self.exe_list.topLevelItemCount())]
        self.current_index = 0
        self.progress.setMaximum(len(self.exe_queue))
        self.progress.setValue(0)

        # Start execution
        self.run_next_exe()

    def run_next_exe(self):
        # End of the queue?
        if self.current_index >= len(self.exe_queue):
            # Clean up the temporary file and finish
            try:
                temp_path = Path(self.temp_toml_path)
                if temp_path.exists():
                    temp_path.unlink()
                    print(tr("DEBUG_TEMP_FILE_REMOVED", path=str(temp_path)))
            except Exception:
                pass
            print(tr("RUN_IN_PREFIX_DONE"))
            self.set_execution_locked(False)
            return

        # Current executable
        exe_path = self.exe_queue[self.current_index]

        self.highlight_current_exe(exe_path)
        QApplication.processEvents()

        # Temporary name/file (derived from the original safe name)
        temp_safe_name = f"{self.safe_invocation}_ztffrip".lower()
        config_dir = Path(self.parent.zordeer_dir) / "config"
        self.temp_toml_path = str(config_dir / f"invocation-info-{temp_safe_name}.toml")

        # Clone original and set the exe to run
        mod = dict(self._original_toml)
        mod["exec_path"] = exe_path
        mod["name"] = temp_safe_name  # Ensures that start_invocation validates the name

        # Clear fields from 'language' onward when "Disable variables" is selected
        if self.radio_clean.isChecked():
            mod["language"] = ""
            mod["force_opengl"] = False
            mod["use_gamemode"] = False
            mod["use_umu"] = False
            mod["env_vars"] = ""
            mod["invocation_args"] = ""
            mod["show_fps"] = False
            mod["fps_hud_type"] = ""

        elif self.radio_automatic.isChecked():
            # Normal values restored, but add silent args
            for key in ("language", "force_opengl", "use_gamemode", "env_vars",
                        "show_fps", "fps_hud_type"):
                if key in self._original_toml:
                    mod[key] = self._original_toml[key]
                else:
                    mod.pop(key, None)
            mod["invocation_args"] = "/VERYSILENT /NORESTART /SILENT /S /quiet /qn"

        else:  # Self.radio_normal.isChecked()
            # Just restore original TOML (no modifications)
            for key in ("language", "force_opengl", "use_gamemode", "env_vars",
                        "show_fps", "fps_hud_type", "invocation_args"):
                if key in self._original_toml:
                    mod[key] = self._original_toml[key]
                else:
                    mod.pop(key, None)

            mod["invocation_args"] = self._original_toml.get("invocation_args", "")

        # Save ONLY the temporary TOML
        try:
            with open(self.temp_toml_path, "w", encoding="utf-8") as f:
                toml.dump(mod, f)
        except Exception as e:
            QMessageBox.critical(self, tr("APP_NAME"), tr("FAILED_UPDATE_TOML", error=e))
            return

        print(tr(
            "RUNNING_IN_PREFIX",
            name=self.invocation_name,
            exe=exe_path,
            silent=self.radio_automatic.isChecked()
        ))

        # Run the temporary "invocation" (start_invocation resolves the path by safe name)
        self.parent.start_invocation(temp_safe_name)

        # Schedule periodic check for completion
        QTimer.singleShot(2000, self.wait_until_finished)

    def wait_until_finished(self):
        # Automatic installation
        if self.radio_automatic.isChecked():
            if self.parent.invocation_process and self.parent.invocation_process.poll() is None:
                QTimer.singleShot(2000, self.wait_until_finished)
                return

            self.parent.stop_execution()
            self.current_index += 1
            self.progress.setValue(self.current_index)
            self.run_next_exe()
            return

        # Clean run e normal run
        if not self._has_printed_waiting_message:
            print(tr("RUN_IN_PREFIX_WAITING"))
            self._has_printed_waiting_message = True

        started_prefix = tr("INVOCATION_STARTED", invocation_name="").split("{invocation_name}")[0].strip()
        if self.parent.windowTitle().startswith(started_prefix):
            QTimer.singleShot(2000, self.wait_until_finished)
        else:
            self.current_index += 1
            self.progress.setValue(self.current_index)
            self._has_printed_waiting_message = False
            self.run_next_exe()

        try:
            temp_path = Path(self.temp_toml_path)
            if temp_path.exists():
                temp_path.unlink()
        except Exception:
            pass

    def set_execution_locked(self, locked: bool):
        self.run_btn.setEnabled(not locked)
        self.select_btn.setEnabled(not locked)
        self.clear_btn.setEnabled(not locked)

        for radio in (self.radio_clean, self.radio_automatic, self.radio_normal):
            radio.setEnabled(not locked)

        if not locked:
            for i in range(self.exe_list.topLevelItemCount()):
                self.exe_list.topLevelItem(i).setSelected(False)

    def closeEvent(self, event):
        # Cleanup if the window is manually closed
        try:
            temp_path = Path(self.temp_toml_path)
            if temp_path.exists():
                temp_path.unlink()
                print(tr("DEBUG_TEMP_FILE_REMOVED", path=str(temp_path)))
        except Exception:
            pass
        event.accept()

class ShortcutManager(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle(tr("SHORTCUTS_MANAGER_TITLE"))
        self.resize(340, 400)

        # Zordeer base directory
        self.zordeer_dir = Path.home() / "AppsFiles" / "Zordeer"
        self.CONFIG_DIR = self.zordeer_dir / "config"

        # Load invocations and shortcuts info
        self.invocations = self.load_invocations()
        self.shortcut_manager_info = self.load_shortcut_manager_info()

        # Current view: "desktop" or "menu"
        self.current_view = "desktop"
        self.checkbox_states = {"desktop": {}, "menu": {}}
        self.checkbox_widgets = {"desktop": {}, "menu": {}}

        # UI
        main_layout = QVBoxLayout(self)

        # Search bar
        self.search_bar = QLineEdit()
        self.search_bar.setPlaceholderText(tr("SEARCH"))
        self.search_bar.textChanged.connect(self.update_list_view)
        main_layout.addWidget(self.search_bar)

        # ComboBox to switch view
        self.view_combo = QComboBox()
        self.view_combo.addItems([tr("SHORTCUTS_OF_DESKTOP"), tr("SHORTCUTS_OF_MENU")])
        self.view_combo.currentIndexChanged.connect(self.update_list_view)
        main_layout.addWidget(self.view_combo)

        # Scroll area for checkboxes
        self.scroll_area = QScrollArea()
        self.scroll_area.setWidgetResizable(True)
        self.scroll_content = QWidget()
        self.scroll_layout = QVBoxLayout(self.scroll_content)
        self.scroll_layout.setContentsMargins(6, 6, 6, 6)
        self.scroll_layout.setSpacing(4)
        self.scroll_content.setLayout(self.scroll_layout)
        self.scroll_area.setWidget(self.scroll_content)
        main_layout.addWidget(self.scroll_area)

        # Select / Deselect All buttons
        select_layout = QHBoxLayout()
        self.select_all_btn = QPushButton(tr("SELECT_ALL_IN_MULTIPLE_EDIT"))
        self.select_all_btn.clicked.connect(self.select_all_checkboxes)
        self.deselect_all_btn = QPushButton(tr("DESELECT_ALL_IN_MULTIPLE_EDIT"))
        self.deselect_all_btn.clicked.connect(self.deselect_all_checkboxes)
        select_layout.addWidget(self.select_all_btn)
        select_layout.addWidget(self.deselect_all_btn)
        main_layout.addLayout(select_layout)

        # Folder selection
        grid = QGridLayout()
        self.desktop_dir_input = QLineEdit(self.shortcut_manager_info.get("desktop_dir", ""))
        desktop_browse = QPushButton(tr("BROWSE_BUTTON"))
        desktop_browse.clicked.connect(lambda: self.browse_folder(self.desktop_dir_input))
        grid.addWidget(QLabel(tr("DESKTOP_FOLDER")), 0, 0)
        grid.addWidget(self.desktop_dir_input, 0, 1)
        grid.addWidget(desktop_browse, 0, 2)

        self.menu_dir_input = QLineEdit(self.shortcut_manager_info.get("menu_dir", ""))
        menu_browse = QPushButton(tr("BROWSE_BUTTON"))
        menu_browse.clicked.connect(lambda: self.browse_folder(self.menu_dir_input))
        grid.addWidget(QLabel(tr("MENU_FOLDER")), 1, 0)
        grid.addWidget(self.menu_dir_input, 1, 1)
        grid.addWidget(menu_browse, 1, 2)

        grid.setContentsMargins(0, 0, 0, 0)

        self.locations_widget = QWidget()
        self.locations_widget.setLayout(grid)
        self.locations_widget.hide()
        main_layout.addWidget(self.locations_widget)

        # Show locations and update button
        buttons_layout = QHBoxLayout()
        self.locations_btn = QPushButton(tr("SHORTCUTS_PATHS"))
        self.locations_btn.clicked.connect(lambda: self.locations_widget.setVisible(not self.locations_widget.isVisible()))
        buttons_layout.addWidget(self.locations_btn)
        buttons_layout.addStretch()
        self.update_shortcuts = QPushButton(tr("UPDATE_SHORTCUTS"))
        self.update_shortcuts.clicked.connect(self.update_and_apply)
        buttons_layout.addWidget(self.update_shortcuts)
        main_layout.addLayout(buttons_layout)

        self.update_list_view()

    def keyPressEvent(self, event):
        if event.key() in (Qt.Key.Key_Return, Qt.Key.Key_Enter):
            # Prevents Enter from triggering something that is not selected
            return
        super().keyPressEvent(event)

    def is_zordeer_desktop(self, file_path: Path) -> bool:
        if not file_path.exists() or file_path.suffix != ".desktop":
            return False

        if not file_path.stem.startswith("invocation-"):
            return False

        try:
            content = file_path.read_text(encoding="utf-8")
            for inv_name in self.invocations.keys():
                if f'--start-invocation "{inv_name}"' in content:
                    return True
        except Exception:
            return False

        return False

    # Checkbox Helpers
    def select_all_checkboxes(self):
        for cb in self.checkbox_widgets[self.current_view].values():
            if cb.isVisible():
                cb.setChecked(True)

    def deselect_all_checkboxes(self):
        for cb in self.checkbox_widgets[self.current_view].values():
            if cb.isVisible():
                cb.setChecked(False)

    # List view update
    def update_list_view(self):
        # Save current states
        for name, cb in self.checkbox_widgets[self.current_view].items():
            self.checkbox_states[self.current_view][name] = cb.isChecked()

        # Define current view
        self.current_view = "desktop" if self.view_combo.currentIndex() == 0 else "menu"

        # Current folder and existing desktops
        folder_path = Path(self.shortcut_manager_info.get(f"{self.current_view}_dir", ""))
        existing_desktops = {f.stem[len("invocation-"):] for f in folder_path.glob("*.desktop") if f.stem.startswith("invocation-") and self.is_zordeer_desktop(f)} if folder_path.exists() else set()

        # Clean up the old layout.
        while self.scroll_layout.count():
            item = self.scroll_layout.takeAt(0)
            if item.widget():
                item.widget().setParent(None)

        # Create/recreate checkboxes for this view.
        new_checkboxes = {}
        for inv in sorted(self.invocations.keys()):
            cb = QCheckBox(inv)
            cb.setChecked(self.checkbox_states[self.current_view].get(inv, inv in existing_desktops))
            new_checkboxes[inv] = cb
        self.checkbox_widgets[self.current_view] = new_checkboxes

        # Add only widgets filtered by the search.
        text = self.search_bar.text().lower()
        for name, cb in self.checkbox_widgets[self.current_view].items():
            if text in name.lower():
                self.scroll_layout.addWidget(cb)
                cb.show()
            else:
                cb.hide()

        self.scroll_layout.addStretch()

    # Loading and saving
    def load_invocations(self) -> dict:
        invs = {}
        if not self.CONFIG_DIR.exists():
            return invs
        for f in self.CONFIG_DIR.glob("invocation-info-*.toml"):
            try:
                content = f.read_text(encoding="utf-8")
                data = toml.loads(content)
                name = data.get("name")
                gui_path = data.get("gui_path", "")
                if name:
                    invs[name] = {"gui_path": gui_path}
            except Exception:
                continue
        return invs

    def load_shortcut_manager_info(self):
        """Load menu_dir, desktop_dir and zordeer_command from TOML settings."""
        settings = load_settings()
        shortcut_section = settings.get("shortcut", {})

        # Get values or use defaults
        menu_dir = shortcut_section.get("menu_dir") or str(
            Path.home() / ".local" / "share" / "applications" / "Zordeer-menu-shortcuts"
        )

        # Determine desktop dir from XDG user dirs
        desktop_dir = shortcut_section.get("desktop_dir")
        if not desktop_dir:
            desktop_dir = Path.home() / "Desktop"  # fallback
            user_dirs_file = Path.home() / ".config" / "user-dirs.dirs"
            if user_dirs_file.exists():
                try:
                    with open(user_dirs_file, encoding="utf-8") as f:
                        for line in f:
                            line = line.strip()
                            if line.startswith("XDG_DESKTOP_DIR"):
                                path = line.split("=", 1)[1].strip().strip('"')
                                path = path.replace("$HOME", str(Path.home()))
                                desktop_dir = Path(path)
                                break
                except Exception:
                    pass

        zordeer_command = shortcut_section.get("zordeer_command") or "zordeer"

        # Update class dictionary
        info = {
            "menu_dir": str(menu_dir),
            "desktop_dir": str(desktop_dir),
            "zordeer_command": zordeer_command
        }

        # Update TOML defaults if empty
        settings.setdefault("shortcut", {})
        settings["shortcut"]["menu_dir"] = str(menu_dir)
        settings["shortcut"]["desktop_dir"] = str(desktop_dir)
        settings["shortcut"]["zordeer_command"] = zordeer_command
        save_settings(settings)

        return info

    def save_shortcut_manager_info(self):
        """Save menu_dir, desktop_dir and zordeer_command to TOML settings."""
        settings = load_settings()
        settings.setdefault("shortcut", {})
        settings["shortcut"]["menu_dir"] = self.shortcut_manager_info.get("menu_dir", "")
        settings["shortcut"]["desktop_dir"] = self.shortcut_manager_info.get("desktop_dir", "")
        settings["shortcut"]["zordeer_command"] = self.shortcut_manager_info.get("zordeer_command", "zordeer")
        save_settings(settings)

    # Folder browsing
    def browse_folder(self, line_edit: QLineEdit):
        folder = QFileDialog.getExistingDirectory(self, tr("CHOOSE_FOLDER"), line_edit.text())
        if not folder:
            return

        old_folder = Path(line_edit.text())
        new_folder = Path(folder)

        if old_folder.exists() and old_folder != new_folder:
            # Find the Zordeer .desktop file in the old folder.
            zordeer_desktops = []
            for f in old_folder.glob("*.desktop"):
                try:
                    content = f.read_text(encoding="utf-8")
                    if self.is_zordeer_desktop(f):
                        zordeer_desktops.append(f)
                except Exception:
                    continue

            # Only ask if there is one.
            if zordeer_desktops:
                reply = QMessageBox.question(
                    self,
                    tr("APP_NAME"),
                    tr("MOVE_SHORTCUTS_CONFIRM", old=str(old_folder), new=str(new_folder)),
                    QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
                )
                if reply == QMessageBox.StandardButton.Yes:
                    new_folder.mkdir(parents=True, exist_ok=True)
                    for f in zordeer_desktops:
                        try:
                            f.rename(new_folder / f.name)
                        except Exception as e:
                            print(tr("ERROR_MOVING_SHORTCUTS", file=f, error=e))

        # Update the line_edit and shortcut manager info.
        line_edit.setText(str(new_folder))
        if line_edit == self.menu_dir_input:
            self.shortcut_manager_info["menu_dir"] = str(new_folder)
            view_key = "menu"
        elif line_edit == self.desktop_dir_input:
            self.shortcut_manager_info["desktop_dir"] = str(new_folder)
            view_key = "desktop"

        self.save_shortcut_manager_info()

        # Update the checkboxes according to the new folder.
        folder_path = new_folder
        existing_desktops = {f.stem[len("invocation-"):] for f in folder_path.glob("*.desktop") if f.stem.startswith("invocation-")} if folder_path.exists() else set()

        new_checkboxes = {}
        for inv in sorted(self.invocations.keys()):
            cb = QCheckBox(inv)
            cb.setChecked(inv in existing_desktops)
            new_checkboxes[inv] = cb

        self.checkbox_widgets[view_key] = new_checkboxes

        # Reapply the search bar filter.
        while self.scroll_layout.count():
            item = self.scroll_layout.takeAt(0)
            if item.widget():
                item.widget().setParent(None)

        text = self.search_bar.text().lower()
        for name, cb in self.checkbox_widgets[view_key].items():
            if text in name.lower():
                self.scroll_layout.addWidget(cb)
                cb.show()
            else:
                cb.hide()

        self.scroll_layout.addStretch()

    def remove_residual_desktops(self):
        menu_dir = Path(self.menu_dir_input.text())
        desktop_dir = Path(self.desktop_dir_input.text())
        valid_names = set(self.invocations.keys())  # Valid invocations

        for folder in [menu_dir, desktop_dir]:
            if not folder.exists():
                continue

            for f in folder.glob("*.desktop"):
                if not f.stem.startswith("invocation-"):
                    continue  # It's not a Zordeer desktop.

                try:
                    content = f.read_text(encoding="utf-8").splitlines()

                    # Invocation name extracted from filename
                    filename_invocation = f.stem[len("invocation-"):]

                    # Name inside Name=
                    name_line = next((line[5:] for line in content if line.startswith("Name=")), None)

                    # Name inside Exec=
                    exec_invocation = None
                    for line in content:
                        if line.startswith("Exec=") and "--start-invocation" in line:
                            start_index = line.find('--start-invocation "') + len('--start-invocation "')
                            end_index = line.find('"', start_index)
                            exec_invocation = line[start_index:end_index]
                            break

                    # If any of them are invalid, remove them.
                    if filename_invocation not in valid_names or name_line not in valid_names or exec_invocation not in valid_names:
                        f.unlink()
                except Exception as e:
                    print(tr("ERROR_REMOVING_FILE", file=f, error=e))

    # Save and create .desktop
    def update_and_apply(self):
        menu_dir = Path(self.menu_dir_input.text().strip())
        desktop_dir = Path(self.desktop_dir_input.text().strip())

        try:
            menu_dir.mkdir(parents=True, exist_ok=True)
        except PermissionError:
            QMessageBox.warning(
                self,
                tr("APP_NAME"),
                tr("ERROR_CREATING_SHORTCUTS_LOCATION", location=menu_dir)
            )
            return

        try:
            desktop_dir.mkdir(parents=True, exist_ok=True)
        except PermissionError:
            QMessageBox.warning(
                self,
                tr("APP_NAME"),
                tr("ERROR_CREATING_SHORTCUTS_LOCATION", location=desktop_dir)
            )
            return

        self.shortcut_manager_info["menu_dir"] = str(menu_dir)
        self.shortcut_manager_info["desktop_dir"] = str(desktop_dir)
        self.save_shortcut_manager_info()

        # Remove invalid .desktop files
        self.remove_residual_desktops()

        # Process each type separately.
        for name, cb in self.checkbox_widgets["desktop"].items():
            checked = cb.isChecked()
            self.handle_desktop_creation(name, checked, desktop_dir)

        for name, cb in self.checkbox_widgets["menu"].items():
            checked = cb.isChecked()
            self.handle_desktop_creation(name, checked, menu_dir)

        QMessageBox.information(self, tr("APP_NAME"), tr("SHORTCUTS_SAVED"))
        self.update_list_view()
        self.accept()

    def handle_desktop_creation(self, name: str, checked: bool, folder: Path):
        desktop_file = folder / f"invocation-{name}.desktop"
        current_zordeer = self.shortcut_manager_info.get("zordeer_command", "zordeer") + f' --start-invocation "{name}"'
        gui_path = self.invocations.get(name, {}).get("gui_path", "")

        if checked:
            content_lines = [
                "[Desktop Entry]",
                f"Name={name}",
                f"Exec={current_zordeer}",
                f"Icon={gui_path}",
                "StartupWMClass=zordeer",
                "Categories=Game;",
                "Keywords=gaming;proton;invocation;",
                "Terminal=false",
                "Type=Application"
            ]
            if desktop_file.exists():
                try:
                    old_lines = desktop_file.read_text(encoding="utf-8").splitlines()
                    new_lines = []
                    for line in old_lines:
                        if line.startswith("Exec="):
                            new_lines.append(f"Exec={current_zordeer}")
                        elif line.startswith("Name="):
                            new_lines.append(f"Name={name}")
                        elif line.startswith("Icon="):
                            new_lines.append(f"Icon={gui_path}")
                        else:
                            new_lines.append(line)
                    content_lines = new_lines
                except Exception:
                    pass
            try:
                with open(desktop_file, "w", encoding="utf-8") as f:
                    f.write("\n".join(content_lines) + "\n")
            except Exception as e:
                print(tr("ERROR_CREATING_FILE", file=desktop_file, error=e))
        else:
            if desktop_file.exists():
                try:
                    desktop_file.unlink()
                except Exception as e:
                    print(tr("ERROR_REMOVING_FILE", file=desktop_file, error=e))

class Zordeer(QMainWindow):
    def __init__(self):
        super().__init__()
        settings = load_settings()
        start_minimized = settings["window"].get("start_minimized", False)
        wanted = settings["design"].get("qt_style")

        size = settings["window"].get("windowSize")
        if size and isinstance(size, list) and len(size) == 2:
            self.resize(QSize(size[0], size[1]))
        else:
            self.resize(780, 640)

        # Only set if style exists on this system
        if wanted and wanted != "indefinite" and wanted in QStyleFactory.keys():
            QApplication.setStyle(wanted)
        self.setWindowTitle(tr("APP_NAME"))
        self.setMinimumSize(300, 160)
        self.invocation_process = None
        
        # Add the icon to the main window
        local_icons = ['zordeer.svg', 'Zordeer.svg']

        icon_set = False
        for icon_file in local_icons:
            if Path(icon_file).exists():
                self.setWindowIcon(QIcon(icon_file))
                icon_set = True
                break
        if not icon_set:
            for name in ['zordeer', 'Zordeer', 'applications-games']:
                icon = QIcon.fromTheme(name)
                if not icon.isNull():
                    self.setWindowIcon(icon)
                    break

        self.zordeer_dir = Path.home() / "AppsFiles" / "Zordeer"
        self.setup_directories()

        # Clean temporary extra TOML files
        self.cleanup_temp_toml_files()

        # Toolbar
        self.toolbar = QToolBar()
        self.toolbar.setMovable(True)
        self.toolbar.setFloatable(False)

        toolbar_position = settings["design"].get("toolbar_position", "top")

        if toolbar_position == "top":
            self.addToolBar(Qt.ToolBarArea.TopToolBarArea, self.toolbar)
        elif toolbar_position == "left":
            self.addToolBar(Qt.ToolBarArea.LeftToolBarArea, self.toolbar)
        elif toolbar_position == "right":
            self.addToolBar(Qt.ToolBarArea.RightToolBarArea, self.toolbar)
        elif toolbar_position == "bottom":
            self.addToolBar(Qt.ToolBarArea.BottomToolBarArea, self.toolbar)
        else:
            self.addToolBar(self.toolbar)  # fallback

        # MenuBar
        self.menu_bar = self.menuBar()

        # Menu INVOCATION
        self.invocation_menu = self.menu_bar.addMenu(tr("INVOCATION"))

        # Open executable folder
        self.open_exe_path_action = QAction(tr("OPEN_EXEC_PATH"), self)
        self.open_exe_path_action.triggered.connect(lambda: self.open_path(self.get_selected_invocation(), chosen_path="exe"))
        self.invocation_menu.addAction(self.open_exe_path_action)

        # Open prefix folder
        self.open_prefix_path_action = QAction(tr("OPEN_PREFIX_PATH"), self)
        self.open_prefix_path_action.triggered.connect(lambda: self.open_path(self.get_selected_invocation(), chosen_path="prefix"))
        self.invocation_menu.addAction(self.open_prefix_path_action)

        # Run in prefix
        self.run_in_prefix_action = QAction(tr("RUN_IN_PREFIX"), self)
        self.run_in_prefix_action.triggered.connect(self.run_in_prefix_dialog)
        self.invocation_menu.addAction(self.run_in_prefix_action)

        # Menu TRANSFER
        self.transfer_menu = self.menu_bar.addMenu(tr("TRANSFER"))

        self.transfer_runners_menu = QAction(tr("TRANSFER_RUNNERS"), self)
        self.transfer_runners_menu.triggered.connect(self.show_runner_transfer_dialog)
        self.transfer_menu.addAction(self.transfer_runners_menu)

        self.transfer_arts_menu = QAction(tr("TRANSFER_ARTS"), self)
        self.transfer_arts_menu.triggered.connect(self.open_transfer_arts)
        self.transfer_menu.addAction(self.transfer_arts_menu)

        # Menu EXTRAS
        self.extras_menu = self.menu_bar.addMenu(tr("EXTRAS"))

        # Add multiple invocations
        self.multiple_create_action = QAction(tr("CREATE_MULTIPLE_INVOCATIONS"), self)
        self.multiple_create_action.triggered.connect(self.open_multiple_create_dialog)
        self.extras_menu.addAction(self.multiple_create_action)

        self.multiple_remove_invocations_action = QAction(tr("REMOVE_MULTIPLE_INVOCATIONS"), self)
        self.multiple_remove_invocations_action.triggered.connect(self.open_multiple_remove_invocations_dialog)
        self.extras_menu.addAction(self.multiple_remove_invocations_action)

        self.multiple_edit_invocations_action = QAction(tr("EDIT_MULTIPLE_INVOCATIONS"), self)
        self.multiple_edit_invocations_action.triggered.connect(self.open_multiple_edit_invocations_dialog)
        self.extras_menu.addAction(self.multiple_edit_invocations_action)

        self.shortcut_manager_action = QAction(tr("MANAGE_SHORTCUTS"), self)
        self.shortcut_manager_action.triggered.connect(self.open_shortcut_manager_dialog)
        self.extras_menu.addAction(self.shortcut_manager_action)

        self.settings_action = QAction(tr("ZORDEER_SETTINGS"), self)
        self.settings_action.triggered.connect(self.open_settings)
        self.extras_menu.addAction(self.settings_action)

        self.about_action = QAction(tr("ABOUT_ZORDEER"), self)
        self.about_action.triggered.connect(self.show_about)
        self.extras_menu.addAction(self.about_action)

        # Increase the size of icons
        self.toolbar.setIconSize(QSize(32, 32))

        self.run_action = QAction(QIcon.fromTheme("media-playback-start"), tr("START_INVOCATION"), self)
        self.run_action.triggered.connect(self.start_selected_invocation)
        self.toolbar.addAction(self.run_action)

        self.stop_execution_action = QAction(QIcon.fromTheme("media-playback-stop"), tr("STOP_INVOCATION"), self)
        self.stop_execution_action.triggered.connect(self.stop_execution)
        self.toolbar.addAction(self.stop_execution_action)

        self.start_random_invocation_action = QAction(QIcon.fromTheme("roll"), tr("START_RANDOM_INVOCATION"), self)
        self.start_random_invocation_action.triggered.connect(self.start_random_invocation)
        self.toolbar.addAction(self.start_random_invocation_action)

        self.add_invocation_action = QAction(QIcon.fromTheme("list-add"), tr("CREATE_INVOCATION"), self)
        self.add_invocation_action.triggered.connect(self.add_invocation)
        self.toolbar.addAction(self.add_invocation_action)

        self.edit_invocation_action = QAction(QIcon.fromTheme("document-edit"), tr("MODIFY_INVOCATION"), self)
        self.edit_invocation_action.triggered.connect(self.edit_invocation)
        self.toolbar.addAction(self.edit_invocation_action)

        self.search_action = QAction(QIcon.fromTheme("search"), tr("SEARCH"), self)
        self.search_action.triggered.connect(self.toggle_search_bar)
        self.toolbar.addAction(self.search_action)

        self.central_widget = QWidget()
        self.setCentralWidget(self.central_widget)
        self.main_layout = QVBoxLayout()
        self.central_widget.setLayout(self.main_layout)

        self.invocation_list_widget = QListWidget()
        self.invocation_list_widget.setSelectionMode(QAbstractItemView.SelectionMode.SingleSelection)

        self._last_selected_items = []
        self.invocation_list_widget.itemSelectionChanged.connect(self.ensure_selection)

        layout_mode = settings["design"].get("layout_mode", "classic")

        icon_width_classic = settings["design"].get("icon_width_classic", 420)
        icon_width_grid = settings["design"].get("icon_width_grid", 300)

        if layout_mode in ("list", "list-bare"):
            self.invocation_list_widget.setViewMode(QListWidget.ViewMode.ListMode)
            self.invocation_list_widget.setMovement(QListWidget.Movement.Static)
            self.invocation_list_widget.setResizeMode(QListWidget.ResizeMode.Adjust)
        elif layout_mode in ("grid", "grid-bare"):
            self.invocation_list_widget.setViewMode(QListWidget.ViewMode.IconMode)
            self.invocation_list_widget.setFlow(QListView.Flow.LeftToRight)
            self.invocation_list_widget.setResizeMode(QListWidget.ResizeMode.Adjust)
            icon_width = icon_width_grid
            icon_height = int(icon_width * (620 / 1920))
            grid_width = icon_width + 5
            grid_height = icon_height + 40
            self.invocation_list_widget.setIconSize(QSize(icon_width, icon_height))
            self.invocation_list_widget.setGridSize(QSize(grid_width, grid_height))
            self.invocation_list_widget.setMovement(QListWidget.Movement.Static)
        elif layout_mode in ("classic", "classic-bare"):
            self.invocation_list_widget.setViewMode(QListWidget.ViewMode.ListMode)
            self.invocation_list_widget.setMovement(QListWidget.Movement.Static)
            self.invocation_list_widget.setResizeMode(QListWidget.ResizeMode.Adjust)
            icon_width = icon_width_classic
            icon_height = int(icon_width * (620 / 1920))
            self.invocation_list_widget.setIconSize(QSize(icon_width, icon_height))

        self.main_layout.addWidget(self.invocation_list_widget)

        # Search bar (initially hidden)
        self.search_bar = QLineEdit()
        self.search_bar.setPlaceholderText(tr("SEARCH"))
        self.search_bar.textChanged.connect(self.filter_invocations)
        self.search_bar.setVisible(False)

        self.main_layout.insertWidget(0, self.search_bar)

        self.load_invocations()

        # Visibility based on Zordeer settings
        visible = settings["design"].get("search_bar_visible", False)
        self.search_bar.setVisible(visible)

        # ===== Context menu =====
        self.global_context_menu = QMenu(self)
        self.global_context_menu.clear()
        # Menu of toolbar
        self.global_context_menu.addAction(self.run_action)
        self.global_context_menu.addAction(self.stop_execution_action)
        self.global_context_menu.addAction(self.start_random_invocation_action)
        self.global_context_menu.addAction(self.add_invocation_action)
        self.global_context_menu.addAction(self.edit_invocation_action)
        self.global_context_menu.addAction(self.search_action)
        self.global_context_menu.addSeparator()
        # Submenu INVOCATION
        self.invocation_submenu_context = QMenu(tr("INVOCATION"), self.global_context_menu)
        self.invocation_submenu_context.addAction(self.open_exe_path_action)
        self.invocation_submenu_context.addAction(self.open_prefix_path_action)
        self.invocation_submenu_context.addAction(self.run_in_prefix_action)
        self.global_context_menu.addMenu(self.invocation_submenu_context)
        # Submenu TRANSFER
        self.transfer_submenu_context = QMenu(tr("TRANSFER"), self.global_context_menu)
        self.transfer_submenu_context.addAction(self.transfer_runners_menu)
        self.transfer_submenu_context.addAction(self.transfer_arts_menu)
        self.global_context_menu.addMenu(self.transfer_submenu_context)
        # Submenu EXTRAS
        self.extras_submenu_context = QMenu(tr("EXTRAS"), self.global_context_menu)
        self.extras_submenu_context.addAction(self.multiple_create_action)
        self.extras_submenu_context.addAction(self.multiple_remove_invocations_action)
        self.extras_submenu_context.addAction(self.multiple_edit_invocations_action)
        self.extras_submenu_context.addAction(self.shortcut_manager_action)
        self.extras_submenu_context.addAction(self.settings_action)
        self.extras_submenu_context.addAction(self.about_action)
        self.global_context_menu.addMenu(self.extras_submenu_context)

        # ===== System Tray Icon =====
        self.tray_icon = QSystemTrayIcon(self)
        self.tray_icon.setIcon(self.windowIcon())
        self.tray_icon.setToolTip(self.windowTitle())
        self.windowTitleChanged.connect(self.tray_icon.setToolTip)

        tray_menu = QMenu()

        # Run random invocation
        random_action = QAction(tr("START_RANDOM_INVOCATION"), tray_menu)
        random_action.setIcon(QIcon.fromTheme("roll"))
        random_action.triggered.connect(self.start_random_invocation)
        tray_menu.addAction(random_action)

        # Stop invocation
        tray_menu.addAction(self.stop_execution_action)

        # Show/Hide Window
        self.restore_action = QAction(tr("ZORDEER_TRAY_TOGGLE"), self)
        self.restore_action.setIcon(QIcon.fromTheme("visibility"))
        self.restore_action.triggered.connect(self.toggle_window)
        tray_menu.addAction(self.restore_action)

        # Quit
        quit_action = QAction(tr("CLOSE_ZORDEER"), self)
        quit_action.setIcon(QIcon.fromTheme("dialog-close"))
        quit_action.triggered.connect(self.close)
        tray_menu.addAction(quit_action)

        self.tray_icon.setContextMenu(tray_menu)
        self.tray_icon.show()

        # Bare mode (Without toolbar and menubar, using context menu)
        is_bare = layout_mode in ("classic-bare", "grid-bare", "list-bare")
        self.menu_bar.setVisible(not is_bare)
        self.toolbar.setVisible(not is_bare)
        if is_bare:
            self.central_widget.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
            self.central_widget.customContextMenuRequested.connect(self.show_global_context_menu)
        else:
            self.central_widget.setContextMenuPolicy(Qt.ContextMenuPolicy.NoContextMenu)
            try:
                self.central_widget.customContextMenuRequested.disconnect(self.show_global_context_menu)
            except Exception:
                pass

        start_minimized = settings["window"].get("start_minimized", False)
        if start_minimized:
            self.hide()
            self.tray_icon.showMessage(
                tr("APP_NAME"),
                tr("RUNNING_IN_BACKGROUND"), QSystemTrayIcon.MessageIcon.NoIcon, 3000)
        elif settings["window"].get("isFullScreen", False):
            self.showFullScreen()
        elif settings["window"].get("isMaximized", False):
            self.showMaximized()
        else:
            self.show()

        atexit.register(self.kill_invocation_process_on_exit)
        self.transfer_successful = False

    def show_global_context_menu(self, pos):
        layout_mode = load_settings()["design"].get("layout_mode", "classic")
        if layout_mode in ("classic-bare", "grid-bare", "list-bare"):
            global_pos = self.central_widget.mapToGlobal(pos)
            self.global_context_menu.popup(global_pos)

    def toggle_search_bar(self):
        visible = not self.search_bar.isVisible()
        self.search_bar.setVisible(visible)
        if visible:
            self.search_bar.setFocus()
            self.search_bar.selectAll()
        else:
            self.search_bar.clear()
            self.filter_invocations("")

    def ensure_selection(self):
        selected_items = self.invocation_list_widget.selectedItems()
        if not selected_items and self._last_selected_items:
            for item in self._last_selected_items:
                item.setSelected(True)
        else:
            self._last_selected_items = selected_items.copy()

    def start_random_invocation(self):
        if self.invocation_list_widget.count() == 0:
            QMessageBox.information(
                self, tr("APP_NAME"), tr("NO_INVOCATIONS_FOUND"))
            return
        idx = random.randint(0, self.invocation_list_widget.count() - 1)
        invocation_name = self.invocation_list_widget.item(idx).text()
        self.start_invocation(invocation_name)

    def toggle_window(self):
        if self.isVisible():
            self.hide()
        else:
            self.show()
            self.raise_()
            self.activateWindow()

    def closeEvent(self, event):
        settings = load_settings()
        settings["design"]["search_bar_visible"] = self.search_bar.isVisible()
        area = self.toolBarArea(self.toolbar)
        if area == Qt.ToolBarArea.TopToolBarArea:
            settings["design"]["toolbar_position"] = "top"
        elif area == Qt.ToolBarArea.LeftToolBarArea:
            settings["design"]["toolbar_position"] = "left"
        elif area == Qt.ToolBarArea.RightToolBarArea:
            settings["design"]["toolbar_position"] = "right"
        elif area == Qt.ToolBarArea.BottomToolBarArea:
            settings["design"]["toolbar_position"] = "bottom"
        settings["window"]["windowSize"] = [self.size().width(), self.size().height()]
        settings["window"]["isMaximized"] = self.isMaximized()
        settings["window"]["isFullScreen"] = self.isFullScreen()
        settings["window"]["start_minimized"] = not self.isVisible()
        # Checks if the title contains the string "INVOCATION_STARTED"
        if self.windowTitle().startswith(tr("INVOCATION_STARTED", invocation_name="").split("{invocation_name}")[0].strip()):
            reply = QMessageBox.question(
                self,
                tr("APP_NAME"),
                tr("CONFIRM_CLOSE_MESSAGE"),
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )
            if reply == QMessageBox.StandardButton.Yes:
                self.stop_execution()
                save_settings(settings)
                QApplication.quit()
            else:
                event.ignore()
        else:
            save_settings(settings)
            QApplication.quit()

    def filter_invocations(self, text):
        text = text.lower()
        first_visible_item = None
        current_item = self.invocation_list_widget.currentItem()

        for i in range(self.invocation_list_widget.count()):
            item = self.invocation_list_widget.item(i)
            visible = text in item.text().lower()
            item.setHidden(not visible)

            if visible and first_visible_item is None:
                first_visible_item = item

        # If the currently selected item is no longer visible, select the first visible one
        if current_item is None or current_item.isHidden():
            if first_visible_item:
                self.invocation_list_widget.setCurrentItem(first_visible_item)

        # Remove context menus
        self.setContextMenuPolicy(Qt.ContextMenuPolicy.NoContextMenu)

    def stop_execution(self):
        self.setWindowTitle(tr("APP_NAME"))

        # Try to kill by the real executable
        if hasattr(self, "last_executable") and self.last_executable:
            exe_name = Path(self.last_executable).name.lower()
            found = False
            for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
                try:
                    cmdline = " ".join(proc.info['cmdline'] or []).lower()
                    if exe_name in cmdline:
                        print(tr("STOP_KILL_PROCESS", pid=proc.pid, exe=exe_name))
                        try:
                            proc.kill()
                            print(tr("STOP_PROCESS_SUCCESS", pid=proc.pid))
                        except Exception as e:
                            print(tr("STOP_KILL_ERROR", pid=proc.pid, error=e))
                        found = True
                except (psutil.NoSuchProcess, psutil.AccessDenied) as e:
                    print(tr("STOP_ACCESS_ERROR", error=e))
                    continue
            if found:
                print(tr("STOP_INVOCATION_SUCCESS"))
            else:
                print(tr("STOP_NO_PROCESS_FOUND"))
        else:
            print(tr("STOP_NO_INVOCATION_ACTIVE"))

        # Clear internal references
        if hasattr(self, "invocation_process"):
            self.invocation_process = None
        if hasattr(self, "last_executable"):
            self.last_executable = None

        # Unmount/eject mounted ISO, if present
        mounted_iso_info = Path.home() / "AppsFiles" / "Zordeer" / "config" / "mounted_iso_info.toml"

        if mounted_iso_info.exists():
            try:
                with mounted_iso_info.open("r", encoding="utf-8") as f:
                    iso_info = toml.load(f)

                loop_device = iso_info.get("loop_device")
                if loop_device:
                    # Unmount
                    result_unmount = subprocess.run(
                        ["udisksctl", "unmount", "-b", loop_device],
                        capture_output=True, text=True
                    )
                    if result_unmount.returncode != 0:
                        print(tr("ISO_UNMOUNT_FAILED", device=loop_device, error=result_unmount.stderr.strip()))

                    # Delete loop device
                    result_delete = subprocess.run(
                        ["udisksctl", "loop-delete", "-b", loop_device],
                        capture_output=True, text=True
                    )
                    if result_delete.returncode != 0:
                        print(tr("ISO_LOOP_DELETE_FAILED", device=loop_device, error=result_delete.stderr.strip()))
                    else:
                        print(tr("ISO_UNMOUNTED", device=loop_device))

            except Exception as e:
                print(tr("ISO_UNMOUNT_EXCEPTION", error=str(e)))

            finally:
                # Remove info file no matter what
                mounted_iso_info.unlink(missing_ok=True)

    def kill_invocation_process_on_exit(self):
        if self.invocation_process and self.invocation_process.poll() is None:
            print(tr("ZORDEER_CLOSED"))
            self.stop_execution()

    def setup_directories(self):
        """Creates the main Zordeer directory structure using pathlib with real folder names."""
        base = Path(self.zordeer_dir)
        subdirs = [
            base / "invocation",
            base / "runner",
            base / "config",
            base / "art"
        ]

        for subdir in subdirs:
            subdir.mkdir(parents=True, exist_ok=True)

    def load_invocations(self):
        """Loads invocation data from TOML files and populates the list, preserving the selection by TOML file."""

        # Save scroll position
        scroll_pos = self.invocation_list_widget.verticalScrollBar().value()

        # Save which file was selected
        selected_invocation_file = None
        current_item = self.invocation_list_widget.currentItem()
        if current_item:
            selected_invocation_file = current_item.data(Qt.ItemDataRole.UserRole)

        self.invocation_list_widget.clear()

        config_dir = Path(self.zordeer_dir) / "config"
        if not config_dir.exists():
            return

        invocations = []
        for file_path in config_dir.glob("invocation-info-*.toml"):
            try:
                with file_path.open('r', encoding='utf-8') as f:
                    invocation_data = toml.load(f)
                    invocations.append((invocation_data, file_path))
            except (IOError, toml.TomlDecodeError) as e:
                print(tr("ERROR_LOADING_FILE", file=file_path, error=e))

        invocations.sort(key=lambda g: g[0].get('name', '').casefold())

        restored_selection_item = None
        for invocation_data, file_path in invocations:
            item = self.add_invocation_to_list(invocation_data)
            item.setData(Qt.ItemDataRole.UserRole, file_path)  # Associate the TOML with the item

            if selected_invocation_file and selected_invocation_file == file_path:
                restored_selection_item = item

        # Restores the selection
        if restored_selection_item:
            self.invocation_list_widget.setCurrentItem(restored_selection_item)
        else:
            if self.invocation_list_widget.count() > 0:
                self.invocation_list_widget.setCurrentRow(0)

        # Reapply the search filter
        if hasattr(self, "search_bar"):
            current_text = self.search_bar.text()
            self.filter_invocations(current_text)

        # Restore scroll position
        self.invocation_list_widget.verticalScrollBar().setValue(scroll_pos)

    def add_invocation(self):
        dialog = AddInvocationDialog(self)
        dialog.invocation_saved.connect(self.load_invocations)
        dialog.exec()

    def open_multiple_create_dialog(self):
        dialog = MultipleCreateInvocationsDialog(self)
        dialog.invocations_saved.connect(self.load_invocations)  # Update list
        dialog.exec()

    def open_multiple_remove_invocations_dialog(self):
        dialog = MultipleRemoveInvocationDialog(self)
        dialog.exec()

    def open_multiple_edit_invocations_dialog(self):
        dialog = MultipleEditInvocationDialog(self)
        dialog.exec()

    def open_shortcut_manager_dialog(self):
        dialog = ShortcutManager(self)
        dialog.exec()

    def edit_invocation(self):
        invocation_name = self.get_selected_invocation()
        if not invocation_name:
            QMessageBox.warning(self, tr("APP_NAME"), tr("NO_INVOCATION_SELECTED_ERROR"))
            return

        config_dir = Path(self.zordeer_dir) / "config"
        safe_invocation_name = invocation_name.replace(" ", "_").lower()
        invocation_file_path = config_dir / f"invocation-info-{safe_invocation_name}.toml"

        try:
            with invocation_file_path.open('r', encoding='utf-8') as f:
                invocation_data = toml.load(f)
        except (IOError, toml.TomlDecodeError):
            QMessageBox.critical(self, tr("APP_NAME"), tr("INVOCATION_INFO_ERROR", name=invocation_name))
            return

        dialog = AddInvocationDialog(self, invocation_data)
        dialog.invocation_saved.connect(self.load_invocations)
        dialog.exec()

    def start_invocation(self, item_or_name):
        if self.windowTitle().startswith(tr("INVOCATION_STARTED", invocation_name="").split("{invocation_name}")[0].strip()):
            reply = QMessageBox.question(
                self,
                tr("APP_NAME"),
                tr("INVOCATION_ALREADY_ACTIVE"),
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )

            if reply == QMessageBox.StandardButton.Yes:
                self.stop_execution()
            else:
                return

        if not item_or_name:
            QMessageBox.warning(self, tr("APP_NAME"), tr("NO_INVOCATION_SELECTED_ERROR"))
            return

        # Accepts QListWidgetItem or string
        if isinstance(item_or_name, QListWidgetItem):
            invocation_name = item_or_name.text()
        else:
            invocation_name = str(item_or_name)

        print(tr("STARTING_INVOCATION", name=invocation_name))

        config_dir = Path(self.zordeer_dir) / "config"
        safe_invocation_name = invocation_name.replace(" ", "_").lower()
        invocation_file_path = config_dir / f"invocation-info-{safe_invocation_name}.toml"

        try:
            with invocation_file_path.open('r', encoding='utf-8') as f:
                invocation_data = toml.load(f)
            print(tr("INVOCATION_INFO_LOADED", name=invocation_name))

            runner_base_path = Path(self.zordeer_dir) / "runner" / invocation_data['runner']
            exec_path_full = Path(invocation_data['exec_path'])
            prefix_path = Path(invocation_data['prefix_path'])

            if not exec_path_full.exists():
                QMessageBox.critical(
                    self,
                    tr("APP_NAME"),
                    tr("EXEC_PATH_NOT_FOUND", path=str(exec_path_full))
                )
                return

            if not prefix_path.exists():
                QMessageBox.critical(
                    self,
                    tr("APP_NAME"),
                    tr("PREFIX_PATH_NOT_FOUND", path=str(prefix_path))
                )
                return

            if exec_path_full.suffix.lower() not in (".exe", ".msi", ".iso"):
                if str(exec_path_full) == ".":
                    reply = QMessageBox.question(
                        self,
                        tr("APP_NAME"),
                        tr("NO_EXEC_PATH"),
                        QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
                    )
                else:
                    reply = QMessageBox.question(
                        self,
                        tr("APP_NAME"),
                        tr("EXEC_PATH_INVALID_CONFIRM", path=str(exec_path_full)),
                        QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
                    )
                if reply == QMessageBox.StandardButton.No:
                    return

            # exec_path_full is the original path of the TOML (can be .iso)
            iso_path = exec_path_full

            if iso_path.suffix.lower() == ".iso":
                mount_point = None
                loop_device = None

                # Check if the ISO is already mounted
                for line in open("/proc/mounts"):
                    dev, mnt = line.split()[:2]
                    if dev.startswith("/dev/loop") and iso_path.as_posix() in subprocess.getoutput(f"losetup {dev}"):
                        mount_point = Path(mnt)
                        loop_device = dev
                        print(tr("ISO_ALREADY_MOUNTED", mount=str(mount_point)))
                        break

                # If not mounted, create loop device and mount it
                if not mount_point:
                    # Create loop device
                    result = subprocess.run(
                        ["udisksctl", "loop-setup", "-f", str(iso_path)],
                        capture_output=True, text=True
                    )
                    if result.returncode != 0:
                        QMessageBox.critical(None, tr("APP_NAME"), tr("LOOP_DEVICE_CREATION_FAILED", error=result.stderr))
                        return

                    match = re.search(r'/dev/loop\d+', result.stdout)
                    if not match:
                        QMessageBox.critical(None, tr("APP_NAME"), tr("LOOP_DEVICE_NOT_FOUND"))
                        return
                    loop_device = match.group(0)

                    # Mount loop device
                    result_mount = subprocess.run(
                        ["udisksctl", "mount", "-b", loop_device],
                        capture_output=True, text=True
                    )
                    if result_mount.returncode != 0:
                        QMessageBox.critical(None, tr("APP_NAME"), tr("ISO_MOUNT_FAILED", error=result_mount.stderr))
                        return

                    # Get mount point
                    match = re.search(r'at (/.+)', result_mount.stdout)
                    mount_point = Path(match.group(1)) if match else None
                    if not mount_point or not mount_point.exists():
                        QMessageBox.critical(None, tr("APP_NAME"), tr("ISO_MOUNT_POINT_NOT_FOUND"))
                        return

                # Look for the .exe inside the ISO
                exe_files = []
                for _ in range(20):
                    exe_files = list(mount_point.glob("setup.exe")) or list(mount_point.rglob("*.exe"))
                    if exe_files:
                        break
                    time.sleep(0.3)
                if not exe_files:
                    QMessageBox.critical(None, tr("APP_NAME"), tr("ISO_NO_EXE_FOUND"))
                    return

                exec_path_full = exe_files[0]
                print(tr("ISO_MOUNTED_EXE_FOUND", iso=str(iso_path), exe=str(exec_path_full)))

                # Save mounted ISO info
                mounted_iso_info = Path.home() / "AppsFiles" / "Zordeer" / "config" / "mounted_iso_info.toml"
                with mounted_iso_info.open("w", encoding="utf-8") as f:
                    toml.dump({
                        "iso_path": str(iso_path),
                        "loop_device": loop_device,
                        "mount_point": str(mount_point)
                    }, f)

            runner_name = (invocation_data.get("runner") or load_settings()["other"].get("default_runner", "")).strip()

            # Handle undefined or empty runner
            if not runner_name or runner_name.lower() == "indefinite":
                QMessageBox.warning(self, tr("APP_NAME"), tr("DEFAULT_RUNNER_INDEFINITE"))
                return

            # Check if UMU launcher is enabled
            use_umu = invocation_data.get('use_umu', False)
            umu_version = load_settings()["other"].get("umu_version", "").strip()

            if use_umu and runner_name.lower() != "wine":
                # Validate UMU version
                if not umu_version or umu_version.lower() == "indefinite":
                    QMessageBox.warning(self, tr("APP_NAME"), tr("DEFAULT_UMU_INDEFINITE"))
                    return
                
                # Get UMU path
                umu_path = Path(self.zordeer_dir) / "umu-launcher" / umu_version / "umu-run"
                if not umu_path.exists():
                    QMessageBox.critical(
                        self,
                        tr("APP_NAME"),
                        tr("UMU_NOT_FOUND", path=str(umu_path.parent))
                    )
                    return

                # UMU launcher command structure
                command = [str(umu_path), str(exec_path_full)]
                
            else:
                # Check if it's Wine.
                if runner_name.lower() == "wine":
                    wine_path = shutil.which("wine")
                    if not wine_path:
                        QMessageBox.critical(self, tr("APP_NAME"), tr("WINE_NOT_FOUND"))
                        return
                    command = [wine_path, str(exec_path_full)]
                else:
                    # Try using a custom runner
                    proton_script = Path(self.zordeer_dir) / "runner" / runner_name / "proton"
                    if not proton_script.exists():
                        QMessageBox.critical(
                            self,
                            tr("APP_NAME"),
                            tr("ERROR_RUNNER", path=str(proton_script.parent))
                        )
                        return

                    command = [str(proton_script), "run", str(exec_path_full)]

            # Gamemode
            use_gamemode = invocation_data.get('use_gamemode', True)
            if use_gamemode:
                gamemoderun_path = shutil.which('gamemoderun')
                if gamemoderun_path:
                    command.insert(0, gamemoderun_path)

            # Invocation arguments
            invocation_args_str = invocation_data.get('invocation_args', '').strip()
            if invocation_args_str:
                command.extend(invocation_args_str.split())

            # Environment variables
            env = os.environ.copy()
            env['WINEPREFIX'] = str(prefix_path)

            if use_umu and runner_name.lower() != "wine":
                # Set XDG_DATA_HOME to redirect UMU data to Zordeer directory
                umu_launcher_files_dir = Path(self.zordeer_dir) / "umu-launcher" / "umu-files"
                umu_launcher_files_dir.mkdir(parents=True, exist_ok=True)
                env['XDG_DATA_HOME'] = str(umu_launcher_files_dir)

                if runner_name.lower() != "wine":
                    env['PROTONPATH'] = str(Path(self.zordeer_dir) / "runner" / runner_name)
            else:
                # Set Steam environment variables only for Proton
                if runner_name.lower() != "wine":
                    env['STEAM_COMPAT_DATA_PATH'] = str(prefix_path)
                    env['STEAM_COMPAT_CLIENT_INSTALL_PATH'] = str(Path.home() / "AppsFiles" / "Zordeer" / ".steam" / "steam")
                    env['STEAM_EXTRA_COMPAT_TOOLS_PATHS'] = str(runner_base_path)

            # Symlink "pfx" > prefix_path (only for non-UMU)
            if not use_umu:
                pfx_symlink = prefix_path / "pfx"
                try:
                    if not pfx_symlink.exists():
                        if pfx_symlink.is_symlink():
                            pfx_symlink.unlink()
                        pfx_symlink.symlink_to(prefix_path)
                        print(tr("SYMLINK_CREATED", symlink=str(pfx_symlink), prefix=str(prefix_path)))
                except Exception as e:
                    print(tr("SYMLINK_ERROR", error=e))

            # Language configuration
            language = invocation_data.get('language', '').strip()
            locale_code = ""
            env_prefix = ["env"]
            if language:
                try:
                    if "(" in language and ")" in language:
                        locale_code = language.split("(")[1].replace(")", "").strip()
                    else:
                        locale_code = language
                    env_prefix.append(f"LC_ALL={locale_code}")
                    env_prefix.append(f"LANG={locale_code}")
                    env_prefix.append(f"LANGUAGE={locale_code}")
                except Exception as e:
                    print(tr("LANGUAGE_SET_ERROR", error=e))

            # Map to MS language code
            locale_to_ms_code = {
                "en_US.UTF-8": "ENU",
                "pt_BR.UTF-8": "PTB",
                "pt_PT.UTF-8": "PTG",
                "es_ES.UTF-8": "ESN",
                "es_MX.UTF-8": "ESM",
                "fr_FR.UTF-8": "FRA",
                "de_DE.UTF-8": "DEU",
                "it_IT.UTF-8": "ITA",
                "ru_RU.UTF-8": "RUS",
                "uk_UA.UTF-8": "UKR",
                "pl_PL.UTF-8": "PLK",
                "cs_CZ.UTF-8": "CSY",
                "sk_SK.UTF-8": "SKY",
                "hu_HU.UTF-8": "HUN",
                "ro_RO.UTF-8": "ROM",
                "nl_NL.UTF-8": "NLD",
                "sv_SE.UTF-8": "SVE",
                "nb_NO.UTF-8": "NOR",
                "da_DK.UTF-8": "DAN",
                "fi_FI.UTF-8": "FIN",
                "el_GR.UTF-8": "ELL",
                "bg_BG.UTF-8": "BGR",
                "ja_JP.UTF-8": "JPN",
                "ko_KR.UTF-8": "KOR",
                "zh_CN.UTF-8": "CHS",
                "zh_TW.UTF-8": "CHT",
                "ar_SA.UTF-8": "ARA",
                "fa_IR.UTF-8": "FAR",
                "tr_TR.UTF-8": "TRK",
                "hi_IN.UTF-8": "HIN",
                "th_TH.UTF-8": "THA",
                "he_IL.UTF-8": "HEB",
            }
            if locale_code and invocation_data.get('use_ms_language_code', False):
                ms_lang_code = locale_to_ms_code.get(locale_code)
                if ms_lang_code:
                    command.append(f"-language={ms_lang_code}")

            # FPS HUD
            show_fps = invocation_data.get('show_fps', False)
            fps_hud_type = invocation_data.get('fps_hud_type', '')
            if show_fps:
                if fps_hud_type == "FPS_DXVK_HUD":
                    env_prefix.append("DXVK_HUD=fps,gpuload,frametimes")
                elif fps_hud_type == "FPS_GALLIUM_HUD":
                    env_prefix.append("GALLIUM_HUD=fps+cpu,frametime")
                elif fps_hud_type == "FPS_MANGOHUD":
                    env_prefix.append("MANGOHUD=1")

            # OpenGL (wined3d)
            if invocation_data.get('force_opengl', False):
                env_prefix.append("PROTON_USE_WINED3D=1")

            # Extra environment variables
            env_vars_str = invocation_data.get('env_vars', '').strip()
            if env_vars_str:
                for item in env_vars_str.split():
                    if '=' in item:
                        env_prefix.append(item)

            # Prefix in the final command
            command = env_prefix + command

            # Simple debug version showing only UMU-related and important env vars
            debug_vars = []
            if use_umu and runner_name.lower() != "wine":
                debug_vars.append(f"WINEPREFIX='{env['WINEPREFIX']}'")
                if 'PROTONPATH' in env:
                    debug_vars.append(f"PROTONPATH='{env['PROTONPATH']}'")
                if 'XDG_DATA_HOME' in env:
                    debug_vars.append(f"XDG_DATA_HOME='{env['XDG_DATA_HOME']}'")
            else:
                debug_vars.append(f"WINEPREFIX='{env['WINEPREFIX']}'")
                # Only show Steam variables if they exist and runner is not Wine
                if runner_name.lower() != "wine":
                    if 'STEAM_COMPAT_DATA_PATH' in env:
                        debug_vars.append(f"STEAM_COMPAT_DATA_PATH='{env['STEAM_COMPAT_DATA_PATH']}'")
                    if 'STEAM_COMPAT_CLIENT_INSTALL_PATH' in env:
                        debug_vars.append(f"STEAM_COMPAT_CLIENT_INSTALL_PATH='{env['STEAM_COMPAT_CLIENT_INSTALL_PATH']}'")
                    if 'STEAM_EXTRA_COMPAT_TOOLS_PATHS' in env:
                        debug_vars.append(f"STEAM_EXTRA_COMPAT_TOOLS_PATHS='{env['STEAM_EXTRA_COMPAT_TOOLS_PATHS']}'")
            
            # Remove "env" from the beginning of command since we're showing env vars separately
            if command[0] == "env":
                command_without_env = command[1:]
            else:
                command_without_env = command
            
            debug_command = " ".join(debug_vars + command_without_env)
            print(tr("RUNNING_COMMAND", command=debug_command))

            self.invocation_process = subprocess.Popen(
                command,
                env=env,
                cwd=str(exec_path_full.parent),
                stdout=sys.stdout,
                stderr=sys.stderr
            )
            self.last_wineprefix = env.get("WINEPREFIX")
            self.last_executable = str(exec_path_full)
            self.setWindowTitle(tr("INVOCATION_STARTED", invocation_name=invocation_name))

            # Give Proton some time to spawn child processes
            time.sleep(3)

            # Capture real process
            try:
                parent = psutil.Process(self.invocation_process.pid)
                children = parent.children(recursive=True)
                if children:
                    self.real_invocation_process = children[-1]
                    print(tr("DEBUG_REAL_INVOCATION_INITIATED", pid=self.real_invocation_process.pid))
                else:
                    self.real_invocation_process = None
            except psutil.NoSuchProcess:
                self.real_invocation_process = None

        except (IOError, toml.TomlDecodeError):
            QMessageBox.critical(self, tr("APP_NAME"), tr("INVOCATION_INFO_ERROR", name=invocation_name))
        except Exception as e:
            QMessageBox.critical(self, tr("APP_NAME"), tr("INVOCATION_START_ERROR", error=str(e)))

    def start_selected_invocation(self):
        invocation_name = self.get_selected_invocation()
        self.start_invocation(invocation_name)

    def get_selected_invocation(self):
        item = self.invocation_list_widget.currentItem()
        if item:
            return item.text()
        return None

    def add_invocation_to_list(self, invocation_data):
        invocation_name = invocation_data['name']

        item = QListWidgetItem()
        item.setText(invocation_name)

        # Bold
        font = item.font()
        font.setBold(True)
        item.setFont(font)

        # Decide which image to use
        art_path_to_use = None
        layout_mode = settings["design"].get("layout_mode", "classic")

        art_path_to_use = invocation_data.get("art_path")

        # Art as an icon
        icon = None
        if art_path_to_use:
            art_file = Path(art_path_to_use)
            if art_file.exists():
                pixmap = QPixmap(str(art_file))
                if not pixmap.isNull():
                    pixmap = pixmap.scaled(
                        self.invocation_list_widget.iconSize(),
                        Qt.AspectRatioMode.KeepAspectRatio,
                        Qt.TransformationMode.SmoothTransformation
                    )
                    icon = QIcon()
                    icon.addPixmap(pixmap, QIcon.Mode.Normal, QIcon.State.Off)
                    icon.addPixmap(pixmap, QIcon.Mode.Selected, QIcon.State.Off)
                    icon.addPixmap(pixmap, QIcon.Mode.Active, QIcon.State.Off)
                    icon.addPixmap(pixmap, QIcon.Mode.Disabled, QIcon.State.Off)

        if icon is None:
            palette = QApplication.palette()
            pixmap = QPixmap(self.invocation_list_widget.iconSize())
            pixmap.fill(palette.color(QPalette.ColorRole.Base))
            painter = QPainter(pixmap)
            painter.setPen(palette.color(QPalette.ColorRole.Text))
            painter.setFont(font)
            painter.drawText(pixmap.rect(), Qt.AlignmentFlag.AlignCenter, " /\\_/\\\n >^.^<")
            painter.end()
            icon = QIcon(pixmap)

        if layout_mode not in ["list", "list-bare"] and icon is not None:
            item.setIcon(icon)

        self.invocation_list_widget.addItem(item)
        return item

    def show_runner_transfer_dialog(self):
        """Opens the runner transfer tab (Runner Transfer Dialog)."""
        dialog = RunnerTransferDialog(self)
        dialog.exec()

    def open_transfer_arts(self):
        dialog = SteamGridDBApp(self)
        dialog.parent_ref = self
        dialog.exec()

    def run_in_prefix_dialog(self):
        invocation_name = self.get_selected_invocation()  # Use self directly
        if not invocation_name:
            QMessageBox.warning(self, tr("APP_NAME"), tr("NO_INVOCATION_SELECTED_ERROR"))
            return

        dlg = RunInPrefix(self, invocation_name)
        dlg.exec()

    def run_in_prefix(self, base_invocation_name):
        exe_path, _ = QFileDialog.getOpenFileName(
            self,
            tr("SELECT_EXE"),
            str(Path.home()),
            tr("EXECUTABLE_FILE_FILTER")
        )
        if not exe_path:
            return  # User canceled

        config_dir = Path(self.zordeer_dir) / "config"
        safe_invocation_name = base_invocation_name.replace(" ", "_").lower()
        base_file = config_dir / f"invocation-info-{safe_invocation_name}.toml"

        if not base_file.exists():
            QMessageBox.warning(self, tr("APP_NAME"), tr("INVOCATION_INFO_NOT_FOUND"))
            return

        with base_file.open("r", encoding="utf-8") as f:
            base_info = toml.load(f)

        # Create temporary TOML
        temp_id = str(uuid.uuid4())[:8]
        temp_name = f"TEMP_EXEC_{temp_id}"
        safe_temp_name = temp_name.lower()
        temp_file = config_dir / f"invocation-info-{safe_temp_name}.toml"

        temp_info = base_info.copy()
        temp_info["name"] = temp_name
        temp_info["exec_path"] = exe_path  # Update the executable

        with temp_file.open("w", encoding="utf-8") as f:
            toml.dump(temp_info, f)

        # Start as normal invocation
        self.start_invocation(temp_name)

        # Cleanup function
        def cleanup():
            if temp_file.exists():
                temp_file.unlink()
                print(tr("RUN_IN_PREFIX_TEMP_FILE_REMOVED", temp_file=str(temp_file)))

        # Remove temp TOML after process ends
        if self.invocation_process:
            threading.Thread(target=lambda: (self.invocation_process.wait(), cleanup()), daemon=True).start()
        else:
            cleanup()

    def run_in_prefix_for_selected_invocation(self):
        invocation_name = self.get_selected_invocation()
        self.run_in_prefix(invocation_name)
    
    def cleanup_temp_toml_files(self):
        config_dir = Path(self.zordeer_dir) / "config"
        removed = 0
        if config_dir.exists():
            for file in config_dir.iterdir():
                if file.name.endswith("_ztffrip.toml"):
                    try:
                        file.unlink()
                        removed += 1
                    except Exception as e:
                        print(tr("ERROR_REMOVING_FILE", file=file.name, error=e))
        if removed > 0:
            print(tr("TEMP_FILES_REMOVED", count=removed))

    def open_path(self, base_invocation_name, chosen_path="prefix"):
        if not base_invocation_name:
            QMessageBox.warning(self, tr("APP_NAME"), tr("NO_INVOCATION_SELECTED_ERROR"))
            return

        base_file = Path(self.zordeer_dir) / "config" / f"invocation-info-{base_invocation_name.replace(' ', '_').lower()}.toml"

        if not base_file.exists():
            QMessageBox.warning(self, tr("APP_NAME"), tr("INVOCATION_INFO_ERROR"))
            return

        with base_file.open("r", encoding="utf-8") as f:
            invocation_info = toml.load(f)

        path = None
        if chosen_path == "prefix":
            path = Path(invocation_info.get("prefix_path", ""))
        elif chosen_path == "exe":
            exec_path = invocation_info.get("exec_path")
            path = Path(exec_path).parent if exec_path else None

        if path and path.exists():
            subprocess.run(["xdg-open", str(path)])
        else:
            QMessageBox.critical(
                self,
                tr("APP_NAME"),
                tr("OPEN_PATH_ERROR", path=str(path) if path else "")
            )

    def open_settings(self):
        dlg = SettingsDialog(self)
        dlg.exec()

    def show_about(self):
        dialog = QDialog(self)
        dialog.setWindowTitle(tr("ABOUT_ZORDEER"))
        dialog.setWindowModality(Qt.WindowModality.ApplicationModal)

        layout = QVBoxLayout(dialog)

        # Zordeer icon
        icon = self.windowIcon()
        if not icon.isNull():
            icon_label = QLabel()
            icon_label.setPixmap(icon.pixmap(64, 64))
            icon_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
            layout.addWidget(icon_label)

        # About text
        label = QLabel(tr("ABOUT_TEXT_HTML"))
        label.setWordWrap(True)
        label.setTextFormat(Qt.TextFormat.RichText)
        label.setOpenExternalLinks(True)
        label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(label)

        # Update button
        update_button = QPushButton(tr("CHECK_UPDATE_BUTTON"))
        update_button.clicked.connect(self.check_update)
        layout.addWidget(update_button, alignment=Qt.AlignmentFlag.AlignCenter)

        dialog.exec()

    def check_update(self):
        try:
            response = requests.get("https://api.github.com/repos/Kyuyrii/Zordeer/tags", timeout=5)
            response.raise_for_status()
            tags = response.json()
            if not tags:
                QMessageBox.warning(self, tr("APP_NAME"), tr("NO_TAGS_FOUND"))
                return

            latest_tag = tags[0]["name"].lstrip("v")
            current_version = __version__

            def version_tuple(v):
                return tuple(int(x) for x in v.split("."))

            if version_tuple(current_version) >= version_tuple(latest_tag):
                QMessageBox.information(self, tr("APP_NAME"), tr("ALREADY_UPDATED"))
            else:
                reply = QMessageBox.question(
                    self,
                    tr("APP_NAME"),
                    tr("NEW_VERSION_AVAILABLE", version=latest_tag),
                    QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
                )
                if reply == QMessageBox.StandardButton.Yes:
                    webbrowser.open("https://github.com/Kyuyrii/Zordeer/releases")
        except Exception as e:
            QMessageBox.warning(self, tr("APP_NAME"), tr("UPDATE_ERROR", error=e))

# Heroes and icons images / SteamGridDB
HEROES_DIR = Path.home() / "AppsFiles" / "Zordeer" / "sgdb" / "heroes"
ICONS_DIR = Path.home() / "AppsFiles" / "Zordeer" / "sgdb" / "icons"
HEROES_DIR.mkdir(parents=True, exist_ok=True)
ICONS_DIR.mkdir(parents=True, exist_ok=True)

# ===================== SGDB: artwork worker (thread) =====================
class ArtworkLoader(QThread):
    finished = pyqtSignal(list)  # List of artworks [{id, url, img_data}, ...]
    error = pyqtSignal(str)
    progress = pyqtSignal(int)   # 0 to 100%

    def __init__(self, api_key, game_id, art_type="heroes"):
        super().__init__()
        self.api_key = api_key
        self.game_id = game_id
        self.art_type = art_type  # "heroes" or "icons"

    def run(self):
        try:
            headers = {"Authorization": f"Bearer {self.api_key}"}
            url = f"https://www.steamgriddb.com/api/v2/{self.art_type}/game/{self.game_id}"
            resp = requests.get(url, headers=headers, timeout=20)
            resp.raise_for_status()
            data = resp.json().get("data", [])

            results = []
            total = len(data)

            for idx, art in enumerate(data):
                # Attempt to find the best available URL, in descending order of priority
                img_url = (
                    art.get("thumb")
                    or art.get("thumb_url")
                    or (art.get("thumbs")[0] if isinstance(art.get("thumbs"), list) and art.get("thumbs") else None)
                    or art.get("full")
                    or art.get("url")
                )

                img_data = None
                if img_url:
                    try:
                        rt = requests.get(img_url, timeout=15)
                        rt.raise_for_status()
                        img_data = rt.content
                    except Exception:
                        img_data = None  # If it fails, continue

                results.append({
                    "id": art.get("id"),
                    "url": img_url,
                    "img_data": img_data
                })

                # Updates the progress bar
                if total > 0:
                    self.progress.emit(int((idx + 1) / total * 100))

            self.finished.emit(results)

        except Exception as e:
            self.error.emit(tr("ARTS_LOAD_ERROR", error=str(e)))

# ===================== SGDB: Transfer heroes window =====================
class SteamGridDBApp(QDialog):
    def __init__(self, parent):
        super().__init__(parent)
        self.api_key = None
        self.headers = None
        self.results = []
        self.heroes = []
        self.selected_game = None
        self._cancel_auto = False

        self.setWindowTitle(tr("TRANSFER_ARTS_TITLE"))
        self.resize(750, 480)
        self.setMinimumSize(300, 250)

        main_layout = QVBoxLayout(self)
        self.setLayout(main_layout)

        # Lists (results and images) with resizable splitter
        self.games_panel = self.make_radio_panel_for_games()

        # Image Container Using QScrollArea
        self.images_container = QWidget()
        self.images_layout = QVBoxLayout(self.images_container)
        self.images_layout.setContentsMargins(6, 6, 6, 6)
        self.images_layout.setSpacing(4)
        self.images_layout.setAlignment(Qt.AlignmentFlag.AlignTop)  # Force items to the top

        self.images_scroll = QScrollArea()
        self.images_scroll.setWidgetResizable(True)
        self.images_scroll.setWidget(self.images_container)

        # Creates horizontal splitter
        body_splitter = QSplitter(Qt.Orientation.Horizontal)
        body_splitter.addWidget(self.games_panel["scroll"])
        body_splitter.addWidget(self.images_scroll)

        # Equal initial width for both sides
        body_splitter.setSizes([1, 1])

        # Prevents any side from disappearing when dragging
        body_splitter.setChildrenCollapsible(False)

        # Adds to main layout
        main_layout.addWidget(body_splitter)

        # Search
        search_row = QHBoxLayout()

        self.auto_button = QPushButton(tr("AUTO_TRANSFER_BUTTON"))
        self.auto_button.clicked.connect(self.run_auto_transfer)
        search_row.addWidget(self.auto_button)

        self.search_input = QLineEdit()
        search_row.addWidget(self.search_input)

        search_btn = QPushButton(tr("SEARCH"))
        search_btn.clicked.connect(self.search_game)
        search_row.addWidget(search_btn)
        main_layout.addLayout(search_row)

        # Action buttons (3 side by side)
        buttons_row = QHBoxLayout()

        self.load_icons_button = QPushButton(tr("LOAD_ICONS"))
        self.load_icons_button.setEnabled(False)
        self.load_icons_button.clicked.connect(lambda: self.load_artwork("icons"))
        buttons_row.addWidget(self.load_icons_button)

        self.transfer_button = QPushButton(tr("TRANSFER"))
        self.transfer_button.setEnabled(False)
        self.transfer_button.clicked.connect(self.transfer_images)
        self.transfer_button.setAutoDefault(False)
        self.transfer_button.setDefault(False)
        buttons_row.addWidget(self.transfer_button)

        self.load_heroes_button = QPushButton(tr("LOAD_HEROES"))
        self.load_heroes_button.setEnabled(False)
        self.load_heroes_button.clicked.connect(lambda: self.load_artwork("heroes"))
        buttons_row.addWidget(self.load_heroes_button)

        main_layout.addLayout(buttons_row)

        # Progress bar always visible
        self.progress_bar = QProgressBar()
        self.progress_bar.setRange(0, 100)
        self.progress_bar.setValue(0)  # Starts at 0%
        main_layout.addWidget(self.progress_bar)

        # Load API key if it exists
        self.load_api_key()

    def closeEvent(self, event):
        self._cancel_auto = True
        event.accept()

    def run_auto_transfer(self):
        self._cancel_auto = False
        if not self.headers:
            QMessageBox.warning(self, tr("APP_NAME"), tr("API_KEY_SAVE_FIRST"))
            return

        config_dir = Path.home() / "AppsFiles" / "Zordeer" / "config"
        if not config_dir.exists():
            QMessageBox.warning(self, tr("APP_NAME"), tr("NO_INVOCATIONS"))
            return

        # Invocations list
        invocations = []
        for toml_file in config_dir.glob("invocation-info-*.toml"):
            try:
                with open(toml_file, "r", encoding="utf-8") as fh:
                    inv = toml.load(fh)
                inv_name = inv.get("name") or inv.get("display_name") or inv.get("id")
                art_path = inv.get("art_path", "")
                gui_path = inv.get("gui_path", "")
                # Also includes cases where paths are filled in but the files do not exist
                art_missing = not art_path or not Path(art_path).exists()
                gui_missing = not gui_path or not Path(gui_path).exists()
                if inv_name and (art_missing or gui_missing):
                    invocations.append((inv_name, toml_file))
            except Exception:
                continue

        if not invocations:
            QMessageBox.information(self, tr("APP_NAME"), tr("AUTO_TRANSFER_NO_MISSING_ARTS"))
            return

        confirm = QMessageBox.question(
            self,
            tr("APP_NAME"),
            tr("AUTO_TRANSFER_EXPLAIN"),
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.No
        )
        if confirm != QMessageBox.StandardButton.Yes:
            return

        # Progress bar
        total = len(invocations)
        self.progress_bar.setRange(0, total)
        self.progress_bar.setValue(0)
        self.setEnabled(False)
        QApplication.processEvents()

        # Directories
        ART_DIR = Path.home() / "AppsFiles" / "Zordeer" / "art"
        GUI_DIR = Path.home() / "AppsFiles" / "Zordeer" / "art" / "gui"
        ART_DIR.mkdir(parents=True, exist_ok=True)
        GUI_DIR.mkdir(parents=True, exist_ok=True)

        completed = 0
        downloads = []  # Stores the hero and icon paths before copying

        for inv_name, toml_file in invocations:
            if self._cancel_auto:
                break

            hero_saved_path = None
            icon_saved_path = None

            try:
                # Search on SteamGridDB
                search_url = f"https://www.steamgriddb.com/api/v2/search/autocomplete/{inv_name}"
                resp = requests.get(search_url, headers=self.headers, timeout=15)
                resp.raise_for_status()
                data = resp.json().get("data", [])
                if not data:
                    completed += 1
                    self.progress_bar.setValue(completed)
                    QApplication.processEvents()
                    continue

                game = data[0]
                game_id = game.get("id")
                steam_game_name = game.get("name") or str(game_id)

                # Download the hero
                try:
                    hero_url = f"https://www.steamgriddb.com/api/v2/heroes/game/{game_id}"
                    r = requests.get(hero_url, headers=self.headers, timeout=20)
                    r.raise_for_status()
                    heroes = r.json().get("data", []) or []
                except Exception:
                    heroes = []

                if heroes:
                    heroes.sort(key=lambda a: a.get("score", 0), reverse=True)
                    best = heroes[0]
                    img_url = (
                        best.get("thumb")
                        or best.get("thumb_url")
                        or (best.get("thumbs")[0] if isinstance(best.get("thumbs"), list) and best.get("thumbs") else None)
                        or best.get("full")
                        or best.get("url")
                    )
                    if img_url:
                        try:
                            rr = requests.get(img_url, timeout=20)
                            rr.raise_for_status()
                            ext = Path(img_url).suffix
                            if not ext or len(ext) > 6:
                                ext = ".png"
                            game_hero_dir = HEROES_DIR / steam_game_name
                            game_hero_dir.mkdir(parents=True, exist_ok=True)
                            hero_filename = game_hero_dir / f"hero_{best.get('id')}{ext}"
                            with hero_filename.open("wb") as fh:
                                fh.write(rr.content)
                            hero_saved_path = hero_filename
                        except Exception:
                            hero_saved_path = None

                # Download the icon
                try:
                    icon_url = f"https://www.steamgriddb.com/api/v2/icons/game/{game_id}"
                    r = requests.get(icon_url, headers=self.headers, timeout=20)
                    r.raise_for_status()
                    icons = r.json().get("data", []) or []
                except Exception:
                    icons = []

                if icons:
                    icons.sort(key=lambda a: a.get("score", 0), reverse=True)
                    best = icons[0]
                    img_url = (
                        best.get("thumb")
                        or best.get("thumb_url")
                        or (best.get("thumbs")[0] if isinstance(best.get("thumbs"), list) and best.get("thumbs") else None)
                        or best.get("full")
                        or best.get("url")
                    )
                    if img_url:
                        try:
                            rr = requests.get(img_url, timeout=20)
                            rr.raise_for_status()
                            ext = Path(img_url).suffix
                            if not ext or len(ext) > 6:
                                ext = ".png"
                            game_icon_dir = ICONS_DIR / steam_game_name
                            game_icon_dir.mkdir(parents=True, exist_ok=True)
                            icon_filename = game_icon_dir / f"icon_{best.get('id')}{ext}"
                            with icon_filename.open("wb") as fh:
                                fh.write(rr.content)
                            icon_saved_path = icon_filename
                        except Exception:
                            icon_saved_path = None

                # Store for later copying
                downloads.append((inv_name, toml_file, hero_saved_path, icon_saved_path))

            except Exception as e:
                print(tr("AUTO_TRANSFER_GENERAL_ERROR", inv_name=inv_name, error=str(e)))
            finally:
                completed += 1
                self.progress_bar.setValue(completed)
                QApplication.processEvents()

        # After all downloads are complete, copy to art/gui
        if not self._cancel_auto:
            for inv_name, toml_file, hero_saved_path, icon_saved_path in downloads:
                normalized = inv_name.lower().replace(" ", "_").replace("/", "_").replace("\\", "_")
                copied_hero = False
                copied_icon = False

                try:
                    with open(toml_file, "r", encoding="utf-8") as fh:
                        inv_toml = toml.load(fh)
                except Exception:
                    inv_toml = {}

                if hero_saved_path:
                    try:
                        dest = ART_DIR / f"{normalized}{hero_saved_path.suffix}"
                        shutil.copy2(hero_saved_path, dest)
                        inv_toml["art_path"] = str(dest)
                        copied_hero = True
                    except Exception:
                        copied_hero = False

                if icon_saved_path:
                    try:
                        dest_icon = GUI_DIR / f"{normalized}{icon_saved_path.suffix}"
                        shutil.copy2(icon_saved_path, dest_icon)
                        inv_toml["gui_path"] = str(dest_icon)
                        copied_icon = True
                    except Exception:
                        copied_icon = False

                if copied_hero or copied_icon:
                    try:
                        with open(toml_file, "w", encoding="utf-8") as fh:
                            toml.dump(inv_toml, fh)
                    except Exception:
                        pass

        # Finalize progress bar
        self.progress_bar.setRange(0, 100)
        self.progress_bar.setValue(100)
        self.setEnabled(True)

        if not self._cancel_auto:
            if hasattr(self, 'parent_ref') and self.parent_ref:
                self.parent_ref.load_invocations()
            QMessageBox.information(self, tr("APP_NAME"), tr("AUTO_TRANSFER_FINISHED"))

    def keyPressEvent(self, event):
        if event.key() in (Qt.Key.Key_Return, Qt.Key.Key_Enter):
            # Prevents Enter from triggering something that is not selected
            return
        super().keyPressEvent(event)

    def load_api_key(self):
        settings = load_settings()
        self.api_key = settings["other"].get("sgdb_apikey", "").strip()
        self.headers = {"Authorization": f"Bearer {self.api_key}"} if self.api_key else None

    # Search games
    def search_game(self):
        """Searches for games in SteamGridDB and updates the radio panel."""
        if not self.headers:
            QMessageBox.warning(self, tr("APP_NAME"), tr("API_KEY_SAVE_FIRST"))
            return

        term = self.search_input.text().strip()
        if not term:
            QMessageBox.warning(self, tr("APP_NAME"), tr("ENTER_GAME_NAME"))
            return

        # Clear selection and UI before fetching
        self.selected_game = None
        # Clear the image container
        for i in reversed(range(self.images_layout.count())):
            widget = self.images_layout.itemAt(i).widget()
            if widget:
                widget.setParent(None)
        self.transfer_button.setEnabled(False)
        self.clear_radio_panel(self.games_panel)

        # API Search
        try:
            url = f"https://www.steamgriddb.com/api/v2/search/autocomplete/{term}"
            resp = requests.get(url, headers=self.headers, timeout=20)
            resp.raise_for_status()
            data = resp.json()
            self.results = data.get("data", []) if isinstance(data, dict) else []
        except Exception as e:
            QMessageBox.critical(self, tr("APP_NAME"), tr("API_FAIL", error=str(e)))
            return

        layout = self.games_panel["layout"]
        group = self.games_panel["button_group"]

        # No results
        if not self.results:
            layout.addWidget(QLabel(tr("NO_RESULTS")))
            return

        # Create new radios
        for game in self.results:
            rb = QRadioButton(f"{game.get('id')} - {game.get('name')}")
            rb.setProperty("game_data", game)
            rb.toggled.connect(self.on_game_radio_toggled)
            group.addButton(rb)
            layout.addWidget(rb)

    def clear_radio_panel(self, panel: dict):
        """Removes all radios and widgets from a radio panel."""
        group = panel["button_group"]
        layout = panel["layout"]

        # Remove buttons from group
        for btn in group.buttons():
            group.removeButton(btn)
            btn.deleteLater()

        # Remove widgets from the layout
        while layout.count():
            item = layout.takeAt(0)
            widget = item.widget()
            if widget:
                widget.deleteLater()

    def make_radio_panel_for_games(self):
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)

        container = QWidget()
        layout = QVBoxLayout(container)
        layout.setContentsMargins(6, 6, 6, 6)
        layout.setSpacing(4)
        scroll.setWidget(container)

        group = QButtonGroup(self)
        group.setExclusive(True)

        return {
            "scroll": scroll,
            "container": container,
            "layout": layout,
            "button_group": group,
        }

    def on_game_radio_toggled(self, checked: bool):
        if not checked:
            return
        rb = self.sender()
        game = rb.property("game_data")
        if not game:
            return
        self.selected_game = game

        # Activate the upload buttons
        self.load_icons_button.setEnabled(True)
        self.load_heroes_button.setEnabled(True)

    def load_artwork(self, art_type: str):
        """Loads artwork (heroes or icons) via worker."""
        if not self.selected_game:
            return

        game_id = self.selected_game.get("id")
        if not game_id:
            return

        self.current_art_type = art_type

        self.setEnabled(False)
        # Clear previous images
        for i in reversed(range(self.images_layout.count())):
            widget = self.images_layout.itemAt(i).widget()
            if widget:
                widget.setParent(None)
        self.transfer_button.setEnabled(False)

        # Infinite progress bar while loading
        self.progress_bar.setRange(0, 0)

        self.loader = ArtworkLoader(self.api_key, game_id, art_type)
        self.loader.finished.connect(self.on_images_loaded)
        self.loader.error.connect(self.on_loader_error)
        self.loader.start()

    def on_loader_error(self, msg):
        self.setEnabled(True)
        # Reset the bar
        self.progress_bar.setRange(0, 100)
        self.progress_bar.setValue(0)
        QMessageBox.critical(self, tr("APP_NAME"), msg)

    def on_images_loaded(self, heroes):
        self.setEnabled(True)

        # Reset progress bar
        self.progress_bar.setRange(0, 100)
        self.progress_bar.setValue(0)

        self.heroes = heroes or []

        # Clear image container
        for i in reversed(range(self.images_layout.count())):
            widget = self.images_layout.itemAt(i).widget()
            if widget:
                widget.setParent(None)

        if not self.heroes:
            label = QLabel(tr("NO_IMAGES"))
            self.images_layout.addWidget(label)
            self.transfer_button.setEnabled(False)
            return

        for hero in self.heroes:
            row = QWidget()
            row_layout = QHBoxLayout(row)
            row_layout.setContentsMargins(0, 0, 0, 0)
            # Adjust spacing according to the current Qt style
            if QApplication.style().objectName().lower() == "oxygen":
                row_layout.setSpacing(0)  # Specific Spacing for Oxygen
            else:
                row_layout.setSpacing(8)  # Default Spacing

            # Checkbox on the left
            checkbox = QCheckBox()
            checkbox.setProperty("hero_data", hero)
            row_layout.addWidget(checkbox)

            # Image
            img_label = QLabel()
            if img_data := hero.get("img_data"):
                pixmap = QPixmap()
                pixmap.loadFromData(img_data)
                img_label.setPixmap(pixmap.scaled(
                    240, 108,
                    Qt.AspectRatioMode.KeepAspectRatio,
                    Qt.TransformationMode.SmoothTransformation
                ))
            row_layout.addWidget(img_label)

            # Name/ID next to image
            text_label = QLabel(f"ID {hero.get('id')}")
            text_label.setContentsMargins(8, 0, 0, 0)
            row_layout.addWidget(text_label)

            row_layout.addStretch()  # Maintains clean horizontal alignment

            self.images_layout.addWidget(row)

        self.transfer_button.setEnabled(True)

    def transfer_images(self):
        """Transfers the selected images."""
        if not self.selected_game:
            return

        to_transfer = []

        for i in range(self.images_layout.count()):
            row = self.images_layout.itemAt(i).widget()
            if not row:
                continue
            checkbox = row.findChild(QCheckBox)
            if checkbox and checkbox.isChecked():
                hero = checkbox.property("hero_data")
                if hero and hero.get("url"):
                    to_transfer.append(hero)

        if not to_transfer:
            QMessageBox.information(self, tr("APP_NAME"), tr("SELECT_AT_LEAST_ONE_IMAGE"))
            return

        self.setEnabled(False)

        game_name = (self.selected_game.get("name") or str(self.selected_game.get('id'))).replace("/", "_")
        base_dir = HEROES_DIR if self.current_art_type == "heroes" else ICONS_DIR
        save_dir = base_dir / game_name
        save_dir.mkdir(parents=True, exist_ok=True)

        # Pull-up bar
        self.progress_bar.setRange(0, len(to_transfer))
        self.progress_bar.setValue(0)

        for i, art in enumerate(to_transfer, start=1):
            url = art.get("url")
            try:
                r = requests.get(url, timeout=30)
                r.raise_for_status()
                ext = Path(url).suffix
                if not ext or len(ext) > 6:
                    ext = ".png"
                prefix = "hero_" if self.current_art_type == "heroes" else "icon_"
                filename = save_dir / f"{prefix}{art.get('id')}{ext}"
                with filename.open("wb") as f:
                    f.write(r.content)
            except Exception as e:
                print(tr("ERROR_TRANSFERRING_URL", url=url, error=e))

            self.progress_bar.setValue(i)
            QApplication.processEvents()

        # Reset bar
        self.progress_bar.setValue(100)
        QMessageBox.information(self, tr("APP_NAME"), tr("TRANSFER_SUMMARY", len=len(to_transfer), dir=str(save_dir)))
        self.setEnabled(True)
        self.progress_bar.setValue(0)

if __name__ == "__main__":
    # Loads settings
    settings = load_settings()
    # Uses full saved locale, or LANG defined in the module (which already has 'pt_BR.UTF-8', for example)
    current_lang = settings["design"].get("language", LANG)
    LANG = current_lang  # Update the global variable
    app = QApplication(sys.argv)

    # Load Qt translation
    translator = QTranslator()
    user_locale = LANG
    translations_path = QLibraryInfo.path(QLibraryInfo.LibraryPath.TranslationsPath)

    if translator.load(f"qt_{user_locale}", translations_path):
        app.installTranslator(translator)

    # Define the application ID so Wayland can find the icon.
    # We use the lowercase application name with hyphens instead of spaces.
    app_id = tr("APP_NAME").lower().replace(' ', '-')
    app.setDesktopFileName(app_id)

    # Helper function to send command to already running instance
    def send_to_running_instance(message: str) -> bool:
        socket = QLocalSocket()
        socket.connectToServer("zordeer_single_instance")
        if socket.waitForConnected(300):
            socket.write(message.encode("utf-8"))
            socket.flush()
            socket.waitForBytesWritten(300)
            socket.disconnectFromServer()
            return True
        return False

    # Try sending --start-invocation command to existing instance
    if "--start-invocation" in sys.argv:
        try:
            idx = sys.argv.index("--start-invocation") + 1
            invocation_name = sys.argv[idx]
            if send_to_running_instance(f'--start-invocation "{invocation_name}"'):
                sys.exit(0)
        except IndexError:
            pass

    # Server for single instance
    def handle_new_connection():
        socket = window.server.nextPendingConnection()
        if not socket.waitForReadyRead(1000):
            socket.disconnectFromServer()
            return
        data = socket.readAll().data().decode("utf-8").strip()

        if data == "--heartbeat":
            socket.write(b"alive")
            socket.flush()
            socket.waitForBytesWritten(300)
            socket.disconnectFromServer()
            return

        if data.startswith("--start-invocation "):
            invocation_name = data[len("--start-invocation "):].strip('"')
            QTimer.singleShot(200, lambda: window.start_invocation(invocation_name))

        socket.disconnectFromServer()

    def is_instance_alive() -> bool:
        socket = QLocalSocket()
        socket.connectToServer("zordeer_single_instance")
        if socket.waitForConnected(300):
            socket.write(b"--heartbeat")
            socket.flush()
            if socket.waitForReadyRead(300):
                response = socket.readAll().data().decode("utf-8").strip()
                socket.disconnectFromServer()
                if response == "alive":
                    return True
        QLocalServer.removeServer("zordeer_single_instance")
        return False

    # Create the single-instance server only if the option is NOT checked
    if is_instance_alive():
        if "--start-invocation" in sys.argv:
            try:
                idx = sys.argv.index("--start-invocation") + 1
                invocation_name = sys.argv[idx]
                send_to_running_instance(f'--start-invocation "{invocation_name}"')
            except IndexError:
                pass
        sys.exit(0)

    window = Zordeer()

    window.server_name = "zordeer_single_instance"
    window.server = QLocalServer(window)
    window.server.listen(window.server_name)
    window.server.newConnection.connect(handle_new_connection)

    if "--start-invocation" in sys.argv:
        try:
            idx = sys.argv.index("--start-invocation") + 1
            invocation_name = sys.argv[idx]
            QTimer.singleShot(500, lambda: window.start_invocation(invocation_name))
        except IndexError:
            pass

    sys.exit(app.exec())