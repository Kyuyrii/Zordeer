#!/usr/bin/env python3
# -*- coding: UTF-8 -*-

import sys
import os
import locale
import json
import toml
import subprocess
import atexit
import shutil
import requests
import tarfile
import io
import threading
import time
import psutil
import uuid
import re
import random
import csv
import dbus
from pathlib import Path
from functools import partial

# Translation System
try:
    locale.setlocale(locale.LC_ALL, '')
    LANG, _ = locale.getlocale(locale.LC_CTYPE)
except locale.Error:
    LANG = 'en_US'

if not LANG:
    LANG = 'en_US'

__version__ = "1.7.8.1"
__creator__ = "<a href='https://github.com/Kyuyrii'>Kyuyrii</a>"

if "ZORDEER_DIR" in os.environ:
    zordeer_dir = Path(os.environ["ZORDEER_DIR"]) / "App" / "Zordeer"
    home_dir = Path(os.environ["ZORDEER_DIR"])

elif os.environ.get("SNAP"):
    home_connected = subprocess.run(["snapctl", "is-connected", "home"]).returncode == 0

    if home_connected:
        zordeer_dir = Path(os.environ["SNAP_REAL_HOME"]) / "App" / "Zordeer"
        home_dir = Path(os.environ["SNAP_REAL_HOME"])
    else:
        zordeer_dir = Path(os.environ["SNAP_USER_COMMON"]) / "App" / "Zordeer"
        home_dir = Path(os.environ["SNAP_USER_COMMON"])

elif os.environ.get("container") == "flatpak":
    if os.environ.get("ZORDEER_DIR_APP_ID") == "1":
        zordeer_dir = Path.home() / ".var" / "app" / "io.github.kyuyrii.zordeer" / "App" / "Zordeer"
        home_dir = Path.home() / ".var" / "app" / "io.github.kyuyrii.zordeer"
    else:
        zordeer_dir = Path.home() / "App" / "Zordeer"
        home_dir = Path.home()

else:
    zordeer_dir = Path.home() / "App" / "Zordeer"
    home_dir = Path.home()

if os.environ.get("XDG_CACHE_HOME"):
    XDG_CACHE_HOME = Path(os.environ["XDG_CACHE_HOME"])
else:
    XDG_CACHE_HOME = Path.home() / ".cache"

# Loads translations from external TOML files.
def load_external_translations():
    external_translations = {}
    supported_languages = {}

    # Translation folders
    translation_dirs = [
        zordeer_dir / "translation",
        Path(sys.argv[0]).parent / "translation",
        Path("/usr/share/Zordeer/translation")
    ]

    for translation_folder in translation_dirs:
        if translation_folder.exists():
            for toml_file in translation_folder.glob("zordeer-translation-*.toml"):
                try:
                    lang_code = toml_file.stem.replace("zordeer-translation-", "")
                    with open(toml_file, 'r', encoding='utf-8') as f:
                        lang_data = toml.load(f)

                    # Add to translations
                    external_translations[lang_code] = lang_data

                    # Adds to supported languages
                    lang_name = lang_data.get("language_name", lang_code)
                    supported_languages[lang_name] = lang_code

                    print(f"Loaded translation: {lang_name} ({lang_code})")

                except Exception as e:
                    print(f"Error loading translation {toml_file}: {e}")

    return external_translations, supported_languages

# Load external translations
EXTERNAL_TRANSLATIONS, SUPPORTED_LANGUAGES = load_external_translations()

def tr(key, **kwargs):
    # Get the translated string from external translations
    if LANG in EXTERNAL_TRANSLATIONS:
        translation_dict = EXTERNAL_TRANSLATIONS[LANG]
        translated_string = translation_dict.get(key)
        
        if translated_string:
            # Replace special variables
            translated_string = translated_string.replace("{__version__}", __version__)
            translated_string = translated_string.replace("{__creator__}", __creator__)

            # Apply formatting with any additional kwargs
            try:
                return translated_string.format(**kwargs)
            except KeyError:
                return translated_string

    # If no translation found, return the key itself
    return key

# PyQt6 Imports
try:
    from PyQt6.QtWidgets import (QApplication, QMainWindow, QWidget, QVBoxLayout, QListWidget, QPushButton, QMessageBox, QToolBar, QDialog, QGridLayout,
    QLabel, QLineEdit, QHBoxLayout, QFileDialog, QComboBox, QCheckBox, QListWidgetItem, QStyleFactory, QProgressBar, QButtonGroup,
    QSplitter, QScrollArea, QRadioButton, QAbstractItemView, QTreeWidget, QTreeWidgetItem, QSystemTrayIcon, QMenu, QListView, QSpinBox, QTextEdit, QProgressDialog)
    from PyQt6.QtCore import Qt, QThread, pyqtSignal, QSize, QTimer, QEvent, QTranslator, QLibraryInfo
    from PyQt6.QtGui import QAction, QIcon, QPixmap, QPainter, QPalette, QColor, QTextCharFormat, QTextCursor
    from PyQt6.QtNetwork import QLocalServer, QLocalSocket
    print("Using PyQt6")
except ImportError:
    print("PyQt6 not found")
    sys.exit(1)

INVOCATION_LOCALE_OPTIONS = [
    'English USA (en_US.UTF-8)',
    'Português Brasil (pt_BR.UTF-8)',
    'Português Portugal (pt_PT.UTF-8)',
    'Español España (es_ES.UTF-8)',
    'Español México (es_MX.UTF-8)',
    'Français (fr_FR.UTF-8)',
    'Deutsch (de_DE.UTF-8)',
    'Italiano (it_IT.UTF-8)',
    'Русский (ru_RU.UTF-8)',
    'Українська (uk_UA.UTF-8)',
    'Polski (pl_PL.UTF-8)',
    'Česky (cs_CZ.UTF-8)',
    'Slovenčina (sk_SK.UTF-8)',
    'Magyar (hu_HU.UTF-8)',
    'Română (ro_RO.UTF-8)',
    'Nederlands (nl_NL.UTF-8)',
    'Svenska (sv_SE.UTF-8)',
    'Norsk Bokmål (nb_NO.UTF-8)',
    'Dansk (da_DK.UTF-8)',
    'Suomi (fi_FI.UTF-8)',
    'Ελληνικά (el_GR.UTF-8)',
    'Български (bg_BG.UTF-8)',
    '日本語 (ja_JP.UTF-8)',
    '한국어 (ko_KR.UTF-8)',
    '简体中文 (zh_CN.UTF-8)',
    '繁體中文 (zh_TW.UTF-8)',
    'العربية (ar_SA.UTF-8)',
    'فارسی (fa_IR.UTF-8)',
    'Türkçe (tr_TR.UTF-8)',
    'हिन्दी (hi_IN.UTF-8)',
    'ไทย (th_TH.UTF-8)',
    'עברית (he_IL.UTF-8)',
]

# Zordeer settings (TOML)
# $HOME/App/Zordeer/config/zordeer-settings.toml
zordeer_config_dir = zordeer_dir / "config"
zordeer_settings_file = zordeer_config_dir / "zordeer-settings.toml"

def detect_default_settings() -> dict:
    """Provides default settings for first-time creation."""
    return {
        "design": {
            "qt_style": "indefinite",
            "language": LANG if LANG else "en_US",
            "layout_mode": "classic",
            "icon_width_classic": 420,
            "icon_width_grid": 300,
            "toolbar_position": "top",
            "toolbar_icon_size": 32,
            "search_bar_visible": False,
            "toolbar_visible": True,
        },
        "window": {
            "isMaximized": "",
            "isFullScreen": "",
            "start_minimized": "",
            "windowSize": [780, 640],
        },
        "shortcut": {
            "desktop_dir": "",
            "dot_config_dir": "",
            "dot_local_dir": "",
            "own_category": True,
        },
        "other": {
            "default_runner": "indefinite",
            "umu_version": "indefinite",
            "sgdb_apikey": "",
            "umu_global": False,
        }
    }

def load_settings() -> dict:
    """Loads settings, uses indefinite if saved style is unavailable."""
    defaults = detect_default_settings()

    try:
        with open(zordeer_settings_file, "r", encoding="utf-8") as f:
            data = toml.load(f)
    except Exception:
        # First creation: save default settings
        save_settings(defaults)
        return defaults

    # Remove outdated or unknown top-level keys
    for key in list(data.keys()):
        if key not in defaults:
            del data[key]

    # Ensure missing top-level sections exist
    for key, value in defaults.items():
        data.setdefault(key, value)

    # Ensure missing keys inside each section
    for section in defaults:
        for key, value in defaults[section].items():
            data[section].setdefault(key, value)

    # Remove outdated keys inside sections
    for section in defaults:
        for key in list(data[section].keys()):
            if key not in defaults[section]:
                del data[section][key]

    # Validate qt_style
    current_style = data["design"]["qt_style"]
    if current_style != "indefinite" and current_style not in QStyleFactory.keys():
        data["design"]["qt_style"] = "indefinite"
        save_settings(data)

    return data

def save_settings(data: dict) -> None:
    """Saves settings in TOML."""
    zordeer_config_dir.mkdir(parents=True, exist_ok=True)
    with open(zordeer_settings_file, "w", encoding="utf-8") as f:
        toml.dump(data, f)

class SettingsDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle(tr("ZORDEER_SETTINGS"))
        self.setMinimumSize(400, 260)

        self.settings = load_settings()

        layout = QGridLayout(self)

        # Qt Style Choice
        style_label = QLabel(tr("QT_STYLE"))
        self.style_combo = QComboBox()
        self.style_combo.addItem(tr("DEFAULT_QT_STYLE"))
        self.style_combo.addItems(QStyleFactory.keys())
        saved_style = self.settings["design"].get("qt_style", "indefinite")
        if saved_style == "indefinite":
            self.style_combo.setCurrentText(tr("DEFAULT_QT_STYLE"))
        else:
            self.style_combo.setCurrentText(saved_style)
        layout.addWidget(style_label, 0, 0)
        layout.addWidget(self.style_combo, 0, 1)

        # Language Choice
        lang_label = QLabel(tr("LANGUAGE"))
        self.lang_combo = QComboBox()
        self.lang_combo.addItems(SUPPORTED_LANGUAGES.keys())
        saved_lang = self.settings["design"].get("language", LANG)
        lang_codes = list(SUPPORTED_LANGUAGES.values())
        if saved_lang in lang_codes:
            self.lang_combo.setCurrentIndex(lang_codes.index(saved_lang))
        else:
            self.lang_combo.setCurrentIndex(0)
        layout.addWidget(lang_label, 1, 0)
        layout.addWidget(self.lang_combo, 1, 1)

        # Visualization Choice
        layout_mode_label = QLabel(tr("LAYOUT_MODE"))
        self.layout_mode_combo = QComboBox()
        self.layout_mode_combo.addItems([
            tr("LAYOUT_MODE_CLASSIC"),
            tr("LAYOUT_MODE_GRID"),
            tr("LAYOUT_MODE_LIST"),
        ])
        saved_layout_mode = self.settings["design"].get("layout_mode", "classic")
        index_map = {"classic": 0, "grid": 1, "list": 2}
        self.layout_mode_combo.setCurrentIndex(index_map.get(saved_layout_mode, 0))
        layout.addWidget(layout_mode_label, 2, 0)
        layout.addWidget(self.layout_mode_combo, 2, 1)

        # Icon Width for Classic
        classic_width_label = QLabel(tr("ICON_WIDTH_CLASSIC"))
        self.classic_width_input = QSpinBox()
        self.classic_width_input.setRange(100, 2000)
        self.classic_width_input.setValue(self.settings["design"].get("icon_width_classic", 420))
        layout.addWidget(classic_width_label, 3, 0)
        layout.addWidget(self.classic_width_input, 3, 1)

        # Icon Width for Grid
        grid_width_label = QLabel(tr("ICON_WIDTH_GRID"))
        self.grid_width_input = QSpinBox()
        self.grid_width_input.setRange(100, 2000)
        self.grid_width_input.setValue(self.settings["design"].get("icon_width_grid", 300))
        layout.addWidget(grid_width_label, 4, 0)
        layout.addWidget(self.grid_width_input, 4, 1)

        # Toolbar icon size
        toolbar_icon_size_label = QLabel(tr("ICON_TOOLBAR_SIZE"))
        self.toolbar_icon_size_input = QSpinBox()
        self.toolbar_icon_size_input.setRange(16, 128)
        self.toolbar_icon_size_input.setValue(self.settings["design"].get("toolbar_icon_size", 32))
        layout.addWidget(toolbar_icon_size_label, 5, 0)
        layout.addWidget(self.toolbar_icon_size_input, 5, 1)

        # Default Runner Choice
        runner_label = QLabel(tr("DEFAULT_RUNNER"))
        self.runner_combo = QComboBox()
        self.populate_runners_settings()
        # Select the correctly saved runner.
        saved_runner = self.settings["other"].get("default_runner", "")
        index = self.runner_combo.findText(saved_runner)
        if index == -1 and saved_runner and saved_runner.lower() != "indefinite":
            # Try selecting the "UNAVAILABLE" version.
            unavailable_text = f"{saved_runner} ({tr("UNAVAILABLE")})"
            index = self.runner_combo.findText(unavailable_text)
        if index != -1:
            self.runner_combo.setCurrentIndex(index)
        else:
            # If you didn't find anything, use a placeholder.
            self.runner_combo.setCurrentText(tr("INDEFINITE"))
        layout.addWidget(runner_label, 6, 0)
        layout.addWidget(self.runner_combo, 6, 1)

        # UMU Launcher Choice
        umu_label = QLabel(tr("UMU_VERSION"))
        self.umu_combo = QComboBox()
        self.populate_umu_versions()
        # Select the correctly saved UMU version
        saved_umu = self.settings["other"].get("umu_version", "")
        index = self.umu_combo.findText(saved_umu)
        if index == -1 and saved_umu and saved_umu.lower() != "indefinite":
            # Try selecting the "UNAVAILABLE" version.
            unavailable_text = f"{saved_umu} ({tr("UNAVAILABLE")})"
            index = self.umu_combo.findText(unavailable_text)
        if index != -1:
            self.umu_combo.setCurrentIndex(index)
        else:
            # If you didn't find anything, use a placeholder.
            self.umu_combo.setCurrentText(tr("INDEFINITE"))
        layout.addWidget(umu_label, 7, 0)
        layout.addWidget(self.umu_combo, 7, 1)

        # SGDB API Key
        api_label = QLabel(tr("SGDB_API_KEY_LABEL"))
        self.api_input = QLineEdit()
        self.api_input.setEchoMode(QLineEdit.EchoMode.Password)
        self.api_input.setText(self.settings["other"].get("sgdb_apikey", ""))
        layout.addWidget(api_label, 8, 0)
        layout.addWidget(self.api_input, 8, 1)

        # Umu global
        self.umu_global_checkbox = QCheckBox(tr("UMU_GLOBAL"))
        self.umu_global_checkbox.setChecked(self.settings["other"].get("umu_global", False))
        layout.addWidget(self.umu_global_checkbox, 9, 0)

        # Save button
        save_btn = QPushButton(tr("SAVE_BUTTON"))
        save_btn.clicked.connect(self.save_and_close)
        layout.addWidget(save_btn, 10, 1, alignment=Qt.AlignmentFlag.AlignRight)

        self.setLayout(layout)

    def keyPressEvent(self, event):
        if event.key() in (Qt.Key.Key_Return, Qt.Key.Key_Enter):
            # Prevents Enter from triggering something that is not selected
            return
        super().keyPressEvent(event)

    def save_and_close(self):
        selected_runner = self.runner_combo.currentText()
        selected_umu = self.umu_combo.currentText()

        # Runner validation
        if tr("UNAVAILABLE") in selected_runner:
            reply = QMessageBox.question(
                self,
                tr("APP_NAME"),
                tr("SELECT_AVAILABLE_RUNNER_CONFIRM"),
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )
            if reply == QMessageBox.StandardButton.No:
                return

        # UMU validation
        if tr("UNAVAILABLE") in selected_umu:
            reply = QMessageBox.question(
                self,
                tr("APP_NAME"),
                tr("SELECT_AVAILABLE_UMU_CONFIRM"),
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )
            if reply == QMessageBox.StandardButton.No:
                return

        unavailable_text = f" ({tr("UNAVAILABLE")})"
        if unavailable_text in selected_runner:
            selected_runner = selected_runner.replace(unavailable_text, "")

        if unavailable_text in selected_umu:
            selected_umu = selected_umu.replace(unavailable_text, "")

        self.settings["design"]["qt_style"] = self.style_combo.currentText()
        selected_index = self.lang_combo.currentIndex()
        self.settings["design"]["language"] = list(SUPPORTED_LANGUAGES.values())[selected_index]
        self.settings["design"]["layout_mode"] = ["classic", "grid", "list"][self.layout_mode_combo.currentIndex()]
        self.settings["design"]["toolbar_icon_size"] = self.toolbar_icon_size_input.value()
        if selected_runner == tr("INDEFINITE"):
            self.settings["other"]["default_runner"] = "indefinite"
        else:
            self.settings["other"]["default_runner"] = selected_runner
        self.settings["other"]["sgdb_apikey"] = self.api_input.text().strip()
        if selected_umu == tr("INDEFINITE"):
            self.settings["other"]["umu_version"] = "indefinite"
        else:
            self.settings["other"]["umu_version"] = selected_umu

        # Save the icon widths
        self.settings["design"]["icon_width_classic"] = self.classic_width_input.value()
        self.settings["design"]["icon_width_grid"] = self.grid_width_input.value()

        self.settings["other"]["umu_global"] = self.umu_global_checkbox.isChecked()

        save_settings(self.settings)
        QMessageBox.information(self, tr("APP_NAME"), tr("SETTINGS_SAVED_RESTART"))
        self.accept()

    def populate_runners_settings(self):
        runners_path = zordeer_dir / "runner"
        runners_path.mkdir(parents=True, exist_ok=True)
        available_runners = sorted([d.name for d in runners_path.iterdir() if d.is_dir()], reverse=True)

        items = [tr("INDEFINITE")]

        # Add Wine only if wine command is found
        if shutil.which("wine"):
            items.append("Wine")

        items += available_runners

        # Add current runner from settings if it's not in the folder
        saved_runner = self.settings["other"].get("default_runner", "")
        if saved_runner and saved_runner not in items and saved_runner.lower() != "indefinite":
            items.append(f"{saved_runner} ({tr("UNAVAILABLE")})")

        self.runner_combo.clear()
        self.runner_combo.addItems(items)

    def populate_umu_versions(self):
        umu_path = zordeer_dir / "umu"

        # Check if each folder has the umu-run file
        available_umu = sorted([
            d.name for d in umu_path.iterdir()
            if d.is_dir() and (d / "umu-run").exists()
        ], reverse=True)

        items = [tr("INDEFINITE")]
        items += available_umu

        # Add current UMU version from settings if it's not in the folder
        saved_umu = self.settings["other"].get("umu_version", "")
        if saved_umu and saved_umu not in items and saved_umu.lower() != "indefinite":
            items.append(f"{saved_umu} ({tr("UNAVAILABLE")})")

        self.umu_combo.clear()
        self.umu_combo.addItems(items)

# Transfer Worker Thread
class TransferWorker(QThread):
    progress = pyqtSignal(int)
    message = pyqtSignal(str)
    finished = pyqtSignal(str)
    error = pyqtSignal(str)

    def __init__(self, url, runner_name, runners_dir, parent=None):
        super().__init__(parent)
        self.url = url
        self.runner_name = runner_name
        self.runners_dir = Path(runners_dir)
        self.cancelled = False
        self.finished_transfer = False


    def cancel(self):
        self.cancelled = True

    def run(self):
        try:
            self.message.emit(tr("TRANSFERRING_RUNNER", name=Path(self.url).name))
            response = requests.get(self.url, stream=True, timeout=30)
            response.raise_for_status()

            total_size = int(response.headers.get('content-length', 0))
            bytes_transferred = 0

            temp_file = io.BytesIO()
            for chunk in response.iter_content(chunk_size=8192):
                if self.cancelled and not self.finished_transfer:
                    self.message.emit(tr("TRANSFER_CANCELED"))
                    return

                temp_file.write(chunk)
                bytes_transferred += len(chunk)
                if total_size > 0:
                    self.progress.emit(min(int(bytes_transferred / total_size * 100), 100))

            temp_file.seek(0)

            self.message.emit(tr("EXTRACTING", name=Path(self.url).name))

            if "umu-launcher" in self.runner_name.lower():
                base_dir = self.runners_dir.parent / "umu"
            else:
                base_dir = self.runners_dir

            base_dir.mkdir(parents=True, exist_ok=True)
            runner_destination_path = base_dir / self.runner_name
            initial_files = set(base_dir.iterdir())

            # Open the tar
            with tarfile.open(fileobj=temp_file, mode="r:*") as tf:
                members = list(tf.getmembers())

                # Automatically detect the root folder containing the files
                root_dirs = set()
                for m in members:
                    if m.isdir() and any(mm.name.startswith(m.name.rstrip('/') + '/') for mm in members if mm.isfile()):
                        root_dirs.add(m.name.rstrip('/'))

                # If not found, use all files
                if not root_dirs:
                    selected_members = members
                else:
                    # Select all files within the first detected folder
                    root = sorted(root_dirs)[0]
                    selected_members = [m for m in members if m.name.startswith(root + '/')]

                # Python 3.14+: safer extraction
                tf.extractall(path=base_dir, members=selected_members, filter="data")

            final_files = set(base_dir.iterdir())
            new_entries = list(final_files - initial_files)

            if not new_entries:
                self.error.emit(tr("NO_FILES_EXTRACTED"))
                return

            # Move the detected folder to the runner destination path
            extracted_path = new_entries[0]
            if extracted_path != runner_destination_path:
                if runner_destination_path.exists():
                    shutil.rmtree(runner_destination_path)
                shutil.move(str(extracted_path), str(runner_destination_path))

            self.finished_transfer = True
            self.finished.emit(tr("TRANSFER_AND_INSTALL_SUCCESS", name=Path(self.url).name))

        except requests.exceptions.RequestException as e:
            self.error.emit(tr("TRANSFER_FAILED", error=str(e)))
        except tarfile.TarError as e:
            self.error.emit(tr("TRANSFER_ERROR", error=str(e)))
        except Exception as e:
            self.error.emit(tr("TRANSFER_ERROR", error=str(e)))

class RunnerTransferDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle(tr("TRANSFER_RUNNERS_TITLE"))
        self.resize(450, 420)
        self.setMinimumSize(400, 200)
        self.parent = parent

        main_layout = QVBoxLayout(self)

        # Runner selection layout
        selection_layout = QHBoxLayout()
        self.runner_combo = QComboBox()
        self.runner_combo.addItems(["Proton-GE", "Proton-Sarek", "Proton-EM", "Proton-CachyOS", "UMU-launcher", "UMU-Proton"])
        selection_layout.addWidget(self.runner_combo)
        main_layout.addLayout(selection_layout)

        buttons_layout = QHBoxLayout()

        # Button to open the repository of the selected runner
        self.repo_button = QPushButton(tr("OPEN_REPO"))
        self.repo_button.clicked.connect(self.open_runner_repo)
        buttons_layout.addWidget(self.repo_button)

        # Button to manually load releases
        self.load_button = QPushButton(tr("LOAD_VERSIONS"))
        self.load_button.clicked.connect(self.handle_load_versions)
        buttons_layout.addWidget(self.load_button)

        main_layout.addLayout(buttons_layout)

        # Scroll area for versions
        self.scroll = QScrollArea()
        self.scroll.setWidgetResizable(True)

        self.container = QWidget()
        self.layout = QVBoxLayout(self.container)
        self.layout.setContentsMargins(6, 6, 6, 6)
        self.layout.setSpacing(4)
        self.scroll.setWidget(self.container)

        main_layout.addWidget(self.scroll)

        # Button group for radio buttons
        self.button_group = QButtonGroup(self)
        self.button_group.setExclusive(True)
        self.button_group.buttonToggled.connect(self.update_transfer_button_state)

        # Transfer button always visible
        self.transfer_button = QPushButton(tr("TRANSFER"))
        self.transfer_button.clicked.connect(self.start_transfer)
        self.transfer_button.setEnabled(False)  # Disabled until something is selected
        main_layout.addWidget(self.transfer_button)

        # Fixed progress bar at the bottom
        self.progress_bar = QProgressBar()
        self.progress_bar.setMinimum(0)
        self.progress_bar.setMaximum(100)
        self.progress_bar.setValue(0)
        main_layout.addWidget(self.progress_bar)

        # Map of runner URLs
        self.runner_urls = {
            "Proton-GE": "https://api.github.com/repos/GloriousEggroll/proton-ge-custom/releases",
            "Proton-Sarek": "https://api.github.com/repos/pythonlover02/Proton-Sarek/releases",
            "Proton-EM": "https://api.github.com/repos/Etaash-mathamsetty/Proton/releases",
            "Proton-CachyOS": "https://api.github.com/repos/CachyOS/proton-cachyos/releases",
            "UMU-launcher": "https://api.github.com/repos/Open-Wine-Components/umu-launcher/releases",
            "UMU-Proton": "https://api.github.com/repos/Open-Wine-Components/umu-proton/releases",
        }

    def open_runner_repo(self):
        selected_runner = self.runner_combo.currentText()
        urls = {
            "Proton-GE": "https://github.com/GloriousEggroll/proton-ge-custom",
            "Proton-Sarek": "https://github.com/pythonlover02/Proton-Sarek",
            "Proton-EM": "https://github.com/Etaash-mathamsetty/Proton",
            "Proton-CachyOS": "https://github.com/CachyOS/proton-cachyos",
            "UMU-launcher": "https://github.com/Open-Wine-Components/umu-launcher",
            "UMU-Proton": "https://github.com/Open-Wine-Components/umu-proton",
        }
        url = urls.get(selected_runner)
        if url:
            subprocess.Popen(['xdg-open', url])

    def closeEvent(self, event):
        if hasattr(self, "worker") and self.worker.isRunning() and not self.worker.finished_transfer:
            self.worker.cancel()
        event.accept()

    def keyPressEvent(self, event):
        if event.key() in (Qt.Key.Key_Return, Qt.Key.Key_Enter):
            return
        super().keyPressEvent(event)

    def handle_load_versions(self):
        runner_type = self.runner_combo.currentText()
        self.load_releases(runner_type)

    def load_releases(self, runner_type):
        url = self.runner_urls[runner_type]

        try:
            response = requests.get(url, timeout=(5, 30))
            response.raise_for_status()
            releases = response.json()

            # Clear existing items
            for btn in self.button_group.buttons():
                self.button_group.removeButton(btn)
                btn.deleteLater()

            while self.layout.count():
                it = self.layout.takeAt(0)
                w = it.widget()
                if w:
                    w.deleteLater()

            first_rb = None

            for release in releases[:30]:
                for asset in release.get('assets', []):
                    display_name = None

                    if runner_type == "UMU-launcher":
                        if asset['name'].endswith('-zipapp.tar'):
                            display_name = asset['name']
                    else:
                        if asset['name'].endswith(('.tar.gz', '.tar.xz')):
                            display_name = asset['name']

                    if display_name:
                        rb = QRadioButton(display_name)
                        rb.setProperty("runner_data", {
                            'tag_name': release['tag_name'],
                            'url': asset['browser_download_url'],
                            'display_name': display_name
                        })

                        self.button_group.addButton(rb)
                        self.layout.addWidget(rb)

                        if first_rb is None:
                            first_rb = rb

            if first_rb:
                first_rb.setChecked(True)

            self.update_transfer_button_state()

        except requests.exceptions.RequestException as e:
            QMessageBox.critical(self, tr("APP_NAME"), tr("TRANSFER_ERROR") + f"\n{e}")

    def update_transfer_button_state(self):
        self.transfer_button.setEnabled(self.button_group.checkedButton() is not None)

    def start_transfer(self):
        checked = self.button_group.checkedButton()

        item_data = checked.property("runner_data")
        tag_name = item_data['tag_name']
        url = item_data['url']

        selected_runner = self.runner_combo.currentText()

        if selected_runner == "UMU-launcher":
            runner_folder_name = f"umu-{tag_name}"
            base_dir = zordeer_dir / "umu"
        else:
            formatted_tag = tag_name.replace('GE-Proton-', '').replace('GE-Proton', '')
            if selected_runner == "Proton-GE":
                runner_folder_name = f"Proton-GE-{formatted_tag}"
            else:
                file_name = Path(url).name
                runner_folder_name = file_name.replace(".tar.gz", "").replace(".tar.xz", "")
            base_dir = zordeer_dir / "runner"

        runner_path = base_dir / runner_folder_name

        if runner_path.exists():
            reply = QMessageBox.question(
                self,
                tr("APP_NAME"),
                tr("RUNNER_EXISTS_WARNING", name=item_data['display_name']),
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )
            if reply == QMessageBox.StandardButton.No:
                return

            try:
                shutil.rmtree(runner_path)
            except Exception as e:
                QMessageBox.critical(self, tr("APP_NAME"), tr("REMOVE_RUNNER_ERROR", error=str(e)))
                return

        # Disable window during transfer
        self.setEnabled(False)
        self.progress_bar.setValue(0)

        def handle_transfer_finished(msg):
            self.progress_bar.setValue(100)
            self.setEnabled(True)
            QMessageBox.information(self, tr("APP_NAME"), msg)
            self.progress_bar.setValue(0)
        
        def handle_transfer_error(msg):
            QMessageBox.critical(self, tr("APP_NAME"), msg)
            self.setEnabled(True)
        
        def print_message(msg):
            print(msg)

        self.worker = TransferWorker(url, runner_folder_name, base_dir)
        self.worker.progress.connect(self.progress_bar.setValue)
        self.worker.message.connect(print_message)
        self.worker.finished.connect(handle_transfer_finished)
        self.worker.error.connect(handle_transfer_error)
        self.worker.start()

class AddInvocationDialog(QDialog):
    # Defining a custom signal that doesn't need arguments
    invocation_saved = pyqtSignal()

    def __init__(self, parent=None, invocation_data=None):
        super().__init__(parent)
        self.DEFAULT_PREFIX_NAME = "animarium_prefix"
        self.invocation_data = invocation_data

        if self.invocation_data:
            self.setWindowTitle(tr("MODIFY_INVOCATION"))
        else:
            self.setWindowTitle(tr("CREATE_INVOCATION"))

        self.resize(600, 400)

        self.main_layout = QGridLayout(self)

        self.name_label = QLabel(tr("INVOCATION_NAME"))
        self.name_input = QLineEdit()

        # Only connect update_prefix_path if it is "Add Invocation"
        if not self.invocation_data:
            self.name_input.textChanged.connect(self.update_prefix_path)

        self.main_layout.addWidget(self.name_label, 0, 0)
        self.main_layout.addWidget(self.name_input, 0, 1, 1, 2)

        self.runner_label = QLabel(tr("RUNNER_VERSION"))
        self.runner_input = QComboBox()
        self.populate_runners()
        self.main_layout.addWidget(self.runner_label, 1, 0)
        self.main_layout.addWidget(self.runner_input, 1, 1, 1, 2)

        self.exec_path_label = QLabel(tr("EXECUTABLE_PATH"))
        self.exec_path_input = QLineEdit()
        self.exec_button = QPushButton(tr("BROWSE_BUTTON"))
        self.exec_button.clicked.connect(self.select_executable)

        self.main_layout.addWidget(self.exec_path_label, 2, 0)
        self.main_layout.addWidget(self.exec_path_input, 2, 1)
        self.main_layout.addWidget(self.exec_button, 2, 2)

        self.prefix_path_label = QLabel(tr("PREFIX_PATH"))
        self.prefix_path_input = QLineEdit()
        self.prefix_path_input.setPlaceholderText(tr("ANIMARIUM_PREFIX_PLACEHOLDER"))
        self.prefix_button = QPushButton(tr("BROWSE_BUTTON"))
        self.prefix_button.clicked.connect(self.select_prefix)

        self.main_layout.addWidget(self.prefix_path_label, 3, 0)
        self.main_layout.addWidget(self.prefix_path_input, 3, 1)
        self.main_layout.addWidget(self.prefix_button, 3, 2)

        self.invocation_art_label = QLabel(tr("INVOCATION_ART_PATH"))
        self.invocation_art_input = QLineEdit()

        self.invocation_art_button = QPushButton(tr("BROWSE_BUTTON"))
        self.invocation_art_button.clicked.connect(self.select_invocation_art)

        self.main_layout.addWidget(self.invocation_art_label, 4, 0)
        self.main_layout.addWidget(self.invocation_art_input, 4, 1)
        self.main_layout.addWidget(self.invocation_art_button, 4, 2)

        self.invocation_gui_label = QLabel(tr("INVOCATION_GUI_PATH"))
        self.invocation_gui_input = QLineEdit()

        self.invocation_gui_button = QPushButton(tr("BROWSE_BUTTON"))
        self.invocation_gui_button.clicked.connect(self.select_invocation_gui)

        self.main_layout.addWidget(self.invocation_gui_label, 5, 0)
        self.main_layout.addWidget(self.invocation_gui_input, 5, 1)
        self.main_layout.addWidget(self.invocation_gui_button, 5, 2)

        self.language_label = QLabel(tr("INVOCATION_LANGUAGE"))
        self.language_input = QComboBox()
        self.language_input.addItems([tr("PLACEHOLDER_FOR_LANGUAGE")] + INVOCATION_LOCALE_OPTIONS)
        self.main_layout.addWidget(self.language_label, 6, 0)
        self.main_layout.addWidget(self.language_input, 6, 1, 1, 2)

        self.ms_language_code_checkbox = QCheckBox(tr("USE_MS_LANGUAGE_CODE"))
        self.ms_language_code_checkbox.setChecked(False)
        self.main_layout.addWidget(self.ms_language_code_checkbox, 7, 0, 1, 3)

        self.force_opengl_layout = QHBoxLayout()
        self.force_opengl_checkbox = QCheckBox(tr("FORCE_OPENGL"))
        self.force_opengl_checkbox.setChecked(False)
        self.main_layout.addWidget(self.force_opengl_checkbox, 8, 0, 1, 3)

        self.umu_checkbox = QCheckBox(tr("USE_UMU_LAUNCHER"))
        self.umu_checkbox.setChecked(False)
        self.main_layout.addWidget(self.umu_checkbox, 9, 0, 1, 3)

        self.umu_buttons_layout = QHBoxLayout()

        self.umu_info_button = QPushButton()
        self.umu_info_button.setIcon(QIcon.fromTheme("help-about"))
        self.umu_info_button.clicked.connect(self.show_umu_info)
        self.umu_buttons_layout.addWidget(self.umu_info_button)

        self.umu_search_button = QPushButton(tr("UMU_DATABASE_BUTTON"))
        self.umu_search_button.clicked.connect(self.open_umu_search)
        self.umu_buttons_layout.addWidget(self.umu_search_button)
        self.main_layout.addLayout(self.umu_buttons_layout, 9, 2)

        self.fps_layout = QHBoxLayout()
        self.show_fps_checkbox = QCheckBox(tr("SHOW_FPS_OPTION"))
        self.show_fps_checkbox.setChecked(False)
        self.fps_hud_combo = QComboBox()
        self.fps_hud_options = [("FPS_GALLIUM_HUD", tr("FPS_GALLIUM_HUD")), ("FPS_DXVK_HUD", tr("FPS_DXVK_HUD")), ("FPS_MANGOHUD", tr("FPS_MANGOHUD"))]
        self.fps_hud_combo.clear()
        for id, text in self.fps_hud_options:
            self.fps_hud_combo.addItem(text, id)  # Text is displayed, id is stored
        self.show_fps_checkbox.stateChanged.connect(self.update_fps_hud_state)
        self.fps_layout.addWidget(self.show_fps_checkbox)
        self.fps_layout.addWidget(self.fps_hud_combo)
        self.fps_hud_combo.setEnabled(False)
        self.main_layout.addLayout(self.fps_layout, 10, 0, 1, 3)

        self.env_vars_label = QLabel(tr("ENVIRONMENT_VARS"))
        self.env_vars_input = QLineEdit()
        self.main_layout.addWidget(self.env_vars_label, 11, 0)
        self.main_layout.addWidget(self.env_vars_input, 11, 1, 1, 2)

        self.invocation_args_label = QLabel(tr("INVOCATION_ARGS"))
        self.invocation_args_input = QLineEdit()
        self.main_layout.addWidget(self.invocation_args_label, 12, 0)
        self.main_layout.addWidget(self.invocation_args_input, 12, 1, 1, 2)

        self.buttons_layout = QHBoxLayout()

        self.remove_invocation_button = QPushButton(tr("REMOVE"))

        self.save_button = QPushButton(tr("SAVE_BUTTON"))
        self.save_button.clicked.connect(self.save_and_accept)

        # Add delete buttons only if the dialog is for editing
        if self.invocation_data:
            # Remove button
            self.buttons_layout.addWidget(self.remove_invocation_button)
            self.remove_invocation_button.clicked.connect(self.delete_invocation)
            # Winecfg button
            self.winecfg_button = QPushButton(tr("WINECFG_BUTTON"))
            self.buttons_layout.addWidget(self.winecfg_button)
            self.winecfg_button.clicked.connect(self.open_winecfg)

        self.buttons_layout.addStretch()
        self.buttons_layout.addWidget(self.save_button)

        self.main_layout.addLayout(self.buttons_layout, 13, 0, 1, 3)

        if self.invocation_data:
            self.load_invocation_data()

    def show_umu_info(self):
        QMessageBox.information(
            self,
            tr("APP_NAME"),
            tr("USE_UMU_LAUNCHER_INFO"))

    def open_umu_search(self):
        current_env_vars = self.env_vars_input.text()

        # Uses the selected runner; if empty, uses the default.
        runner_name = self.runner_input.currentText().strip()
        if runner_name == tr("PLACEHOLDER_FOR_RUNNER"):
            runner_name = ""

        dialog = UMUGameSearchDialog(self, runner_name, current_env_vars)
        if dialog.exec() == QDialog.DialogCode.Accepted:
            self.env_vars_input.setText(dialog.selected_env_vars)

    def keyPressEvent(self, event):
        if event.key() in (Qt.Key.Key_Return, Qt.Key.Key_Enter):
            # Prevents Enter from triggering something that is not selected
            return
        super().keyPressEvent(event)

    def update_fps_hud_state(self, state):
        self.fps_hud_combo.setEnabled(self.show_fps_checkbox.isChecked())

    def load_invocation_data(self):
        """Populates the form with invocation data for editing."""
        self.name_input.setText(self.invocation_data.get('name', ''))
        self.exec_path_input.setText(self.invocation_data.get('exec_path', ''))
        self.prefix_path_input.setText(self.invocation_data.get('prefix_path', ''))
        self.invocation_art_input.setText(self.invocation_data.get('art_path', ''))
        self.invocation_gui_input.setText(self.invocation_data.get('gui_path', ''))

        env_vars_text = self.invocation_data.get('env_vars', '').strip()
        self.env_vars_input.setText(env_vars_text)

        self.invocation_args_input.setText(self.invocation_data.get('invocation_args', ''))

        runner = self.invocation_data.get('runner', '')
        index_runner = self.runner_input.findText(runner)
        if index_runner != -1:
            self.runner_input.setCurrentIndex(index_runner)

        # Fix: Search for the full language string
        language = self.invocation_data.get('language', '')
        index_lang = self.language_input.findText(language)
        if index_lang != -1:
            self.language_input.setCurrentIndex(index_lang)

        use_ms_language_code = self.invocation_data.get("use_ms_language_code", False)
        self.ms_language_code_checkbox.setChecked(use_ms_language_code)

        force_opengl = self.invocation_data.get('force_opengl', False)
        self.force_opengl_checkbox.setChecked(force_opengl)

        use_umu = self.invocation_data.get('use_umu', False)
        self.umu_checkbox.setChecked(use_umu)

        show_fps = self.invocation_data.get('show_fps', False)
        self.show_fps_checkbox.setChecked(show_fps)
        self.update_fps_hud_state(Qt.CheckState.Checked if show_fps else Qt.CheckState.Unchecked)

        fps_hud_type = self.invocation_data.get('fps_hud_type', '')
        index_hud = self.fps_hud_combo.findData(fps_hud_type)  # Search by "id"
        if index_hud != -1:
            self.fps_hud_combo.setCurrentIndex(index_hud)

    def update_prefix_path(self, name):
        """Generates a default prefix path based on the invocation name."""
        invocation_dir = name.replace(" ", "_").lower()
        if invocation_dir:
            default_path = zordeer_dir / "invocation" / invocation_dir
            self.prefix_path_input.setText(str(default_path))

    def populate_runners(self):
        """Lists the available runner options and adds a warning if the runner chosen for the invocation is no longer available."""
        runners_path = zordeer_dir / "runner"
        runners_path.mkdir(parents=True, exist_ok=True)

        available_runners = sorted([d.name for d in runners_path.iterdir() if d.is_dir()], reverse=True)

        items = [tr("PLACEHOLDER_FOR_RUNNER")]

        # Add Wine only if wine command is found
        if shutil.which("wine"):
            items.append("Wine")

        items += available_runners

        # Adds the current runner with a warning if it's not available.
        if self.invocation_data:
            current_runner = self.invocation_data.get("runner", "")
            if current_runner and current_runner not in items:
                items.append(f"{current_runner} ({tr("UNAVAILABLE")})")

        self.runner_input.clear()
        self.runner_input.addItems(items)

        # Select the correct runner.
        if self.invocation_data:
            runner_to_select = self.invocation_data.get("runner", "")
            index = self.runner_input.findText(runner_to_select)
            if index == -1 and runner_to_select:
                index = self.runner_input.findText(f"{runner_to_select} ({tr("UNAVAILABLE")})")
            if index != -1:
                self.runner_input.setCurrentIndex(index)

    def select_executable(self):
        # Paths in order of priority
        drive_c = Path(self.prefix_path_input.text().strip()) / "drive_c"
        prefix = Path(self.prefix_path_input.text().strip())
        invocations = zordeer_dir / "invocation"

        # Choose the first one that exists
        start_dir = drive_c if drive_c.exists() else prefix if prefix.exists() else invocations

        file_path, _ = QFileDialog.getOpenFileName(
            self,
            tr("SELECT_EXECUTABLE"),
            str(start_dir),
            tr("EXECUTABLE_FILE_FILTER")
        )

        if file_path:
            self.exec_path_input.setText(file_path)

    def select_prefix(self):
        invocations_dir = zordeer_dir / "invocation"
        invocations_dir.mkdir(parents=True, exist_ok=True)

        dir_path = QFileDialog.getExistingDirectory(
            self,
            tr("SELECT_PREFIX_TITLE"),
            str(invocations_dir)
        )
        if dir_path:
            self.prefix_path_input.setText(dir_path)

    def select_invocation_art(self):
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            tr("SELECT_INVOCATION_ART"),
            str(home_dir),
            tr("IMAGE_FILTER"))
        if file_path:
            self.invocation_art_input.setText(file_path)

    def select_invocation_gui(self):
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            tr("SELECT_INVOCATION_GUI"),
            str(home_dir),
            tr("IMAGE_FILTER"))
        if file_path:
            self.invocation_gui_input.setText(file_path)

    def get_form_data(self):
        """Gets data from the form fields."""
        selected_runner = self.runner_input.currentText()
        if selected_runner == tr("PLACEHOLDER_FOR_RUNNER"):
            selected_runner = ""

        selected_lang = self.language_input.currentText()
        if selected_lang == tr("PLACEHOLDER_FOR_LANGUAGE"):
            selected_lang = ""

        env_vars_text = self.env_vars_input.text().strip()

        force_opengl = self.force_opengl_checkbox.isChecked()
        use_umu = self.umu_checkbox.isChecked()
        show_fps = self.show_fps_checkbox.isChecked()
        fps_hud_type = self.fps_hud_combo.currentData()  # Get the "id", not the text
        use_ms_language_code = self.ms_language_code_checkbox.isChecked()

        prefix_text = self.prefix_path_input.text().strip()
        if not prefix_text:  # If empty, use default
            prefix_text = str(zordeer_dir / "invocation" / self.DEFAULT_PREFIX_NAME)

        art_path = self.invocation_art_input.text().strip()
        gui_path = self.invocation_gui_input.text().strip()

        return {
            "name": self.name_input.text(),
            "runner": selected_runner,
            "exec_path": self.exec_path_input.text(),
            "prefix_path": prefix_text,
            "art_path": art_path,
            "gui_path": gui_path,
            "language": selected_lang,
            "use_ms_language_code": use_ms_language_code,
            "force_opengl": force_opengl,
            "use_umu": use_umu,
            "show_fps": show_fps,
            "fps_hud_type": fps_hud_type,
            "env_vars": env_vars_text,
            "invocation_args": self.invocation_args_input.text(),
        }

    def save_and_accept(self):
        """Validates fields, saves data to file, and updates paths if the name changes."""
        invocation_data = self.get_form_data()

        # Runner validation
        selected_runner = invocation_data.get("runner", "")
        if tr("UNAVAILABLE") in selected_runner:
            reply = QMessageBox.question(
                self,
                tr("APP_NAME"),
                tr("SELECT_AVAILABLE_RUNNER_CONFIRM"),
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )
            if reply == QMessageBox.StandardButton.No:
                return

        old_safe_name = ""
        if self.invocation_data:
            old_safe_name = self.invocation_data.get('name', '').replace(" ", "_").lower()

        required_fields = ["name"]
        if all(invocation_data.get(field) for field in required_fields):
            prefix_path = Path(invocation_data["prefix_path"])
            if not prefix_path.exists():
                try:
                    prefix_path.mkdir(parents=True, exist_ok=True)
                except Exception:
                    pass

            art_dir = zordeer_dir / "art"
            gui_dir = zordeer_dir / "art" / "gui"

            try:
                art_dir.mkdir(parents=True, exist_ok=True)
                gui_dir.mkdir(parents=True, exist_ok=True)
            except Exception:
                pass

            # Normalize name
            safe_invocation_name = invocation_data["name"].replace(" ", "_").lower()
            invocation_file_path = zordeer_config_dir / f"invocation-info-{safe_invocation_name}.toml"

            # Check for duplicate invocation name
            if (
                invocation_file_path.exists() and
                (not self.invocation_data or self.invocation_data.get("name", "").lower() != invocation_data["name"].lower())
            ):
                QMessageBox.warning(
                    self,
                    tr("APP_NAME"),
                    tr("INVOCATION_ALREADY_EXISTS")
                )
                return

            # Handle artwork
            safe_invocation_name = invocation_data["name"].replace(" ", "_").lower()

            # art_path
            if invocation_data.get("art_path"):
                art_path = Path(invocation_data["art_path"])
                if art_path.exists() and art_path.is_file():
                    # Remove old images with old name only if we're selecting a NEW file
                    if self.invocation_data and self.invocation_data.get("art_path"):
                        old_art_path = Path(self.invocation_data['art_path'])
                        # Only remove if the new file is different from the old one
                        if old_art_path != art_path:
                            old_safe_name = self.invocation_data.get('name', '').replace(" ", "_").lower()
                            for old_file in art_dir.glob(f"{old_safe_name}.*"):
                                try:
                                    old_file.unlink()
                                except Exception:
                                    pass

                    # Copy new image only if it's not already in the art_dir
                    if art_path.parent != art_dir:
                        art_extension = art_path.suffix.lower()
                        new_art_path = art_dir / f"{safe_invocation_name}{art_extension}"
                        try:
                            shutil.copyfile(art_path, new_art_path)
                            invocation_data["art_path"] = str(new_art_path)
                        except Exception:
                            invocation_data["art_path"] = ""
                    else:
                        # File is already in art_dir, just update the path with new name if needed
                        if self.invocation_data:
                            old_safe_name = self.invocation_data.get('name', '').replace(" ", "_").lower()
                            if old_safe_name != safe_invocation_name:
                                new_art_path = art_dir / f"{safe_invocation_name}{art_path.suffix.lower()}"
                                try:
                                    art_path.rename(new_art_path)
                                    invocation_data["art_path"] = str(new_art_path)
                                except Exception:
                                    invocation_data["art_path"] = str(art_path)
            elif self.invocation_data and self.invocation_data.get("art_path"):
                # User removed the art path - delete old file
                old_art_path = Path(self.invocation_data['art_path'])
                if old_art_path.exists() and old_art_path.is_file() and old_art_path.parent == art_dir:
                    try:
                        old_art_path.unlink()
                    except Exception:
                        pass
                invocation_data["art_path"] = ""

            # gui_path
            if invocation_data.get("gui_path"):
                gui_path = Path(invocation_data["gui_path"])
                if gui_path.exists() and gui_path.is_file():
                    # Remove old images with old name only if we're selecting a NEW file
                    if self.invocation_data and self.invocation_data.get("gui_path"):
                        old_gui_path = Path(self.invocation_data['gui_path'])
                        # Only remove if the new file is different from the old one
                        if old_gui_path != gui_path:
                            old_safe_name = self.invocation_data.get('name', '').replace(" ", "_").lower()
                            for old_file in gui_dir.glob(f"{old_safe_name}.*"):
                                try:
                                    old_file.unlink()
                                except Exception:
                                    pass

                    # Copy new image only if it's not already in the gui_dir
                    if gui_path.parent != gui_dir:
                        gui_extension = gui_path.suffix.lower()
                        new_gui_path = gui_dir / f"{safe_invocation_name}{gui_extension}"
                        try:
                            shutil.copyfile(gui_path, new_gui_path)
                            invocation_data["gui_path"] = str(new_gui_path)
                        except Exception:
                            invocation_data["gui_path"] = ""
                    else:
                        # File is already in gui_dir, just update the path with new name if needed
                        if self.invocation_data:
                            old_safe_name = self.invocation_data.get('name', '').replace(" ", "_").lower()
                            if old_safe_name != safe_invocation_name:
                                new_gui_path = gui_dir / f"{safe_invocation_name}{gui_path.suffix.lower()}"
                                try:
                                    gui_path.rename(new_gui_path)
                                    invocation_data["gui_path"] = str(new_gui_path)
                                except Exception:
                                    invocation_data["gui_path"] = str(gui_path)
            elif self.invocation_data and self.invocation_data.get("gui_path"):
                # User removed the gui path - delete old file
                old_gui_path = Path(self.invocation_data['gui_path'])
                if old_gui_path.exists() and old_gui_path.is_file() and old_gui_path.parent == gui_dir:
                    try:
                        old_gui_path.unlink()
                    except Exception:
                        pass
                invocation_data["gui_path"] = ""

            # Handle prefix folder rename if it's safe
            if self.invocation_data:
                old_prefix_path = Path(self.invocation_data.get('prefix_path', '')).resolve()
                current_prefix_path = Path(invocation_data.get('prefix_path', '')).resolve()
                old_exec_path = Path(self.invocation_data.get('exec_path', '')).resolve() if self.invocation_data.get('exec_path') else None

                # Only attempt rename if the user has not manually changed the prefix
                if old_prefix_path == current_prefix_path:
                    # Only rename if the folder exists and its name matches the old invocation name
                    if old_prefix_path.exists() and old_prefix_path.name.lower() == old_safe_name:
                        used_by_other = False
                        # Check if any other invocation is using the same prefix folder
                        for f in zordeer_config_dir.glob("invocation-info-*.toml"):
                            old_inv_file = zordeer_config_dir / f"invocation-info-{old_safe_name}.toml"
                            if f == old_inv_file:
                                continue  # Skip the current invocation file
                            try:
                                with open(f, encoding="utf-8") as tf:
                                    data = toml.load(tf)
                                    other_prefix = Path(data.get('prefix_path', '')).resolve()
                                    other_exec = Path(data.get('exec_path', '')).resolve() if data.get('exec_path') else None

                                    # Block rename if:
                                    # - Another invocation uses the same prefix folder
                                    # - Another invocation has an executable inside this prefix
                                    if (
                                        other_prefix == old_prefix_path or
                                        (other_exec and other_exec.is_relative_to(old_prefix_path))
                                    ):
                                        used_by_other = True
                                        break
                            except Exception:
                                pass  # Ignore any errors reading other invocation files

                        # Rename the prefix folder if no other invocation is using it
                        if not used_by_other:
                            # Skip rename prompt if the invocation name didn't actually change
                            if safe_invocation_name == old_safe_name:
                                invocation_data["prefix_path"] = str(old_prefix_path)
                            else:
                                reply = QMessageBox.question(
                                    self,
                                    tr("APP_NAME"),
                                    tr("RENAME_PREFIX_QUESTION", old=self.invocation_data.get("name", old_safe_name), new=invocation_data.get("name", safe_invocation_name)),
                                    QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                                    QMessageBox.StandardButton.No
                                )

                                if reply == QMessageBox.StandardButton.Yes:
                                    new_prefix_path = old_prefix_path.parent / safe_invocation_name
                                    try:
                                        old_prefix_path.rename(new_prefix_path)
                                        invocation_data["prefix_path"] = str(new_prefix_path)

                                        # Update exec_path if it's inside the old prefix folder
                                        if old_exec_path and old_exec_path.is_relative_to(old_prefix_path):
                                            relative_exec = old_exec_path.relative_to(old_prefix_path)
                                            new_exec_path = new_prefix_path / relative_exec
                                            invocation_data["exec_path"] = str(new_exec_path)

                                    except Exception:
                                        # Keep old path if rename fails
                                        invocation_data["prefix_path"] = str(old_prefix_path)
                                else:
                                    invocation_data["prefix_path"] = str(old_prefix_path)
                        else:
                            # Another invocation is using this prefix, keep current path
                            invocation_data["prefix_path"] = str(old_prefix_path)
                    else:
                        # Folder name doesn't match old invocation name, keep current path
                        invocation_data["prefix_path"] = str(old_prefix_path)
                else:
                    # User manually changed the prefix, do not rename
                    invocation_data["prefix_path"] = str(current_prefix_path)

            # Prevents the text "UNAVAILABLE" from being added to the saved runner's name.
            runner_value = invocation_data.get("runner", "")
            unavailable_text = f" ({tr("UNAVAILABLE")})"
            if unavailable_text in runner_value:
                invocation_data["runner"] = runner_value.replace(unavailable_text, "")

            # Save TOML
            try:
                with open(invocation_file_path, 'w', encoding="utf-8") as tf:
                    toml.dump(invocation_data, tf)
            except Exception as e:
                print(e)
                QMessageBox.critical(
                    self,
                    tr("APP_NAME"),
                    tr("NAME_INVALID", error=str(e))
                )
                return  # The old TOML remains intact.

            # Remove old TOML only if name changed
            if self.invocation_data:
                old_safe_name = self.invocation_data.get('name', '').replace(" ", "_").lower()
                new_safe_name = safe_invocation_name
                if old_safe_name != new_safe_name:
                    old_invocation_file_path = zordeer_config_dir / f"invocation-info-{old_safe_name}.toml"
                    if old_invocation_file_path.exists():
                        old_invocation_file_path.unlink()

            # Emit signal and close
            self.invocation_saved.emit()
            self.accept()
        else:
            QMessageBox.warning(self, tr("CREATE_INVOCATION"), tr("MANDATORY_FIELD_ERROR"))

    def delete_invocation(self):
        """Removes the invocation and optionally its data/prefix."""
        invocation_name = self.name_input.text().strip()

        # Confirmation dialog with checkbox
        msg = QMessageBox(self)
        msg.setIcon(QMessageBox.Icon.Warning)
        msg.setWindowTitle(tr("REMOVE"))
        msg.setText(tr("DELETE_INVOCATION_CONFIRM_MESSAGE", name=invocation_name))
        msg.setStandardButtons(QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)

        msg.button(QMessageBox.StandardButton.Yes).setText(tr("YES_BUTTON"))
        msg.button(QMessageBox.StandardButton.No).setText(tr("NO_BUTTON"))

        delete_data_cb = QCheckBox(tr("DELETE_PREFIX_CHECKBOX"))
        msg.setCheckBox(delete_data_cb)

        if msg.exec() != QMessageBox.StandardButton.Yes:
            return

        # Path to the TOML file
        safe_name = invocation_name.replace(" ", "_").lower()
        invocation_file = zordeer_config_dir / f"invocation-info-{safe_name}.toml"

        if not invocation_file.exists():
            QMessageBox.critical(self, tr("APP_NAME"), tr("INVOCATION_INFO_ERROR"))
            return

        # Load data
        with open(invocation_file, encoding='utf-8') as f:
            invocation_data = toml.load(f)

        prefix_path = invocation_data.get('prefix_path')
        prefix_in_use_by_others = []

        # Checks if the prefix is ​​being used by other invocations
        if prefix_path:
            for f in zordeer_config_dir.glob("invocation-info-*.toml"):
                if f == invocation_file:
                    continue
                try:
                    with open(f, encoding="utf-8") as toml_file:
                        data = toml.load(toml_file)
                        other_prefix = data.get('prefix_path')
                        if other_prefix and Path(other_prefix).resolve() == Path(prefix_path).resolve():
                            prefix_in_use_by_others.append(data.get('name', 'Unknown'))
                except Exception:
                    pass

        # If the user marked for deletion and the prefix is ​​in use
        if delete_data_cb.isChecked() and prefix_in_use_by_others:
            dialog = QDialog(self)
            dialog.setWindowTitle(tr("REMOVE"))
            dialog.resize(400, 300)
            layout = QVBoxLayout(dialog)

            # Main message
            msg_label = QLabel(tr("PREFIX_IN_USE_MESSAGE"))
            msg_label.setWordWrap(True)
            layout.addWidget(msg_label)

            # QTreeWidget to show affected invocations
            tree_widget = QTreeWidget()
            tree_widget.setHeaderLabels([tr("PREFIX_REMOTION_INFORMATION")])
            tree_widget.setColumnCount(1)
            tree_widget.setRootIsDecorated(True)
            tree_widget.setSelectionMode(QTreeWidget.SelectionMode.NoSelection)

            # Prefix that would be removed
            prefix_item = QTreeWidgetItem([prefix_path])
            tree_widget.addTopLevelItem(prefix_item)

            # Affected invocations
            affected_item = QTreeWidgetItem([tr("AFFECTED_INVOCATIONS")])
            prefix_item.addChild(affected_item)

            # Invocations that use this prefix
            for inv in prefix_in_use_by_others:
                inv_item = QTreeWidgetItem([inv])
                affected_item.addChild(inv_item)

            # Expands by default to be visible
            tree_widget.expandAll()

            layout.addWidget(tree_widget)

            # Radiobuttons
            keep_radio = QRadioButton(tr("DO_NOT_DELETE_PREFIX"))
            force_radio = QRadioButton(tr("DELETE_PREFIX_ANYWAY"))
            keep_radio.setChecked(True)
            layout.addWidget(keep_radio)
            layout.addWidget(force_radio)

            # Confirm button
            buttons_layout = QHBoxLayout()
            confirm_button = QPushButton(tr("CONFIRM"))
            buttons_layout.addWidget(confirm_button)
            layout.addLayout(buttons_layout)

            confirm_button.clicked.connect(dialog.accept)

            if dialog.exec() != QDialog.DialogCode.Accepted:
                return

            if keep_radio.isChecked():
                delete_data_cb.setChecked(False)

        # Remove TOML
        invocation_file.unlink()

        # Remove prefix if checkbox is checked
        if delete_data_cb.isChecked():
            if prefix_path:
                prefix_path_obj = Path(prefix_path)
                if prefix_path_obj.exists() and prefix_path_obj.is_dir():
                    try:
                        shutil.rmtree(prefix_path_obj)
                    except Exception:
                        pass

        # Remove artwork if it exists
        art = invocation_data.get('art_path')
        if art:
            art_path = Path(art)
            if art_path.exists() and art_path.is_file():
                try:
                    art_path.unlink()
                except Exception:
                    pass

        # Remove gui icon if it exists
        gui = invocation_data.get('gui_path')
        if gui:
            gui_path = Path(gui)
            if gui_path.exists() and gui_path.is_file():
                try:
                    gui_path.unlink()
                except Exception:
                    pass

        # Refresh the list and close
        self.parent().load_invocations()
        self.accept()

    def open_winecfg(self):
        prefix_path = Path(self.prefix_path_input.text().strip())
        if not prefix_path.exists():
            QMessageBox.warning(self, tr("APP_NAME"), tr("INVALID_PREFIX_ERROR"))
            return

        selected_runner = self.runner_input.currentText().strip()

        # Avoid problems with unavailable runners.
        unavailable_text = f" ({tr("UNAVAILABLE")})"
        if unavailable_text in selected_runner:
            selected_runner = selected_runner.replace(unavailable_text, "")

        # Default runner
        if selected_runner == tr("PLACEHOLDER_FOR_RUNNER") or selected_runner == "PLACEHOLDER_FOR_RUNNER":
            runner_name = load_settings()["other"].get("default_runner", "").strip()

            if not runner_name or runner_name.lower() == "indefinite":
                QMessageBox.warning(self, tr("APP_NAME"), tr("DEFAULT_RUNNER_INDEFINITE"))
                return
        else:
            runner_name = selected_runner

        if runner_name.lower() != "wine":
            runners_path = zordeer_dir / "runner"
            proton_script = runners_path / runner_name / "proton"

            # Warning if the Proton runner does not exist
            if not proton_script.exists():
                QMessageBox.critical(
                    self,
                    tr("APP_NAME"),
                    tr("ERROR_RUNNER", path=str(proton_script.parent)))
                return

        env = os.environ.copy()

        # Warns if the Wine runner does not exist, and runs winecfg in the selected runner.
        if runner_name.lower() == "wine":
            wine_path = shutil.which("wine")
            if not wine_path:
                QMessageBox.critical(self, tr("APP_NAME"), tr("WINE_NOT_FOUND"))
                return
            cmd = [wine_path, "winecfg"]
            env["WINEPREFIX"] = str(prefix_path)
        else:
            cmd = [str(proton_script), "run", "winecfg"]
            env["STEAM_COMPAT_DATA_PATH"] = str(prefix_path)
            env["STEAM_COMPAT_CLIENT_INSTALL_PATH"] = str(zordeer_dir / ".steam" / "steam")
            env["STEAM_EXTRA_COMPAT_TOOLS_PATHS"] = str(proton_script.parent)

        subprocess.Popen(cmd, env=env)

class UMUGameSearchDialog(QDialog):
    def __init__(self, parent=None, runner_name="", current_env_vars=""):
        super().__init__(parent)
        self.runner_name = runner_name
        self.current_env_vars = current_env_vars
        self.setWindowTitle(tr("UMU_DATABASE"))
        self.resize(500, 300)

        self.main_layout = QVBoxLayout(self)

        # Search bar
        self.search_input = QLineEdit()
        self.search_input.setPlaceholderText(tr("SEARCH"))
        self.search_input.textChanged.connect(self.search_games)
        self.main_layout.addWidget(self.search_input)

        # Game list
        self.tree_widget = QTreeWidget()
        self.tree_widget.setHeaderLabels([tr("GAME_NAME"), tr("STORE")])
        self.tree_widget.setColumnCount(2)

        # Column size
        self.tree_widget.setColumnWidth(0, 350)
        self.tree_widget.setColumnWidth(1, 120)

        self.main_layout.addWidget(self.tree_widget)

        # Add button
        self.buttons_layout = QHBoxLayout()
        self.add_button = QPushButton(tr("ADD_VARIABLES_BUTTON"))
        self.add_button.clicked.connect(self.add_selected)
        self.buttons_layout.addStretch()
        self.buttons_layout.addWidget(self.add_button)

        self.main_layout.addLayout(self.buttons_layout)

        self.should_show = self.pre_validate()

        if not self.should_show:
            self.deleteLater()

    # Perform all checks before displaying the window.
    def pre_validate(self):
        # If runner is empty, use the default runner.
        if not self.runner_name:
            settings = load_settings()
            self.runner_name = settings["other"].get("default_runner", "").strip()

        # Verification for runner "indefinite"
        if not self.runner_name or self.runner_name.lower() == "indefinite":
            QMessageBox.warning(self.parent(), tr("APP_NAME"), tr("DEFAULT_RUNNER_INDEFINITE"))
            return False

        # Verification for runner "Wine"
        if self.runner_name.lower() == "wine":
            QMessageBox.information(self.parent(), tr("APP_NAME"), tr("UMU_DATABASE_WINE_NOT_SUPPORTED"))
            return False

        csv_path = zordeer_dir / "runner" / self.runner_name / "protonfixes" / "umu-database.csv"

        if not csv_path.exists():
            QMessageBox.warning(self.parent(), tr("APP_NAME"), tr("UMU_DATABASE_NOT_FOUND", path=str(csv_path)))
            return False

        # Try loading the data.
        try:
            self.games_data = []
            with open(csv_path, 'r', encoding='utf-8') as f:
                reader = csv.reader(f)
                next(reader, None)  # Ignore header "TITLE,STORE,CODENAME,UMU_ID"

                for row in reader:
                    if len(row) >= 4:  # It needs to have a name, store, codename, and UMU_ID.
                        self.games_data.append({
                            'name': row[0],
                            'store': row[1],
                            'umu_id': row[3]  # Fourth column = UMU_ID
                        })
            # Load the list
            self.search_games()
            return True
        except Exception as e:
            QMessageBox.critical(self.parent(), tr("APP_NAME"), tr("UMU_DATABASE_LOAD_ERROR", error=str(e)))
            return False

    # Override the exec command to prevent the window from opening if the validations are not passed.
    def exec(self):
        if not self.should_show:
            return QDialog.DialogCode.Rejected
        # Call search_games to ensure the list is populated
        if hasattr(self, 'games_data'):
            self.search_games()
        return super().exec()

    # Override the show to prevent the window from opening if validations are not passed.
    def show(self):
        if not self.should_show:
            return
        # Call search_games to ensure the list is populated
        if hasattr(self, 'games_data'):
            self.search_games()
        super().show()

    def keyPressEvent(self, event):
        if event.key() in (Qt.Key.Key_Return, Qt.Key.Key_Enter):
            self.add_selected()
            return
        super().keyPressEvent(event)

    # It filters games based on the search text and selects them automatically.
    def search_games(self):
        if not hasattr(self, 'games_data') or not self.games_data:
            return

        search_text = self.search_input.text().lower().strip()
        self.tree_widget.clear()

        filtered_games = []
        for game in self.games_data:
            if not search_text or search_text in game['name'].lower():
                filtered_games.append(game)

        # Add filtered games
        for game in filtered_games:
            item = QTreeWidgetItem([game['name'], game['store']])
            item.setData(0, Qt.ItemDataRole.UserRole, game['umu_id'])
            item.setData(1, Qt.ItemDataRole.UserRole, game['store'])
            self.tree_widget.addTopLevelItem(item)

        # Selects automatically
        if filtered_games:
            first_item = self.tree_widget.topLevelItem(0)
            if first_item:
                self.tree_widget.setCurrentItem(first_item)
                first_item.setSelected(True)

    # Adds the selected game to the environment variables.
    def add_selected(self):
        selected_items = self.tree_widget.selectedItems()
        if not selected_items:
            first_item = self.tree_widget.topLevelItem(0)
            if first_item:
                selected_items = [first_item]
            else:
                QMessageBox.warning(self, tr("APP_NAME"), tr("NO_GAME_SELECTED_ERROR"))
                return

        item = selected_items[0]
        umu_id = item.data(0, Qt.ItemDataRole.UserRole)
        store = item.data(1, Qt.ItemDataRole.UserRole)

        if umu_id and store:
            new_vars = f"GAMEID={umu_id} STORE={store}"

            if self.current_env_vars.strip():
                env_vars_text = f"{self.current_env_vars} {new_vars}"
            else:
                env_vars_text = new_vars

            self.selected_env_vars = env_vars_text
            self.accept()

class MultipleCreateInvocationsDialog(QDialog):
    invocations_saved = pyqtSignal()

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle(tr("MULTIPLE_INVOCATION_CREATOR"))
        self.resize(700, 500)

        self.main_layout = QVBoxLayout(self)

        # Runner and Language layout (grid)
        top_grid = QGridLayout()

        # Runner
        runner_label = QLabel(tr("RUNNER_VERSION"))
        self.runner_combo = QComboBox()
        self.populate_runners()
        top_grid.addWidget(runner_label, 0, 0)
        top_grid.addWidget(self.runner_combo, 0, 1)

        # Language and combobox
        language_label = QLabel(tr("INVOCATION_LANGUAGE"))
        self.language_input = QComboBox()
        self.language_input.addItems([tr("PLACEHOLDER_FOR_LANGUAGE")] + INVOCATION_LOCALE_OPTIONS)
        top_grid.addWidget(language_label, 1, 0)
        top_grid.addWidget(self.language_input, 1, 1)

        self.main_layout.addLayout(top_grid)

        # Checkbox animarium_prefix
        self.animarium_prefix_cb = QCheckBox(tr("USE_ANIMARIUM_PREFIX_FOR_ALL"))
        self.main_layout.addWidget(self.animarium_prefix_cb)

        self.auto_prefix_cb = QCheckBox(tr("USE_AUTO_PREFIX_FOR_ALL"))
        self.main_layout.addWidget(self.auto_prefix_cb)

        self.animarium_prefix_cb.stateChanged.connect(
            partial(QCheckBox.setDisabled, self.auto_prefix_cb)
        )

        self.auto_prefix_cb.stateChanged.connect(
            partial(QCheckBox.setDisabled, self.animarium_prefix_cb)
        )

        # TreeWidget for multiple invocations
        self.file_list = QTreeWidget()
        self.file_list.setColumnCount(1)
        self.file_list.setHeaderHidden(True)
        self.file_list.setExpandsOnDoubleClick(True)
        self.main_layout.addWidget(self.file_list)

        # Add/Remove File Buttons
        btn_layout = QHBoxLayout()
        self.add_files_button = QPushButton(tr("ADD_FILES"))
        self.add_files_button.clicked.connect(self.add_files)
        self.remove_item_button = QPushButton(tr("REMOVE_SELECTED"))
        self.remove_item_button.clicked.connect(self.remove_selected_item)
        btn_layout.addWidget(self.add_files_button)
        btn_layout.addWidget(self.remove_item_button)
        self.main_layout.addLayout(btn_layout)

        # Save button
        save_layout = QHBoxLayout()
        self.save_button = QPushButton(tr("SAVE_BUTTON"))
        self.save_button.clicked.connect(self.save_multiple)
        save_layout.addStretch()
        save_layout.addWidget(self.save_button)
        self.main_layout.addLayout(save_layout)

        self.paths = []

    # Utility functions

    def keyPressEvent(self, event):
        if event.key() in (Qt.Key.Key_Return, Qt.Key.Key_Enter):
            # Prevents Enter from triggering something that is not selected
            return
        super().keyPressEvent(event)

    def populate_runners(self):
        runners_path = zordeer_dir / "runner"
        runners_path.mkdir(parents=True, exist_ok=True)
        runners = [d.name for d in runners_path.iterdir() if d.is_dir()]

        self.runner_combo.clear()

        items = [tr("PLACEHOLDER_FOR_RUNNER")]

        if shutil.which("wine"):
            items.append("Wine")

        items += sorted(runners, reverse=True)

        self.runner_combo.addItems(items)

    def add_files(self):
        files, _ = QFileDialog.getOpenFileNames(self, tr("SELECT_EXECUTABLE"), "", tr("EXECUTABLE_FILE_FILTER"))
        for f in files:
            self.add_file_item(f)

    def remove_selected_item(self):
        selected = self.file_list.currentItem()
        if selected and hasattr(selected, "path"):
            index = self.file_list.indexOfTopLevelItem(selected)
            self.file_list.takeTopLevelItem(index)
            self.paths.remove(selected.path)

    def add_file_item(self, path):
        if path in self.paths:
            return
        self.paths.append(path)

        # Internal widget for options
        item_widget = QWidget()
        layout = QVBoxLayout(item_widget)
        layout.setContentsMargins(2, 2, 2, 2)
        layout.setSpacing(4)

        # Invocation name
        name_layout = QHBoxLayout()
        name_label = QLabel(tr("INVOCATION_NAME"))
        name_input = QLineEdit(Path(path).stem)
        name_layout.addWidget(name_label)
        name_layout.addWidget(name_input)
        layout.addLayout(name_layout)

        # Prefix
        prefix_layout = QHBoxLayout()
        prefix_label = QLabel(tr("PREFIX_PATH"))
        prefix_input = QLineEdit(str(zordeer_dir / "invocation" / Path(path).stem.replace(" ", "_").lower()))
        prefix_button = QPushButton(tr("BROWSE_BUTTON"))
        prefix_layout.addWidget(prefix_label)
        prefix_layout.addWidget(prefix_input)
        prefix_layout.addWidget(prefix_button)
        layout.addLayout(prefix_layout)

        def update_prefix_from_name(text):
            new_text = text.replace(" ", "_").lower()
            new_path = zordeer_dir / "invocation" / new_text
            prefix_input.setText(str(new_path))

        name_input.textChanged.connect(update_prefix_from_name)
        prefix_button.clicked.connect(
            partial(self.select_prefix_folder, prefix_input))

        # Checkboxes
        ms_lang_cb = QCheckBox(tr("USE_MS_LANGUAGE_CODE"))
        ms_lang_cb.setChecked(False)
        layout.addWidget(ms_lang_cb)

        force_opengl_cb = QCheckBox(tr("FORCE_OPENGL"))
        force_opengl_cb.setChecked(False)
        layout.addWidget(force_opengl_cb)

        umu_cb = QCheckBox(tr("USE_UMU_LAUNCHER"))
        umu_cb.setChecked(False)
        layout.addWidget(umu_cb)

        # FPS HUD
        fps_layout = QHBoxLayout()
        show_fps_cb = QCheckBox(tr("SHOW_FPS_OPTION"))
        fps_hud_combo = QComboBox()
        fps_hud_options = [
            ("FPS_GALLIUM_HUD", tr("FPS_GALLIUM_HUD")),
            ("FPS_DXVK_HUD", tr("FPS_DXVK_HUD")),
            ("FPS_MANGOHUD", tr("FPS_MANGOHUD"))
        ]
        for id, text in fps_hud_options:
            fps_hud_combo.addItem(text, id)
        fps_hud_combo.setEnabled(False)
        show_fps_cb.stateChanged.connect(partial(QComboBox.setEnabled, fps_hud_combo))
        fps_layout.addWidget(show_fps_cb)
        fps_layout.addWidget(fps_hud_combo)
        layout.addLayout(fps_layout)

        # QTreeWidgetItem with child containing widget
        parent_item = QTreeWidgetItem(self.file_list)
        parent_item.setText(0, Path(path).name)
        child_item = QTreeWidgetItem(parent_item)
        child_item.setFlags(child_item.flags() & ~Qt.ItemFlag.ItemIsSelectable)
        self.file_list.setItemWidget(child_item, 0, item_widget)
        parent_item.setExpanded(True)

        # Save references
        parent_item.path = path
        parent_item.name_input = name_input
        parent_item.prefix_input = prefix_input
        parent_item.ms_lang_cb = ms_lang_cb
        parent_item.force_opengl_cb = force_opengl_cb
        parent_item.umu_cb = umu_cb
        parent_item.show_fps_cb = show_fps_cb
        parent_item.fps_hud_combo = fps_hud_combo

    def select_prefix_folder(self, line_edit: QLineEdit):
        dir_path = QFileDialog.getExistingDirectory(
            self,
            tr("SELECT_PREFIX_TITLE"),
            str(zordeer_dir / "invocation")
        )
        if dir_path:
            line_edit.setText(dir_path)

    def save_multiple(self):
        # Runner and item validation
        runner = self.runner_combo.currentText()
        if self.file_list.topLevelItemCount() == 0:
            QMessageBox.warning(self, tr("CREATE_INVOCATION"), tr("MANDATORY_FIELDS_ERROR"))
            return

        # If the user does not select a runner, it will be saved as empty.
        if runner == tr("PLACEHOLDER_FOR_RUNNER"):
            runner = ""

        art_dir = zordeer_dir / "art"
        gui_dir = zordeer_dir / "art" / "gui"
        art_dir.mkdir(parents=True, exist_ok=True)
        gui_dir.mkdir(parents=True, exist_ok=True)

        # Name and duplicate validation
        existing_names = set()
        for i in range(self.file_list.topLevelItemCount()):
            item = self.file_list.topLevelItem(i)
            name = item.name_input.text().strip()

            # Empty name
            if not name:
                QMessageBox.warning(self, tr("APP_NAME"), tr("MANDATORY_FIELDS_ERROR"))
                return

            safe_name = name.replace(" ", "_").lower()

            # Duplicate in own list
            if safe_name in existing_names:
                QMessageBox.warning(
                    self,
                    tr("APP_NAME"),
                    tr("DUPLICATE_NAME_IN_LIST", name=name)
                )
                return
            existing_names.add(safe_name)

            # Duplicate in filesystem
            test_path = zordeer_config_dir / f"invocation-info-{safe_name}.toml"
            if test_path.exists():
                QMessageBox.warning(
                    self,
                    tr("APP_NAME"),
                    tr("INVOCATION_IN_MULTIPLE_CREATE_ALREADY_EXISTS", name=name)
                )
                return

            # Test if you can write the file
            try:
                with open(test_path, 'w', encoding="utf-8") as f:
                    toml.dump({}, f)
                test_path.unlink()
            except Exception as e:
                QMessageBox.critical(
                    self,
                    tr("APP_NAME"),
                    tr("NAME_INVALID_IN_MULTIPLE", name=name, error=str(e))
                )
                return

        selected_lang = self.language_input.currentText()
        if selected_lang == tr("PLACEHOLDER_FOR_LANGUAGE"):
            selected_lang = ""

        for i in range(self.file_list.topLevelItemCount()):
            item = self.file_list.topLevelItem(i)
            name = item.name_input.text().strip()
            safe_name = name.replace(" ", "_").lower()
            file_path = zordeer_config_dir / f"invocation-info-{safe_name}.toml"

            # Determine prefix
            if self.auto_prefix_cb.isChecked():
                prefix_path = Path(item.path)
                while prefix_path != prefix_path.parent:
                    if prefix_path.name.lower() == "drive_c":
                        prefix_path = prefix_path.parent
                        break
                    prefix_path = prefix_path.parent
                else:
                    # If you can't find 'drive_c', use the manual prefix
                    prefix_path = Path(item.prefix_input.text())
                prefix_path.mkdir(parents=True, exist_ok=True)
            elif self.animarium_prefix_cb.isChecked():
                prefix_path = zordeer_dir / "invocation" / "animarium_prefix"
                prefix_path.mkdir(parents=True, exist_ok=True)
            else:
                prefix_path = Path(item.prefix_input.text())
                prefix_path.mkdir(parents=True, exist_ok=True)

            # Save TOML
            try:
                with open(file_path, 'w', encoding="utf-8") as f:
                    toml.dump({
                        "name": name,
                        "runner": runner,
                        "exec_path": item.path,
                        "prefix_path": str(prefix_path),
                        "art_path": "",
                        "gui_path": "",
                        "language": selected_lang,
                        "use_ms_language_code": item.ms_lang_cb.isChecked(),
                        "force_opengl": item.force_opengl_cb.isChecked(),
                        "use_umu": item.umu_cb.isChecked(),
                        "show_fps": item.show_fps_cb.isChecked(),
                        "fps_hud_type": item.fps_hud_combo.currentData() or "",
                        "env_vars": "",
                        "invocation_args": ""
                    }, f)
            except Exception as e:
                QMessageBox.critical(self, tr("APP_NAME"), tr("FAILED_UPDATE_TOML", error=str(e)))
                return

        self.invocations_saved.emit()
        self.accept()

    def save_invocation_data(self, data):
        safe_name = data["name"].replace(" ", "_").lower()
        file_path = zordeer_config_dir / f"invocation-info-{safe_name}.toml"
        if file_path.exists():
            return
        with open(file_path, 'w', encoding="utf-8") as f:
            toml.dump(data, f)

class MultipleRemoveInvocationDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle(tr("MULTIPLE_INVOCATION_REMOVER"))
        self.resize(340, 400)
        self.parent_ref = parent

        self.main_layout = QVBoxLayout(self)

        # Search bar
        self.search_input = QLineEdit()
        self.search_input.setPlaceholderText(tr("SEARCH"))
        self.search_input.textChanged.connect(self.update_invocation_list)
        self.main_layout.addWidget(self.search_input)

        # Scroll area with invocations
        self.scroll_area = QScrollArea()
        self.scroll_area.setWidgetResizable(True)
        self.scroll_content = QWidget()
        self.scroll_layout = QVBoxLayout(self.scroll_content)
        self.scroll_content.setLayout(self.scroll_layout)
        self.scroll_layout.setContentsMargins(6, 6, 6, 6)
        self.scroll_layout.setSpacing(4)
        self.scroll_area.setWidget(self.scroll_content)
        self.main_layout.addWidget(self.scroll_area)

        # Checkbox to delete prefix
        self.delete_prefix_checkbox = QCheckBox(tr("DELETE_PREFIX_CHECKBOX"))
        self.delete_prefix_checkbox.setChecked(False)
        self.main_layout.addWidget(self.delete_prefix_checkbox)

        # Select All / Deselect All buttons
        btn_layout = QHBoxLayout()
        self.select_all_btn = QPushButton(tr("SELECT_ALL_IN_MULTIPLE_EDIT"))
        self.deselect_all_btn = QPushButton(tr("DESELECT_ALL_IN_MULTIPLE_EDIT"))
        self.select_all_btn.clicked.connect(self.select_all_invocations)
        self.deselect_all_btn.clicked.connect(self.deselect_all_invocations)
        btn_layout.addWidget(self.select_all_btn)
        btn_layout.addWidget(self.deselect_all_btn)
        self.main_layout.addLayout(btn_layout)

        # Remove button
        self.remove_button = QPushButton(tr("REMOVE"))
        self.remove_button.clicked.connect(self.remove_selected_invocations)
        self.main_layout.addWidget(self.remove_button)

        # Dictionary invocation_name -> checkbox
        self.invocation_checkboxes = {}
        self.load_invocations()

    def select_all_invocations(self):
        for i in range(self.scroll_layout.count()):
            widget = self.scroll_layout.itemAt(i).widget()
            if isinstance(widget, QCheckBox) and not widget.isHidden():
                widget.setChecked(True)

    def deselect_all_invocations(self):
        for i in range(self.scroll_layout.count()):
            widget = self.scroll_layout.itemAt(i).widget()
            if isinstance(widget, QCheckBox) and not widget.isHidden():
                widget.setChecked(False)

    def keyPressEvent(self, event):
        if event.key() in (Qt.Key.Key_Return, Qt.Key.Key_Enter):
            # Prevents Enter from triggering something that is not selected
            return
        super().keyPressEvent(event)

    def load_invocations(self):
        """Loads all existing invocations in alphabetical order."""
        self.invocation_checkboxes.clear()

        # Clean layout
        while self.scroll_layout.count():
            item = self.scroll_layout.takeAt(0)
            widget = item.widget()
            if widget:
                widget.deleteLater()

        # Sort files by name (alphabetical)
        invocation_files = sorted(zordeer_config_dir.glob("invocation-info-*.toml"))

        for invocation_file in invocation_files:
            try:
                with open(invocation_file, encoding="utf-8") as f:
                    invocation_data = toml.load(f)
                name = invocation_data.get("name", invocation_file.stem)
                checkbox = QCheckBox(name)
                checkbox.invocation_file = invocation_file
                checkbox.prefix_path = invocation_data.get("prefix_path")
                checkbox.art_path = invocation_data.get("art_path")
                checkbox.gui_path = invocation_data.get("gui_path")

                self.scroll_layout.addWidget(checkbox)
                self.invocation_checkboxes[name] = checkbox
            except Exception:
                continue

        self.scroll_layout.addStretch()

    def update_invocation_list(self, text):
        """Filters invocations by the text entered in the search."""
        text = text.lower()
        for name, checkbox in self.invocation_checkboxes.items():
            checkbox.setVisible(text in name.lower())

    def remove_selected_invocations(self):
        to_remove = [cb for cb in self.invocation_checkboxes.values() if cb.isChecked()]
        if not to_remove:
            QMessageBox.warning(self, tr("APP_NAME"), tr("NO_INVOCATION_SELECTED_MULTIPLE"))
            return

        msg = QMessageBox(self)
        msg.setIcon(QMessageBox.Icon.Warning)
        msg.setWindowTitle(tr("MULTIPLE_INVOCATION_REMOVER"))
        msg.setText(tr("DELETE_INVOCATIONS_CONFIRM_MESSAGE"))
        msg.setStandardButtons(QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
        msg.button(QMessageBox.StandardButton.Yes).setText(tr("YES_BUTTON"))
        msg.button(QMessageBox.StandardButton.No).setText(tr("NO_BUTTON"))

        if msg.exec() != QMessageBox.StandardButton.Yes:
            return

        art_dir = zordeer_dir / "art"
        gui_dir = zordeer_dir / "art" / "gui"

        # Checking prefixes in use
        prefix_usages = {}
        if self.delete_prefix_checkbox.isChecked():
            for cb in to_remove:
                if not cb.prefix_path:
                    continue
                prefix_path_obj = Path(cb.prefix_path)
                if not prefix_path_obj.exists() or not prefix_path_obj.is_dir():
                    continue

                selected_using = []
                affected_using = []
                for f in zordeer_config_dir.glob("invocation-info-*.toml"):
                    try:
                        with open(f, encoding="utf-8") as toml_file:
                            data = toml.load(toml_file)
                            other_prefix = data.get('prefix_path')
                            if other_prefix and Path(other_prefix).resolve() == prefix_path_obj.resolve():
                                name = data.get("name", f.stem)
                                if name in [c.text() for c in to_remove]:
                                    selected_using.append(name)
                                else:
                                    affected_using.append(name)
                    except Exception:
                        pass

                if affected_using:
                    prefix_usages[str(prefix_path_obj)] = {
                        "selected": selected_using,
                        "affected": affected_using,
                    }

        force_delete = False
        keep_in_use = False
        if prefix_usages:
            dialog = QDialog(self)
            dialog.setWindowTitle(tr("MULTIPLE_INVOCATION_REMOVER"))
            layout = QVBoxLayout(dialog)

            label = QLabel(tr("PREFIXES_IN_USE_MESSAGE"))
            label.setWordWrap(True)
            layout.addWidget(label)

            tree = QTreeWidget()
            tree.setHeaderLabels([tr("PREFIXES_REMOTION_INFORMATION")])
            tree.setSelectionMode(QAbstractItemView.SelectionMode.NoSelection)
            for prefix, info in prefix_usages.items():
                root = QTreeWidgetItem([prefix])

                selected_item = QTreeWidgetItem([tr("SELECTED_INVOCATIONS")])
                for name in info["selected"]:
                    QTreeWidgetItem(selected_item, [name])
                root.addChild(selected_item)

                affected_item = QTreeWidgetItem([tr("AFFECTED_INVOCATIONS")])
                for name in info["affected"]:
                    QTreeWidgetItem(affected_item, [name])
                root.addChild(affected_item)

                tree.addTopLevelItem(root)

            layout.addWidget(tree)

            rb_keep = QRadioButton(tr("DO_NOT_DELETE_PREFIXES"))
            rb_delete = QRadioButton(tr("DELETE_PREFIXES_ANYWAY"))
            rb_keep.setChecked(True)
            layout.addWidget(rb_keep)
            layout.addWidget(rb_delete)

            confirm_btn = QPushButton(tr("CONFIRM"))
            confirm_btn.clicked.connect(dialog.accept)
            layout.addWidget(confirm_btn)

            if dialog.exec() == QDialog.DialogCode.Accepted:
                force_delete = rb_delete.isChecked()
                keep_in_use = rb_keep.isChecked()
            else:
                return  # User closed the window, cancel everything

        # Effective removal
        for cb in to_remove:
            # Remove TOML
            try:
                if cb.invocation_file.exists():
                    cb.invocation_file.unlink()
            except Exception:
                pass

            # Remove artwork
            if cb.art_path:
                art_path = Path(cb.art_path)
                if art_path.exists() and art_path.is_file():
                    try:
                        art_path.unlink()
                    except Exception:
                        pass

            # Remove gui icon
            if cb.gui_path:
                gui_path = Path(cb.gui_path)
                if gui_path.exists() and gui_path.is_file():
                    try:
                        gui_path.unlink()
                    except Exception:
                        pass

            # Remove prefix if checkbox is checked
            if self.delete_prefix_checkbox.isChecked() and cb.prefix_path:
                prefix_path_obj = Path(cb.prefix_path)
                if prefix_path_obj.exists() and prefix_path_obj.is_dir():
                    try:
                        if str(prefix_path_obj) in prefix_usages:
                            if force_delete:
                                shutil.rmtree(prefix_path_obj)
                            elif keep_in_use:
                                continue  # Keeps
                        else:
                            # Unique prefix, can be deleted
                            shutil.rmtree(prefix_path_obj)
                    except Exception:
                        pass

        # Reload the list
        self.load_invocations()
        if self.parent_ref:
            self.parent_ref.load_invocations()

        self.accept()

class MultipleEditInvocationDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle(tr("MULTIPLE_INVOCATION_EDITOR"))
        self.resize(580, 480)
        self.parent_ref = parent

        # Main layout
        splitter = QSplitter(Qt.Orientation.Horizontal, self)
        splitter.setChildrenCollapsible(False)

        # Left: selection of invocations
        left_widget = QWidget()
        left_layout = QVBoxLayout(left_widget)

        self.search_input = QLineEdit()
        self.search_input.setPlaceholderText(tr("SEARCH"))
        self.search_input.textChanged.connect(self.update_invocation_list)
        left_layout.addWidget(self.search_input)

        # Runner filter
        self.runner_filter = QComboBox()
        self.runner_filter.addItem(tr("ALL_INVOCATIONS"))
        self.runner_filter.currentIndexChanged.connect(self.update_invocation_list)
        left_layout.addWidget(self.runner_filter)

        self.scroll_area = QScrollArea()
        self.scroll_area.setWidgetResizable(True)
        self.scroll_content = QWidget()
        self.scroll_layout = QVBoxLayout(self.scroll_content)
        self.scroll_layout.setContentsMargins(6, 6, 6, 6)
        self.scroll_layout.setSpacing(4)
        self.scroll_content.setLayout(self.scroll_layout)
        self.scroll_area.setWidget(self.scroll_content)
        left_layout.addWidget(self.scroll_area)

        # Select all / Deselect all
        btn_layout = QHBoxLayout()
        self.select_all_btn = QPushButton(tr("SELECT_ALL_IN_MULTIPLE_EDIT"))
        self.deselect_all_btn = QPushButton(tr("DESELECT_ALL_IN_MULTIPLE_EDIT"))
        self.select_all_btn.clicked.connect(self.select_all_invocations)
        self.deselect_all_btn.clicked.connect(self.deselect_all_invocations)
        btn_layout.addWidget(self.select_all_btn)
        btn_layout.addWidget(self.deselect_all_btn)
        left_layout.addLayout(btn_layout)

        # Information viewer
        self.view_invocations_btn = QPushButton(tr("SEE_DATA"))
        self.view_invocations_btn.clicked.connect(self.open_invocation_info_viewer)
        left_layout.addWidget(self.view_invocations_btn)

        # Right: Mass editing
        right_widget = QWidget()
        right_layout = QGridLayout(right_widget)
        splitter.addWidget(left_widget)
        splitter.addWidget(right_widget)

        splitter.setSizes([100, 380])

        main_layout = QVBoxLayout(self)
        main_layout.addWidget(splitter)

        row = 0

        # Runner
        self.runner_label = QLabel(tr("RUNNER_VERSION"))
        self.runner_combo = QComboBox()
        self.populate_runners()
        self.runner_combo.insertItem(0, tr("DO_NOT_CHANGE"))
        self.runner_combo.setCurrentIndex(0)
        right_layout.addWidget(self.runner_label, row, 0)
        right_layout.addWidget(self.runner_combo, row, 1, 1, 2)
        row += 1

        # Executable path
        self.exec_label = QLabel(tr("EXECUTABLE_PATH"))
        self.exec_input = QLineEdit(tr("DO_NOT_CHANGE"))
        self.exec_button = QPushButton(tr("BROWSE_BUTTON"))
        self.exec_button.clicked.connect(self.select_executable)
        right_layout.addWidget(self.exec_label, row, 0)
        right_layout.addWidget(self.exec_input, row, 1)
        right_layout.addWidget(self.exec_button, row, 2)
        row += 1

        # Prefix path
        self.prefix_label = QLabel(tr("PREFIX_PATH"))
        self.prefix_input = QLineEdit(tr("DO_NOT_CHANGE"))
        self.prefix_input.setPlaceholderText(tr("ANIMARIUM_PREFIX_PLACEHOLDER"))
        self.prefix_button = QPushButton(tr("BROWSE_BUTTON"))
        self.prefix_button.clicked.connect(self.select_prefix)
        right_layout.addWidget(self.prefix_label, row, 0)
        right_layout.addWidget(self.prefix_input, row, 1)
        right_layout.addWidget(self.prefix_button, row, 2)
        row += 1

        # Art path
        self.art_label = QLabel(tr("INVOCATION_ART_PATH"))
        self.art_input = QLineEdit(tr("DO_NOT_CHANGE"))
        self.art_button = QPushButton(tr("BROWSE_BUTTON"))
        self.art_button.clicked.connect(self.select_invocation_art)
        right_layout.addWidget(self.art_label, row, 0)
        right_layout.addWidget(self.art_input, row, 1)
        right_layout.addWidget(self.art_button, row, 2)
        row += 1

        # Gui path
        self.gui_label = QLabel(tr("INVOCATION_GUI_PATH"))
        self.gui_input = QLineEdit(tr("DO_NOT_CHANGE"))
        self.gui_button = QPushButton(tr("BROWSE_BUTTON"))
        self.gui_button.clicked.connect(self.select_invocation_gui)
        right_layout.addWidget(self.gui_label, row, 0)
        right_layout.addWidget(self.gui_input, row, 1)
        right_layout.addWidget(self.gui_button, row, 2)
        row += 1

        # Language
        self.lang_label = QLabel(tr("INVOCATION_LANGUAGE"))
        self.lang_combo = QComboBox()
        self.lang_combo.addItems([
            tr("DO_NOT_CHANGE"),
            tr("PLACEHOLDER_FOR_LANGUAGE")
        ] + INVOCATION_LOCALE_OPTIONS)
        self.lang_combo.setCurrentIndex(0)
        right_layout.addWidget(self.lang_label, row, 0)
        right_layout.addWidget(self.lang_combo, row, 1, 1, 2)
        row += 1

        # Checkboxes with tristate
        self.ms_lang_checkbox = QCheckBox(tr("USE_MS_LANGUAGE_CODE"))
        self.ms_lang_checkbox.setTristate(True)
        self.ms_lang_checkbox.setCheckState(Qt.CheckState.PartiallyChecked)
        right_layout.addWidget(self.ms_lang_checkbox, row, 0, 1, 3)
        row += 1

        self.force_opengl_checkbox = QCheckBox(tr("FORCE_OPENGL"))
        self.force_opengl_checkbox.setTristate(True)
        self.force_opengl_checkbox.setCheckState(Qt.CheckState.PartiallyChecked)
        right_layout.addWidget(self.force_opengl_checkbox, row, 0, 1, 3)
        row += 1

        self.umu_checkbox = QCheckBox(tr("USE_UMU_LAUNCHER"))
        self.umu_checkbox.setTristate(True)
        self.umu_checkbox.setCheckState(Qt.CheckState.PartiallyChecked)
        right_layout.addWidget(self.umu_checkbox, row, 0, 1, 3)
        row += 1

        # FPS HUD
        self.show_fps_checkbox = QCheckBox(tr("SHOW_FPS_OPTION"))
        self.show_fps_checkbox.setTristate(True)
        self.show_fps_checkbox.setCheckState(Qt.CheckState.PartiallyChecked)
        self.fps_hud_combo = QComboBox()
        self.fps_hud_options = [("FPS_GALLIUM_HUD", tr("FPS_GALLIUM_HUD")),
                                ("FPS_DXVK_HUD", tr("FPS_DXVK_HUD")),
                                ("FPS_MANGOHUD", tr("FPS_MANGOHUD"))]
        for id, text in self.fps_hud_options:
            self.fps_hud_combo.addItem(text, id)
        self.fps_hud_combo.setEnabled(False)
        self.show_fps_checkbox.stateChanged.connect(self.update_fps_hud_state)
        right_layout.addWidget(self.show_fps_checkbox, row, 0)
        right_layout.addWidget(self.fps_hud_combo, row, 1, 1, 3)
        row += 1

        # Env vars
        self.env_label = QLabel(tr("ENVIRONMENT_VARS"))
        self.env_input = QLineEdit(tr("DO_NOT_CHANGE"))
        right_layout.addWidget(self.env_label, row, 0)
        right_layout.addWidget(self.env_input, row, 1, 1, 2)
        row += 1

        # Invocation args
        self.args_label = QLabel(tr("INVOCATION_ARGS"))
        self.args_input = QLineEdit(tr("DO_NOT_CHANGE"))
        right_layout.addWidget(self.args_label, row, 0)
        right_layout.addWidget(self.args_input, row, 1, 1, 2)
        row += 1

        self.add_default_clear(self.exec_input)
        self.add_default_clear(self.prefix_input)
        self.add_default_clear(self.art_input)
        self.add_default_clear(self.gui_input)
        self.add_default_clear(self.env_input)
        self.add_default_clear(self.args_input)

        # Reset and save buttons
        self.reset_button = QPushButton(tr("RESET_BUTTON_MULTIPLE_EDIT"))
        self.reset_button.clicked.connect(self.reset_fields)

        self.save_button = QPushButton(tr("SAVE_BUTTON"))
        self.save_button.clicked.connect(self.apply_multiple_edit)

        buttons_layout = QHBoxLayout()
        buttons_layout.addStretch()
        buttons_layout.addWidget(self.reset_button)
        buttons_layout.addWidget(self.save_button)

        right_layout.addLayout(buttons_layout, row, 0, 1, 3)

        # Loads invocations
        self.invocation_checkboxes = {}
        self.load_invocations()
        self.update_runner_filter()

    # Auxiliary functions

    # Select or deselect innovations listed in the Invocation Viewer.
    def set_checked_state(self, inv_name, state: bool):
        for checkbox in self.invocation_checkboxes.values():
            try:
                if checkbox.text() == inv_name:
                    checkbox.setChecked(state)
            except Exception:
                continue

    def closeEvent(self, event):
        viewer = getattr(self, "invocation_info_viewer", None)
        if viewer and viewer.isVisible():
            viewer.close()
        super().closeEvent(event)

    def open_invocation_info_viewer(self):
        if getattr(self, "invocation_info_viewer", None) and self.invocation_info_viewer.isVisible():
            self.invocation_info_viewer.raise_()
            self.invocation_info_viewer.activateWindow()
            return

        self.invocation_info_viewer = InvocationInfoViewerDialog(zordeer_dir, self, multiple_edit_dialog=self)
        self.invocation_info_viewer.finished.connect(partial(setattr, self, "invocation_info_viewer", None))
        self.invocation_info_viewer.show()

    def keyPressEvent(self, event):
        if event.key() in (Qt.Key.Key_Return, Qt.Key.Key_Enter):
            # Prevents Enter from triggering something that is not selected
            return
        super().keyPressEvent(event)

    def add_default_clear(self, line_edit):
        original_keyPressEvent = line_edit.keyPressEvent

        def new_keyPressEvent(event):
            if line_edit.text() == tr("DO_NOT_CHANGE"):
                line_edit.clear()
            # Invoke normal QLineEdit behavior
            original_keyPressEvent(event)

        line_edit.keyPressEvent = new_keyPressEvent

    def eventFilter(self, obj, event):
        if isinstance(obj, QLineEdit) and event.type() == QEvent.Type.FocusIn:
            if obj.text() == tr("DO_NOT_CHANGE"):
                obj.clear()
        return super().eventFilter(obj, event)

    def update_runner_filter(self):
        """Updates the available runners in the filter based on the invocation-info files."""
        runners = set()
        for cb in self.invocation_checkboxes.values():
            try:
                with open(cb.invocation_file, encoding="utf-8") as f:
                    data = toml.load(f)
                runner = data.get("runner", "")
                if not runner:
                    runner = tr("PLACEHOLDER_FOR_RUNNER")
                runners.add(runner)
            except Exception:
                continue

        current = self.runner_filter.currentText()
        self.runner_filter.blockSignals(True)
        self.runner_filter.clear()
        self.runner_filter.addItem(tr("ALL_INVOCATIONS"))
        placeholder = tr("PLACEHOLDER_FOR_RUNNER")
        if placeholder in runners:
            self.runner_filter.addItem(placeholder)
            runners.remove(placeholder)
        if "Wine" in runners:
            self.runner_filter.addItem("Wine")
            runners.remove("Wine")
        for runner in sorted(runners, reverse=True):
            self.runner_filter.addItem(runner)
        # Keep the previous selection, if it still exists.
        index = self.runner_filter.findText(current)
        if index != -1:
            self.runner_filter.setCurrentIndex(index)
        self.runner_filter.blockSignals(False)

    def populate_runners(self):
        runners_path = zordeer_dir / "runner"
        runners_path.mkdir(parents=True, exist_ok=True)
        runners = [d.name for d in runners_path.iterdir() if d.is_dir()]

        self.runner_combo.clear()

        items = [tr("PLACEHOLDER_FOR_RUNNER")]

        if shutil.which("wine"):
            items.append("Wine")

        items += sorted(runners, reverse=True)

        self.runner_combo.addItems(items)

    def update_fps_hud_state(self, state):
        self.fps_hud_combo.setEnabled(Qt.CheckState(state) == Qt.CheckState.Checked)

    def select_executable(self):
        invocations_dir = zordeer_dir / "invocation"
        invocations_dir.mkdir(parents=True, exist_ok=True)

        file_path, _ = QFileDialog.getOpenFileName(
            self,
            tr("SELECT_EXECUTABLE"),
            str(invocations_dir),
            tr("EXECUTABLE_FILE_FILTER")
        )

        if file_path:
            self.exec_input.setText(file_path)

    def select_prefix(self):
        invocations_dir = zordeer_dir / "invocation"
        invocations_dir.mkdir(parents=True, exist_ok=True)

        dir_path = QFileDialog.getExistingDirectory(
            self,
            tr("SELECT_PREFIX_TITLE"),
            str(invocations_dir)
        )
        if dir_path:
            self.prefix_input.setText(dir_path)

    def select_invocation_art(self):
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            tr("SELECT_INVOCATION_ART"),
            str(home_dir),
            tr("IMAGE_FILTER"))
        if file_path:
            self.art_input.setText(file_path)

    def select_invocation_gui(self):
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            tr("SELECT_INVOCATION_GUI"),
            str(home_dir),
            tr("IMAGE_FILTER"))
        if file_path:
            self.gui_input.setText(file_path)

    def load_invocations(self):
        self.invocation_checkboxes.clear()
        while self.scroll_layout.count():
            item = self.scroll_layout.takeAt(0)
            widget = item.widget()
            if widget:
                widget.deleteLater()
        invocation_files = sorted(zordeer_config_dir.glob("invocation-info-*.toml"))
        for invocation_file in invocation_files:
            try:
                with open(invocation_file, encoding="utf-8") as f:
                    data = toml.load(f)
                name = data.get("name", invocation_file.stem)
                cb = QCheckBox(name)
                cb.invocation_file = invocation_file
                self.scroll_layout.addWidget(cb)
                self.invocation_checkboxes[name] = cb
            except Exception:
                continue
        self.scroll_layout.addStretch()

    def update_invocation_list(self, _=None):
        search_text = self.search_input.text().lower()
        selected_runner = self.runner_filter.currentText()

        for name, cb in self.invocation_checkboxes.items():
            try:
                with open(cb.invocation_file, encoding="utf-8") as f:
                    data = toml.load(f)
                runner = data.get("runner", "")
                if not runner:
                    runner = tr("PLACEHOLDER_FOR_RUNNER")
            except Exception:
                runner = tr("PLACEHOLDER_FOR_RUNNER")

            matches_text = search_text in name.lower()
            matches_runner = (selected_runner == tr("ALL_INVOCATIONS")) or (runner == selected_runner)
            cb.setVisible(matches_text and matches_runner)

    def select_all_invocations(self):
        for cb in self.invocation_checkboxes.values():
            if cb.isVisible():
                cb.setChecked(True)

    def deselect_all_invocations(self):
        for cb in self.invocation_checkboxes.values():
            if cb.isVisible():
                cb.setChecked(False)

    def reset_fields(self):
        # Runner
        self.runner_combo.setCurrentIndex(0)

        # Executable / Prefix / Art / Gui
        self.exec_input.setText(tr("DO_NOT_CHANGE"))
        self.prefix_input.setText(tr("DO_NOT_CHANGE"))
        self.art_input.setText(tr("DO_NOT_CHANGE"))
        self.gui_input.setText(tr("DO_NOT_CHANGE"))

        # Language
        self.lang_combo.setCurrentIndex(0)

        # Checkboxes
        self.ms_lang_checkbox.setCheckState(Qt.CheckState.PartiallyChecked)
        self.force_opengl_checkbox.setCheckState(Qt.CheckState.PartiallyChecked)
        self.umu_checkbox.setCheckState(Qt.CheckState.PartiallyChecked)

        # FPS HUD
        self.show_fps_checkbox.setCheckState(Qt.CheckState.PartiallyChecked)
        self.fps_hud_combo.setCurrentIndex(0)
        self.fps_hud_combo.setEnabled(False)

        # Env vars / Args
        self.env_input.setText(tr("DO_NOT_CHANGE"))
        self.args_input.setText(tr("DO_NOT_CHANGE"))

    # Apply changes
    def apply_multiple_edit(self):
        selected = [cb for cb in self.invocation_checkboxes.values() if cb.isChecked()]
        if not selected:
            QMessageBox.warning(self, tr("APP_NAME"), tr("NO_INVOCATION_SELECTED_MULTIPLE"))
            return

        for cb in selected:
            with open(cb.invocation_file, encoding="utf-8") as f:
                data = toml.load(f)

            # Apply fields
            # Runner
            runner = self.runner_combo.currentText()
            if runner != tr("DO_NOT_CHANGE"):
                data["runner"] = "" if runner == tr("PLACEHOLDER_FOR_RUNNER") else runner

            # Executable
            exec_path = self.exec_input.text()
            if exec_path != tr("DO_NOT_CHANGE"):
                data["exec_path"] = exec_path

            # Prefix
            prefix_text = self.prefix_input.text().strip()
            if prefix_text != tr("DO_NOT_CHANGE"):
                if prefix_text == "":
                    # Uses the standard prefix animarium_prefix
                    prefix_path = zordeer_dir / "invocation" / "animarium_prefix"
                    prefix_path.mkdir(parents=True, exist_ok=True)
                    data["prefix_path"] = str(prefix_path)
                else:
                    data["prefix_path"] = prefix_text

            # Art
            art_input_text = self.art_input.text().strip()
            if art_input_text != tr("DO_NOT_CHANGE"):
                if not art_input_text:
                    # Remove previous file if it exists.
                    if data.get("art_path"):
                        old_art_path = Path(data["art_path"])
                        if old_art_path.exists() and old_art_path.is_file():
                            try:
                                old_art_path.unlink()
                            except Exception:
                                pass
                    data["art_path"] = ""
                else:
                    art_path = Path(art_input_text)
                    if art_path.exists() and art_path.is_file():
                        # Remove previous file if it exists.
                        if data.get("art_path"):
                            old_art_path = Path(data["art_path"])
                            if old_art_path.exists() and old_art_path.is_file():
                                try:
                                    old_art_path.unlink()
                                except Exception:
                                    pass

                        art_dir = zordeer_dir / "art"
                        art_dir.mkdir(parents=True, exist_ok=True)
                        ext = art_path.suffix.lower()
                        new_art_path = art_dir / f"{data['name'].replace(' ', '_').lower()}{ext}"
                        try:
                            shutil.copyfile(art_path, new_art_path)
                            data["art_path"] = str(new_art_path)
                        except Exception:
                            data["art_path"] = ""

            # Gui
            gui_input_text = self.gui_input.text().strip()
            if gui_input_text != tr("DO_NOT_CHANGE"):
                if not gui_input_text:
                    # Remove previous file if it exists.
                    if data.get("gui_path"):
                        old_gui_path = Path(data["gui_path"])
                        if old_gui_path.exists() and old_gui_path.is_file():
                            try:
                                old_gui_path.unlink()
                            except Exception:
                                pass
                    data["gui_path"] = ""
                else:
                    gui_path = Path(gui_input_text)
                    if gui_path.exists() and gui_path.is_file():
                        # Remove GUI antiga se existir
                        if data.get("gui_path"):
                            old_gui_path = Path(data["gui_path"])
                            if old_gui_path.exists() and old_gui_path.is_file():
                                try:
                                    old_gui_path.unlink()
                                except Exception:
                                    pass

                        gui_dir = zordeer_dir / "art" / "gui"
                        gui_dir.mkdir(parents=True, exist_ok=True)
                        ext = gui_path.suffix.lower()
                        new_gui_path = gui_dir / f"{data['name'].replace(' ', '_').lower()}{ext}"
                        try:
                            shutil.copyfile(gui_path, new_gui_path)
                            data["gui_path"] = str(new_gui_path)
                        except Exception:
                            data["gui_path"] = ""

            # Language
            lang = self.lang_combo.currentText()
            if lang != tr("DO_NOT_CHANGE"):
                data["language"] = "" if lang == tr("PLACEHOLDER_FOR_LANGUAGE") else lang

            # Checkboxes
            def apply_checkbox(cb_widget, key):
                state = cb_widget.checkState()
                if state != Qt.CheckState.PartiallyChecked:
                    data[key] = (state == Qt.CheckState.Checked)
            apply_checkbox(self.ms_lang_checkbox, "use_ms_language_code")
            apply_checkbox(self.force_opengl_checkbox, "force_opengl")
            apply_checkbox(self.umu_checkbox, "use_umu")

            # FPS HUD
            if self.show_fps_checkbox.checkState() == Qt.CheckState.Checked:
                data["show_fps"] = True
                data["fps_hud_type"] = self.fps_hud_combo.currentData()
            elif self.show_fps_checkbox.checkState() == Qt.CheckState.Unchecked:
                data["show_fps"] = False
                data["fps_hud_type"] = self.fps_hud_combo.currentData()

            # Env vars
            env_vars = self.env_input.text()
            if env_vars != tr("DO_NOT_CHANGE"):
                data["env_vars"] = env_vars.strip()

            # Invocation args
            args = self.args_input.text()
            if args != tr("DO_NOT_CHANGE"):
                data["invocation_args"] = args.strip()

            # Save TOML
            with open(cb.invocation_file, "w", encoding="utf-8") as f:
                toml.dump(data, f)

        if self.parent_ref:
            self.update_runner_filter()
            self.update_invocation_list(self.search_input.text())
            self.parent_ref.load_invocations()

        QMessageBox.information(
            self,
            tr("MULTIPLE_INVOCATION_EDITOR"),
            tr("CHANGES_SAVED")
        )

        # Updates the right panel of the InvocationInfoViewerDialog.
        if hasattr(self, "invocation_info_viewer") and self.invocation_info_viewer:
            self.invocation_info_viewer.reload_current_selection()

class InvocationInfoViewerDialog(QDialog):
    def __init__(self, zordeer_dir=None, parent=None, multiple_edit_dialog=None):
        super().__init__(parent)
        self.multiple_edit_dialog = multiple_edit_dialog
        self.setWindowTitle(tr("INVOCATION_INFO_VIEWER_TITLE"))
        self.setAttribute(Qt.WidgetAttribute.WA_DeleteOnClose, True)
        if parent is not None:
            self.destroyed.connect(partial(setattr, parent, "invocation_info_viewer", None))
        self.resize(580, 480)

        self.invocations = self.load_invocations()

        # Left widget: Search, combobox, list
        left_widget = QWidget()
        left_layout = QVBoxLayout(left_widget)

        # Search bar
        self.search_box = QLineEdit()
        self.search_box.setPlaceholderText(tr("SEARCH"))
        self.search_box.textChanged.connect(self.filter_invocations)
        left_layout.addWidget(self.search_box)

        # Combobox for search
        self.search_mode_combo = QComboBox()
        self.search_mode_combo.addItems([tr("NAME"), tr("CONTENT")])
        self.search_mode_combo.currentIndexChanged.connect(self.update_filter_from_combo)
        left_layout.addWidget(self.search_mode_combo)

        # Scroll area for radio buttons
        self.scroll = QScrollArea()
        self.scroll.setWidgetResizable(True)
        self.container = QWidget()
        self.scroll_layout = QVBoxLayout(self.container)
        self.scroll_layout.setContentsMargins(6, 6, 6, 6)
        self.scroll_layout.setSpacing(4)
        self.scroll.setWidget(self.container)
        left_layout.addWidget(self.scroll)

        # mark/unmark listed buttons (added)
        self.btn_mark_listed = QPushButton(tr("MARK_LISTED"))
        self.btn_unmark_listed = QPushButton(tr("UNMARK_LISTED"))

        self.btn_mark_listed.clicked.connect(self.mark_listed)
        self.btn_unmark_listed.clicked.connect(self.unmark_listed)

        left_layout.addWidget(self.btn_mark_listed)
        left_layout.addWidget(self.btn_unmark_listed)

        # Radio button group
        self.button_group = QButtonGroup(self)
        self.button_group.setExclusive(True)
        self.button_group.buttonToggled.connect(self.handle_button_toggled)

        # Text box
        self.text_box = QTextEdit()
        self.text_box.setReadOnly(True)
        self.text_box.setAcceptRichText(True)
        self.text_box.setTextInteractionFlags(Qt.TextInteractionFlag.TextSelectableByMouse)

        # Styling
        palette = QApplication.palette()
        base_color = palette.color(QPalette.ColorRole.Base)
        text_color = palette.color(QPalette.ColorRole.Text)
        accent_color = palette.color(QPalette.ColorRole.Highlight)

        self.text_box.setStyleSheet(f"""
            QTextEdit {{
                background-color: {base_color.name()};
                color: {text_color.name()};
            }}
        """)

        # Qsplitter and main layout
        splitter = QSplitter(Qt.Orientation.Horizontal)
        splitter.addWidget(left_widget)
        splitter.addWidget(self.text_box)
        splitter.setChildrenCollapsible(False)

        splitter.setSizes([200, 460])

        main_layout = QHBoxLayout(self)
        main_layout.setContentsMargins(6, 6, 6, 6)
        main_layout.addWidget(splitter)

        self.radio_buttons = []
        self.create_invocation_buttons()

    def update_filter_from_combo(self):
        current_text = self.search_box.text()
        self.filter_invocations(current_text)

    # In the MultipleEditInvocationDialog, mark all the innovations that are visible
    def mark_listed(self):
        if not getattr(self, "multiple_edit_dialog", None):
            return

        listed = []
        for rb in self.radio_buttons:
            if rb.isVisible():
                listed.append(rb.text())

        for name in listed:
            self.multiple_edit_dialog.set_checked_state(name, True)

    # In the Multiple Edit Invocation Dialog, uncheck all the innovations that are visible
    def unmark_listed(self):
        if not getattr(self, "multiple_edit_dialog", None):
            return

        listed = []
        for rb in self.radio_buttons:
            if rb.isVisible():
                listed.append(rb.text())

        for name in listed:
            self.multiple_edit_dialog.set_checked_state(name, False)

    def keyPressEvent(self, event):
        if event.key() in (Qt.Key.Key_Return, Qt.Key.Key_Enter):
            # Prevents Enter from triggering something that is not selected
            return
        super().keyPressEvent(event)

    def closeEvent(self, event):
        # Notifies the MultipleEditInvocationDialog that this dialog has been closed.
        if hasattr(self.parent(), "invocation_info_viewer"):
            self.parent().invocation_info_viewer = None
        super().closeEvent(event)

    # Loads the available TOML files.
    def load_invocations(self) -> list[dict]:
        invocations = []
        if not zordeer_config_dir.exists():
            return invocations

        for file in zordeer_config_dir.glob("invocation-info-*.toml"):
            try:
                with open(file, "r", encoding="utf-8") as f:
                    inv = toml.load(f)
                    inv["__filename"] = file.name
                    invocations.append(inv)
            except Exception:
                pass
        return invocations

    # Create radio buttons
    def create_invocation_buttons(self):
        # Sort alphabetically by filename (invocation-info-)
        def get_filename_sort_key(invocation):
            filename = invocation.get("__filename", "")
            return Path(filename).stem.lower()
        
        self.invocations.sort(key=get_filename_sort_key)

        first_rb = None
        for inv in self.invocations:
            filename = inv.get("__filename", "")
            
            # Displays the content of the name field.
            display_name = inv.get("name")
            
            rb = QRadioButton(display_name)
            rb.setProperty("invocation_filename", filename)
            self.button_group.addButton(rb)
            self.scroll_layout.addWidget(rb)
            self.radio_buttons.append(rb)
            if first_rb is None:
                first_rb = rb

        self.scroll_layout.addStretch(1)

        # Initial Selection
        if first_rb:
            first_rb.setChecked(True)
            self.show_invocation_info_from_file(first_rb.property("invocation_filename"))

    # Search filter
    def filter_invocations(self, text: str):
        text = (text or "").strip().lower()
        first_visible = None
        search_mode = self.search_mode_combo.currentText()

        for rb in self.radio_buttons:
            filename = rb.property("invocation_filename")
            match = False

            if search_mode == tr("NAME"):
                match = text in rb.text().lower()
            else:  # Content
                file_path = zordeer_dir / "config" / filename
                if file_path.exists():
                    try:
                        with open(file_path, "r", encoding="utf-8") as f:
                            data = toml.load(f)
                        # Search for content only in these fields
                        for key in ["exec_path", "prefix_path", "language", "fps_hud_type", "env_vars", "invocation_args"]:
                            value = str(data.get(key, "")).lower()
                            if text in value:
                                match = True
                                break
                    except Exception:
                        match = False

            rb.setVisible(match)
            if match and first_visible is None:
                first_visible = rb

        if first_visible:
            first_visible.setChecked(True)

            checked = self.button_group.checkedButton()
            if checked:
                filename = checked.property("invocation_filename")
                self.show_invocation_info_from_file(filename)
        else:
            self.text_box.clear()

    # When a radio button is clicked
    def handle_button_toggled(self, button, checked: bool):
        if not checked or not button:
            return
        filename = button.property("invocation_filename")
        if filename:
            self.show_invocation_info_from_file(filename)

    # Display information by reading the TOML.
    def show_invocation_info_from_file(self, filename: str):
        file_path = zordeer_dir / "config" / filename
        if not file_path.exists():
            self.text_box.clear()
            return

        try:
            with open(file_path, "r", encoding="utf-8") as f:
                inv = toml.load(f)
        except Exception:
            self.text_box.clear()
            return

        self.text_box.clear()
        cursor = self.text_box.textCursor()
        palette = QApplication.palette()
        key_color = palette.color(QPalette.ColorRole.Highlight)
        value_color = palette.color(QPalette.ColorRole.Text)

        translations = {
            "name": tr("INVOCATION_NAME"),
            "runner": tr("RUNNER_VERSION"),
            "exec_path": tr("EXECUTABLE_PATH"),
            "prefix_path": tr("PREFIX_PATH"),
            "art_path": tr("INVOCATION_ART_PATH"),
            "gui_path": tr("INVOCATION_GUI_PATH"),
            "language": tr("INVOCATION_LANGUAGE"),
            "use_ms_language_code": tr("USE_MS_LANGUAGE_CODE"),
            "force_opengl": tr("FORCE_OPENGL"),
            "use_umu": tr("USE_UMU_LAUNCHER"),
            "show_fps": tr("SHOW_FPS_OPTION"),
            "fps_hud_type": tr("SHOW_FPS_OPTION_HUD"),
            "env_vars": tr("ENVIRONMENT_VARS"),
            "invocation_args": tr("INVOCATION_ARGS"),
        }

        value_translations = {
            "FPS_GALLIUM_HUD": tr("FPS_GALLIUM_HUD"),
            "FPS_DXVK_HUD": tr("FPS_DXVK_HUD"),
            "FPS_MANGOHUD": tr("FPS_MANGOHUD"),
        }

        for key, value in inv.items():
            if isinstance(value, bool):
                value = "✅" if value else "❌"

            if isinstance(value, str) and value in value_translations:
                value = value_translations[value]
                value = re.sub(r"\s*\(.*?\)", "", value).strip()

            key_label = translations.get(key, key)

            fmt_key = QTextCharFormat()
            fmt_key.setForeground(QColor(key_color))

            fmt_value = QTextCharFormat()
            fmt_value.setForeground(QColor(value_color))

            cursor.insertText(f"{key_label}: ", fmt_key)
            cursor.insertText(str(value) + "\n", fmt_value)

        self.text_box.moveCursor(QTextCursor.MoveOperation.Start)

    def reload_current_selection(self):
        search_text = self.search_box.text().strip()
        search_mode = self.search_mode_combo.currentText()

        # Reload all invocation files
        self.invocations = self.load_invocations()

        # Clear the scroll layout completely
        while self.scroll_layout.count():
            item = self.scroll_layout.takeAt(0)
            widget = item.widget()
            if widget:
                widget.deleteLater()

        self.radio_buttons.clear()
        self.button_group = QButtonGroup(self)
        self.button_group.setExclusive(True)
        self.button_group.buttonToggled.connect(self.handle_button_toggled)

        # Recreate buttons
        self.create_invocation_buttons()

        # Reapply filter (if there was any text)
        if search_text:
            self.search_mode_combo.setCurrentText(search_mode)
            self.filter_invocations(search_text)

class RunInPrefix(QDialog):
    def __init__(self, parent, invocation_name):
        super().__init__(parent)
        self.parent = parent  # Zordeer
        self.invocation_name = invocation_name
        self.setWindowTitle(tr("RUN_IN_PREFIX_INVOCATION_NAME", invocation_name=invocation_name))
        self.resize(500, 500)
        self._has_printed_waiting_message = False

        # Preventive cleanup: delete old leftovers
        for fname in zordeer_config_dir.iterdir():
            if fname.name.endswith("_ztffrip.toml"):
                try:
                    fname.unlink()
                except Exception:
                    pass

        # Main layout
        layout = QVBoxLayout(self)

        # List of executables
        self.exe_list = QTreeWidget()
        self.exe_list.setHeaderLabels([tr("SELECTED_EXECUTABLES")])
        self.exe_list.setColumnCount(1)
        self.exe_list.setRootIsDecorated(True)
        self.exe_list.setSelectionMode(QTreeWidget.SelectionMode.SingleSelection)
        layout.addWidget(self.exe_list)

        # Grid layout for buttons (2x2)
        grid_buttons = QGridLayout()
        
        self.select_btn = QPushButton(tr("ADD_FILES"))
        self.remove_btn = QPushButton(tr("REMOVE"))
        self.select_folder_btn = QPushButton(tr("ADD_FOLDER"))
        self.clear_btn = QPushButton(tr("CLEAR_LIST"))
        
        grid_buttons.addWidget(self.select_btn, 0, 0)
        grid_buttons.addWidget(self.remove_btn, 0, 1)
        grid_buttons.addWidget(self.select_folder_btn, 1, 0)
        grid_buttons.addWidget(self.clear_btn, 1, 1)
        
        layout.addLayout(grid_buttons)

        # Execution mode section (radio buttons)
        layout.addWidget(QLabel(tr("EXECUTION_MODE")))

        self.radio_group = QButtonGroup(self)

        self.radio_normal = QRadioButton(tr("NORMAL_RUN"))             # Untouched TOML
        self.radio_clean = QRadioButton(tr("CLEAN_RUN"))               # Prevents env vars
        self.radio_automatic = QRadioButton(tr("AUTOMATIC_RUN"))       # Silent args like /VERYSILENT

        self.radio_group.addButton(self.radio_normal)
        self.radio_group.addButton(self.radio_clean)
        self.radio_group.addButton(self.radio_automatic)

        self.radio_normal.setChecked(True)  # Default selection

        # Group layout for radios
        radios_layout = QVBoxLayout()
        radios_layout.addWidget(self.radio_normal)
        radios_layout.addWidget(self.radio_clean)
        radios_layout.addWidget(self.radio_automatic)
        layout.addLayout(radios_layout)

        # Bottom buttons (Run / Stop)
        btn_bottom = QHBoxLayout()
        self.run_btn = QPushButton(tr("CONFIRM_AND_RUN"))
        self.force_stop_btn = QPushButton(tr("STOP_CURRENT"))

        if hasattr(self.parent, "stop_execution"):
            self.force_stop_btn.clicked.connect(self.parent.stop_execution)
        else:
            self.force_stop_btn.setEnabled(False)

        btn_bottom.addWidget(self.run_btn)
        btn_bottom.addWidget(self.force_stop_btn)
        layout.addLayout(btn_bottom)

        # Progress bar
        self.progress = QProgressBar()
        self.progress.setValue(0)
        layout.addWidget(self.progress)

        # Connections
        self.select_btn.clicked.connect(self.select_exes)
        self.select_folder_btn.clicked.connect(self.select_folder)
        self.remove_btn.clicked.connect(self.remove_selected)
        self.clear_btn.clicked.connect(self.clear_list)
        self.run_btn.clicked.connect(self.start_execution)

        # Control variables
        self.exe_queue = []
        self.current_index = 0

        # TOML paths
        self.safe_invocation = self.invocation_name.replace(" ", "_").lower()
        self.real_toml_path = zordeer_config_dir / f"invocation-info-{self.safe_invocation}.toml"
        self.temp_toml_path = zordeer_config_dir / f"invocation-info-{self.safe_invocation}_ztffrip.toml"

        # Backup of the original TOML in memory (loaded in start_execution)
        self._original_toml = None

    def remove_selected(self):
        selected = self.exe_list.selectedItems()
        if selected:
            self.exe_list.takeTopLevelItem(self.exe_list.indexOfTopLevelItem(selected[0]))
            if self.exe_list.topLevelItemCount() == 0:
                self.progress.setValue(0)

    def highlight_current_exe(self, exe_path):
        for i in range(self.exe_list.topLevelItemCount()):
            item = self.exe_list.topLevelItem(i)
            item_path = item.data(0, 0x0100)
            item.setSelected(item_path == exe_path)

    def keyPressEvent(self, event):
        if event.key() in (Qt.Key.Key_Return, Qt.Key.Key_Enter):
            # Prevents Enter from triggering something that is not selected
            return
        super().keyPressEvent(event)

    def clear_list(self):
        self.exe_list.clear()
        self.exe_queue = []
        self.current_index = 0
        self.progress.setValue(0)

    def select_folder(self):
        # Select a folder and add compatible files.
        folder = QFileDialog.getExistingDirectory(
            self, tr("SELECT_FOLDER"), "")
        
        if folder:
            folder_path = Path(folder)
            supported_extensions = {'.exe', '.msi', '.iso'}
            
            for file_path in folder_path.iterdir():
                if file_path.is_file():
                    # Check if file has a supported extension
                    if file_path.suffix.lower() in supported_extensions:
                        item = QTreeWidgetItem([file_path.name])
                        item.setData(0, 0x0100, str(file_path))
                        self.exe_list.addTopLevelItem(item)

    def select_exes(self):
        files, _ = QFileDialog.getOpenFileNames(
            self, tr("SELECT_EXECUTABLE"), "", tr("EXECUTABLE_FILE_FILTER"))
        for f in files:
            path_obj = Path(f)
            item = QTreeWidgetItem([path_obj.name])
            # Stores the full path to UserRole
            item.setData(0, 0x0100, str(path_obj))
            self.exe_list.addTopLevelItem(item)

    def start_execution(self):
        if self.exe_list.topLevelItemCount() == 0:
            QMessageBox.warning(self, tr("APP_NAME"), tr("NO_EXECUTABLE_SELECTED"))
            return

        self.set_execution_locked(True)

        # Load and store the original TOML once
        try:
            with open(self.real_toml_path, "r", encoding="utf-8") as f:
                self._original_toml = toml.load(f)
        except Exception as e:
            QMessageBox.critical(
                self,
                tr("APP_NAME"),
                tr("INVOCATION_INFO_ERROR", error=str(e))
            )
            return

        # Build queue
        self.exe_queue = [self.exe_list.topLevelItem(i).data(0, 0x0100)for i in range(self.exe_list.topLevelItemCount())]
        self.current_index = 0
        self.progress.setMaximum(len(self.exe_queue))
        self.progress.setValue(0)

        # Start execution
        self.run_next_exe()

    def run_next_exe(self):
        # End of the queue?
        if self.current_index >= len(self.exe_queue):
            # Clean up the temporary file and finish
            try:
                temp_path = Path(self.temp_toml_path)
                if temp_path.exists():
                    temp_path.unlink()
                    print(tr("DEBUG_TEMP_FILE_REMOVED", path=str(temp_path)))
            except Exception:
                pass
            print(tr("RUN_IN_PREFIX_DONE"))
            self.set_execution_locked(False)
            return

        # Current executable
        exe_path = self.exe_queue[self.current_index]

        self.highlight_current_exe(exe_path)
        QApplication.processEvents()

        # Temporary name/file (derived from the original safe name)
        temp_safe_name = f"{self.safe_invocation}_ztffrip".lower()
        self.temp_toml_path = str(zordeer_config_dir / f"invocation-info-{temp_safe_name}.toml")

        # Clone original and set the exe to run
        mod = dict(self._original_toml)
        mod["exec_path"] = exe_path
        mod["name"] = temp_safe_name  # Ensures that start_invocation validates the name

        # Clears the fields below when CLEAN_RUN is enabled.
        if self.radio_clean.isChecked():
            mod["language"] = ""
            mod["use_ms_language_code"] = False
            mod["force_opengl"] = False
            mod["env_vars"] = ""
            mod["invocation_args"] = ""
            mod["show_fps"] = False
            mod["fps_hud_type"] = ""

        elif self.radio_automatic.isChecked():
            # Normal values restored, but add silent args
            for key in ("language", "use_ms_language_code", "force_opengl", "env_vars",
                        "show_fps", "fps_hud_type"):
                if key in self._original_toml:
                    mod[key] = self._original_toml[key]
                else:
                    mod.pop(key, None)
            mod["invocation_args"] = "/VERYSILENT /NORESTART /SILENT /S /quiet /qn"

        else:  # Self.radio_normal.isChecked()
            # Just restore original TOML (no modifications)
            for key in ("language", "use_ms_language_code", "force_opengl", "env_vars",
                        "show_fps", "fps_hud_type", "invocation_args"):
                if key in self._original_toml:
                    mod[key] = self._original_toml[key]
                else:
                    mod.pop(key, None)

            mod["invocation_args"] = self._original_toml.get("invocation_args", "")

        # Save ONLY the temporary TOML
        try:
            with open(self.temp_toml_path, "w", encoding="utf-8") as f:
                toml.dump(mod, f)
        except Exception as e:
            QMessageBox.critical(self, tr("APP_NAME"), tr("FAILED_UPDATE_TOML", error=e))
            return

        print(tr(
            "RUNNING_IN_PREFIX",
            name=self.invocation_name,
            exe=exe_path,
            silent=self.radio_automatic.isChecked()
        ))

        # Run the temporary "invocation" (start_invocation resolves the path by safe name)
        self.parent.start_invocation(temp_safe_name)

        # Schedule periodic check for completion
        QTimer.singleShot(2000, self.wait_until_finished)

    def wait_until_finished(self):
        # Automatic installation
        if self.radio_automatic.isChecked():
            if self.parent.invocation_process and self.parent.invocation_process.poll() is None:
                QTimer.singleShot(2000, self.wait_until_finished)
                return

            self.parent.stop_execution()
            self.current_index += 1
            self.progress.setValue(self.current_index)
            self.run_next_exe()
            return

        # Clean run and normal run
        if not self._has_printed_waiting_message:
            print(tr("RUN_IN_PREFIX_WAITING"))
            self._has_printed_waiting_message = True

        started_prefix = tr("INVOCATION_STARTED", invocation_name="").split("{invocation_name}")[0].strip()
        if self.parent.windowTitle().startswith(started_prefix):
            QTimer.singleShot(2000, self.wait_until_finished)
        else:
            self.current_index += 1
            self.progress.setValue(self.current_index)
            self._has_printed_waiting_message = False
            self.run_next_exe()

        try:
            temp_path = Path(self.temp_toml_path)
            if temp_path.exists():
                temp_path.unlink()
        except Exception:
            pass

    def set_execution_locked(self, locked: bool):
        self.run_btn.setEnabled(not locked)
        self.select_btn.setEnabled(not locked)
        self.select_folder_btn.setEnabled(not locked)
        self.remove_btn.setEnabled(not locked)
        self.clear_btn.setEnabled(not locked)

        for radio in (self.radio_clean, self.radio_automatic, self.radio_normal):
            radio.setEnabled(not locked)

        if not locked:
            self.exe_list.clearSelection()
            for i in range(self.exe_list.topLevelItemCount()):
                self.exe_list.topLevelItem(i).setSelected(False)

    def closeEvent(self, event):
        # Cleanup if the window is manually closed
        try:
            temp_path = Path(self.temp_toml_path)
            if temp_path.exists():
                temp_path.unlink()
                print(tr("DEBUG_TEMP_FILE_REMOVED", path=str(temp_path)))
        except Exception:
            pass
        event.accept()

class ShortcutManager(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle(tr("SHORTCUTS_MANAGER_TITLE"))
        self.resize(340, 400)

        # Load invocations and shortcuts info
        self.invocations = self.load_invocations()
        self.shortcut_manager_info = self.load_shortcut_manager_info()

        # Current view: "desktop" or "menu"
        self.current_view = "desktop"
        self.checkbox_states = {"desktop": {}, "menu": {}}
        self.checkbox_widgets = {"desktop": {}, "menu": {}}

        # UI
        main_layout = QVBoxLayout(self)

        # Search bar
        self.search_bar = QLineEdit()
        self.search_bar.setPlaceholderText(tr("SEARCH"))
        self.search_bar.textChanged.connect(self.update_list_view)
        main_layout.addWidget(self.search_bar)

        # ComboBox to switch view
        self.view_combo = QComboBox()
        self.view_combo.addItems([tr("SHORTCUTS_OF_DESKTOP"), tr("SHORTCUTS_OF_MENU")])
        self.view_combo.currentIndexChanged.connect(self.update_list_view)
        main_layout.addWidget(self.view_combo)

        # Scroll area for checkboxes
        self.scroll_area = QScrollArea()
        self.scroll_area.setWidgetResizable(True)
        self.scroll_content = QWidget()
        self.scroll_layout = QVBoxLayout(self.scroll_content)
        self.scroll_layout.setContentsMargins(6, 6, 6, 6)
        self.scroll_layout.setSpacing(4)
        self.scroll_content.setLayout(self.scroll_layout)
        self.scroll_area.setWidget(self.scroll_content)
        main_layout.addWidget(self.scroll_area)

        # Select / Deselect All buttons
        select_layout = QHBoxLayout()
        self.select_all_btn = QPushButton(tr("SELECT_ALL_IN_MULTIPLE_EDIT"))
        self.select_all_btn.clicked.connect(self.select_all_checkboxes)
        self.deselect_all_btn = QPushButton(tr("DESELECT_ALL_IN_MULTIPLE_EDIT"))
        self.deselect_all_btn.clicked.connect(self.deselect_all_checkboxes)
        select_layout.addWidget(self.select_all_btn)
        select_layout.addWidget(self.deselect_all_btn)
        main_layout.addLayout(select_layout)

        # Own category checkbox
        self.own_category_cb = QCheckBox(tr("OWN_CATEGORY"))
        own_category_checked = self.shortcut_manager_info.get("own_category", True)
        self.own_category_cb.setChecked(own_category_checked)
        main_layout.addWidget(self.own_category_cb)

        # Folder selection
        grid = QGridLayout()

        # Desktop section
        grid.addWidget(QLabel(tr("DESKTOP_FOLDER")), 0, 0)
        self.desktop_dir_input = QLineEdit(self.shortcut_manager_info.get("desktop_dir", ""))
        grid.addWidget(self.desktop_dir_input, 1, 0, 1, 3)

        desktop_buttons = QHBoxLayout()
        desktop_browse = QPushButton(tr("BROWSE_BUTTON"))
        desktop_browse.clicked.connect(partial(self.browse_folder, self.desktop_dir_input))
        desktop_buttons.addWidget(desktop_browse)
        grid.addLayout(desktop_buttons, 2, 0, 1, 3)

        # .config section
        grid.addWidget(QLabel(tr("DOT_CONFIG_FOLDER")), 3, 0)
        self.dot_config_input = QLineEdit(self.shortcut_manager_info.get("dot_config_dir", ""))
        grid.addWidget(self.dot_config_input, 4, 0, 1, 3)

        config_buttons = QHBoxLayout()
        config_browse = QPushButton(tr("BROWSE_BUTTON"))
        config_browse.clicked.connect(partial(self.browse_folder, self.dot_config_input))
        config_buttons.addWidget(config_browse)
        grid.addLayout(config_buttons, 5, 0, 1, 3)

        # .local section
        grid.addWidget(QLabel(tr("DOT_LOCAL_FOLDER")), 6, 0)
        self.dot_local_input = QLineEdit(self.shortcut_manager_info.get("dot_local_dir", ""))
        grid.addWidget(self.dot_local_input, 7, 0, 1, 3)

        local_buttons = QHBoxLayout()
        local_browse = QPushButton(tr("BROWSE_BUTTON"))
        local_browse.clicked.connect(partial(self.browse_folder, self.dot_local_input))
        local_buttons.addWidget(local_browse)
        grid.addLayout(local_buttons, 8, 0, 1, 3)

        grid.setContentsMargins(0, 0, 0, 0)

        self.locations_widget = QWidget()
        self.locations_widget.setLayout(grid)
        self.locations_widget.hide()
        main_layout.addWidget(self.locations_widget)

        # Show locations and update button
        buttons_layout = QHBoxLayout()
        self.locations_btn = QPushButton(tr("SHORTCUTS_PATHS"))
        self.locations_btn.clicked.connect(self.toggle_locations)
        buttons_layout.addWidget(self.locations_btn)

        # Button to inform users about problems in Snap.
        self.paths_info_button = QPushButton()
        self.paths_info_button.setIcon(QIcon.fromTheme("help-about"))
        self.paths_info_button.clicked.connect(self.show_paths_info)
        buttons_layout.addWidget(self.paths_info_button)

        buttons_layout.addStretch()
        self.update_shortcuts = QPushButton(tr("UPDATE_SHORTCUTS"))
        self.update_shortcuts.clicked.connect(self.update_and_apply)
        buttons_layout.addWidget(self.update_shortcuts)
        main_layout.addLayout(buttons_layout)

        self.update_list_view()
        self.view_combo.setCurrentIndex(1)
        self.update_list_view()
        self.view_combo.setCurrentIndex(0)

    def show_paths_info(self):
        QMessageBox.information(
            self,
            tr("APP_NAME"),
            tr("SHORTCUTS_PATHS_INFO"))

    def toggle_locations(self):
        self.locations_widget.setVisible(not self.locations_widget.isVisible())

    def keyPressEvent(self, event):
        if event.key() in (Qt.Key.Key_Return, Qt.Key.Key_Enter):
            # Prevents Enter from triggering something that is not selected
            return
        super().keyPressEvent(event)

    def is_zordeer_desktop(self, file_path: Path) -> bool:
        if not file_path.exists() or file_path.suffix != ".desktop":
            return False

        if not file_path.stem.startswith("invocation-"):
            return False

        try:
            content = file_path.read_text(encoding="utf-8")
            return '--start-invocation' in content
        except Exception:
            return False

    # Checkbox Helpers
    def select_all_checkboxes(self):
        for cb in self.checkbox_widgets[self.current_view].values():
            if cb.isVisible():
                cb.setChecked(True)

    def deselect_all_checkboxes(self):
        for cb in self.checkbox_widgets[self.current_view].values():
            if cb.isVisible():
                cb.setChecked(False)

    # List view update
    def update_list_view(self):
        # Save current states
        for name, cb in self.checkbox_widgets[self.current_view].items():
            self.checkbox_states[self.current_view][name] = cb.isChecked()

        # Define current view
        self.current_view = "desktop" if self.view_combo.currentIndex() == 0 else "menu"

        # Get the appropriate folder path based on current view
        if self.current_view == "desktop":
            folder_path = Path(self.shortcut_manager_info.get("desktop_dir", ""))
        else:
            # For menu view, use .local/share/applications
            dot_local = Path(self.shortcut_manager_info.get("dot_local_dir", ""))
            folder_path = dot_local / "share" / "applications"
        
        existing_desktops = set()

        if folder_path.exists():
            safe_to_display = {data["safe_invocation_name"]: name
                              for name, data in self.invocations.items()
                              if "safe_invocation_name" in data}

            for f in folder_path.glob("invocation-*.desktop"):
                if self.is_zordeer_desktop(f):
                    safe_name = f.stem.replace("invocation-", "")
                    if safe_name in safe_to_display:
                        existing_desktops.add(safe_to_display[safe_name])

        # Clean up the old layout.
        while self.scroll_layout.count():
            item = self.scroll_layout.takeAt(0)
            if item.widget():
                item.widget().setParent(None)

        # Create/recreate checkboxes for this view.
        new_checkboxes = {}
        for inv in sorted(self.invocations.keys()):
            cb = QCheckBox(inv)
            cb.setChecked(self.checkbox_states[self.current_view].get(inv, inv in existing_desktops))
            new_checkboxes[inv] = cb
        self.checkbox_widgets[self.current_view] = new_checkboxes

        # Add only widgets filtered by the search.
        text = self.search_bar.text().lower()
        for name, cb in self.checkbox_widgets[self.current_view].items():
            if text in name.lower():
                self.scroll_layout.addWidget(cb)
                cb.show()
            else:
                cb.hide()

        self.scroll_layout.addStretch()

    # Loading and saving
    def load_invocations(self) -> dict:
        invs = {}
        if not zordeer_config_dir.exists():
            return invs
        for f in zordeer_config_dir.glob("invocation-info-*.toml"):
            try:
                content = f.read_text(encoding="utf-8")
                data = toml.loads(content)
                name = data.get("name")
                gui_path = data.get("gui_path", "")
                safe_invocation_name = f.stem.replace("invocation-info-", "")
                if name:
                    invs[name] = {"gui_path": gui_path, "safe_invocation_name": safe_invocation_name}
            except Exception:
                continue
        return invs

    def load_shortcut_manager_info(self):
        # Load directories from TOML settings.
        settings = load_settings()
        shortcut_section = settings.get("shortcut", {})

        # Get values from config or empty strings
        desktop_dir = shortcut_section.get("desktop_dir", "")
        dot_config_dir = shortcut_section.get("dot_config_dir", "")
        dot_local_dir = shortcut_section.get("dot_local_dir", "")
        own_category = shortcut_section.get("own_category", False)

        # If desktop_dir is empty in config, calculate default
        if not desktop_dir:
            desktop_dir = self.get_default_desktop_dir()

        # If dot_config_dir is empty in config, use default
        if not dot_config_dir:
            dot_config_dir = str(home_dir / ".config")

        # If dot_local_dir is empty in config, use default
        if not dot_local_dir:
            dot_local_dir = str(home_dir / ".local")

        # Processed settings for shortcut manager
        info = {
            "desktop_dir": str(desktop_dir),
            "dot_config_dir": str(dot_config_dir),
            "dot_local_dir": str(dot_local_dir),
            "own_category": own_category,
        }

        return info

    def get_default_desktop_dir(self):
        # Get default desktop directory from XDG user dirs.
        desktop_dir = home_dir / "Desktop"
        user_dirs_file = home_dir / ".config" / "user-dirs.dirs"
        if user_dirs_file.exists():
            try:
                with open(user_dirs_file, encoding="utf-8") as f:
                    for line in f:
                        line = line.strip()
                        if line.startswith("XDG_DESKTOP_DIR"):
                            path = line.split("=", 1)[1].strip().strip('"')
                            path = path.replace("$HOME", str(home_dir))
                            desktop_dir = Path(path)
                            break
            except Exception:
                pass
        return str(desktop_dir)

    def save_shortcut_manager_info(self):
        # Save directories to TOML settings.
        settings = load_settings()
        settings.setdefault("shortcut", {})
        settings["shortcut"]["desktop_dir"] = self.shortcut_manager_info.get("desktop_dir", "")
        settings["shortcut"]["dot_config_dir"] = self.shortcut_manager_info.get("dot_config_dir", "")
        settings["shortcut"]["dot_local_dir"] = self.shortcut_manager_info.get("dot_local_dir", "")
        settings["shortcut"]["own_category"] = self.own_category_cb.isChecked()
        save_settings(settings)

    def browse_folder(self, line_edit: QLineEdit):
        folder = QFileDialog.getExistingDirectory(self, tr("SELECT_FOLDER"), str(home_dir))
        if not folder:
            return

        new_folder = Path(folder)
        line_edit.setText(str(new_folder))

    def remove_all_zordeer_desktops(self, folder: Path):
        if not folder.exists():
            return

        for f in folder.glob("invocation-*.desktop"):
            try:
                if self.is_zordeer_desktop(f):
                    f.unlink()
            except Exception as e:
                print(tr("ERROR_REMOVING_FILE", file=f, error=e))

    def update_and_apply(self):
        desktop_dir = Path(self.desktop_dir_input.text().strip())
        dot_config_dir = Path(self.dot_config_input.text().strip())
        dot_local_dir = Path(self.dot_local_input.text().strip())
        
        # Define menu applications directory
        applications_dir = dot_local_dir / "share" / "applications"

        # Create desktop directory if it doesn't exist
        try:
            desktop_dir.mkdir(parents=True, exist_ok=True)
        except Exception:
            QMessageBox.warning(
                self,
                tr("APP_NAME"),
                tr("ERROR_CREATING_PATH", path=desktop_dir)
            )
            return

        # Check if .config directory exists
        if not dot_config_dir.exists():
            QMessageBox.warning(
                self,
                tr("APP_NAME"),
                tr("ERROR_CREATING_PATH", path=dot_config_dir)
            )
            return

        # Check if .local directory exists
        if not dot_local_dir.exists():
            QMessageBox.warning(
                self,
                tr("APP_NAME"),
                tr("ERROR_CREATING_PATH", path=dot_local_dir)
            )
            return
        
        applications_dir.mkdir(parents=True, exist_ok=True)

        old_desktop_dir = Path(self.shortcut_manager_info.get("desktop_dir", ""))
        old_dot_config_dir = Path(self.shortcut_manager_info.get("dot_config_dir", ""))
        old_dot_local_dir = Path(self.shortcut_manager_info.get("dot_local_dir", ""))
        
        # Remove old desktop files from previous locations
        self.remove_all_zordeer_desktops(old_desktop_dir)
        
        # Remove old menu files from previous .local/share/applications
        old_applications_dir = old_dot_local_dir / "share" / "applications"
        self.remove_all_zordeer_desktops(old_applications_dir)

        # Update info with new paths
        self.shortcut_manager_info["desktop_dir"] = str(desktop_dir)
        self.shortcut_manager_info["dot_config_dir"] = str(dot_config_dir)
        self.shortcut_manager_info["dot_local_dir"] = str(dot_local_dir)
        self.shortcut_manager_info["own_category"] = self.own_category_cb.isChecked()

        # Remove category files if checkbox is unchecked
        if not self.own_category_cb.isChecked():
            # Remove menu file from .config
            old_menu_file = old_dot_config_dir / "menus" / "applications-merged" / "Zordeer.menu"
            if old_menu_file.exists():
                try:
                    old_menu_file.unlink()
                except Exception as e:
                    print(tr("ERROR_REMOVING_FILE", file=str(old_menu_file), error=e))

            # Remove directory file from .local
            old_directory_file = old_dot_local_dir / "share" / "desktop-directories" / "Zordeer.directory"
            if old_directory_file.exists():
                try:
                    old_directory_file.unlink()
                except Exception as e:
                    print(tr("ERROR_REMOVING_FILE", file=str(old_directory_file), error=e))

        self.save_shortcut_manager_info()

        # Create category files if checkbox is checked
        if self.own_category_cb.isChecked():
            try:
                # Create .menu file in the configured .config directory
                menu_file_path = dot_config_dir / "menus" / "applications-merged" / "Zordeer.menu"
                menu_file_path.parent.mkdir(parents=True, exist_ok=True)
                
                menu_content = "\n".join([
                    "<Menu>",
                    "  <Name>Applications</Name>",
                    "  <Menu>",
                    "    <Name>Zordeer</Name>",
                    "    <Directory>Zordeer.directory</Directory>",
                    "    <Include>",
                    "      <Category>Zordeer</Category>",
                    "    </Include>",
                    "  </Menu>",
                    "</Menu>"
                ])
                menu_file_path.write_text(menu_content, encoding="utf-8")
            except Exception as e:
                print(tr("ERROR_CREATING_FILE", file="Zordeer.menu", error=e))

            try:
                # Create .directory file in the configured .local directory
                directory_file_path = dot_local_dir / "share" / "desktop-directories" / "Zordeer.directory"
                directory_file_path.parent.mkdir(parents=True, exist_ok=True)

                directory_content = "\n".join([
                    "[Desktop Entry]",
                    "Name=Zordeer",
                    "Icon=io.github.kyuyrii.zordeer.svg"
                ])
                directory_file_path.write_text(directory_content, encoding="utf-8")
            except Exception as e:
                print(tr("ERROR_CREATING_FILE", file="Zordeer.directory", error=e))

        # Remove existing .desktop files from new locations
        self.remove_all_zordeer_desktops(desktop_dir)
        self.remove_all_zordeer_desktops(applications_dir)

        # Create desktop shortcuts
        for name, cb in self.checkbox_widgets["desktop"].items():
            checked = cb.isChecked()
            self.create_desktop_file(name, checked, desktop_dir)

        # Create menu shortcuts
        for name, cb in self.checkbox_widgets["menu"].items():
            checked = cb.isChecked()
            self.create_desktop_file(name, checked, applications_dir)

        # Set executable permissions
        os.system(f'chmod +x "{desktop_dir}/"invocation-*.desktop 2>/dev/null')
        os.system(f'chmod +x "{applications_dir}/"invocation-*.desktop 2>/dev/null')

        self.update_list_view()
        self.accept()

    def create_desktop_file(self, name: str, checked: bool, folder: Path):
        if not checked:
            return

        invocation_data = self.invocations.get(name, {})
        safe_name = invocation_data.get("safe_invocation_name", "")

        desktop_file = folder / f"invocation-{safe_name}.desktop"

        if os.environ.get("SNAP"):
            current_zordeer = "snap run zordeer"
        elif os.environ.get("container") == "flatpak":
            current_zordeer = "flatpak run io.github.kyuyrii.zordeer"
        else:
            current_zordeer = os.path.abspath(sys.argv[0])

        current_zordeer += f' --start-invocation "{name}"'

        gui_path = self.invocations.get(name, {}).get("gui_path", "")

        categories = "Zordeer;" if self.own_category_cb.isChecked() else "Game;"

        content_lines = [
            "[Desktop Entry]",
            f"Name={name}",
            f"Exec={current_zordeer}",
            f"Icon={gui_path}",
            "StartupWMClass=io.github.kyuyrii.zordeer",
            f"Categories={categories}",
            "Keywords=gaming;invocation;",
            "Type=Application",
            "StartupNotify=false",
            "Terminal=false"
        ]

        try:
            with open(desktop_file, "w", encoding="utf-8") as f:
                f.write("\n".join(content_lines) + "\n")
        except Exception as e:
            print(tr("ERROR_CREATING_FILE", file=desktop_file, error=e))

class Zordeer(QMainWindow):
    def __init__(self):
        super().__init__()
        settings = load_settings()
        start_minimized = settings["window"].get("start_minimized", False)
        wanted = settings["design"].get("qt_style")

        size = settings["window"].get("windowSize")
        if size and isinstance(size, list) and len(size) == 2:
            self.resize(QSize(size[0], size[1]))
        else:
            self.resize(780, 640)

        # Only set if style exists on this system
        if wanted and wanted != "indefinite" and wanted in QStyleFactory.keys():
            QApplication.setStyle(wanted)
        self.setWindowTitle(tr("APP_NAME"))
        self.setMinimumSize(300, 160)
        self.invocation_process = None

        # Add the icon to the main window
        local_icons = ['io.github.kyuyrii.zordeer.svg', '/snap/zordeer/current/animarium/io.github.kyuyrii.zordeer.svg']

        icon_set = False
        for icon_file in local_icons:
            if Path(icon_file).exists():
                self.setWindowIcon(QIcon(icon_file))
                icon_set = True
                break
        if not icon_set:
            for name in ['io.github.kyuyrii.zordeer', 'zordeer']:
                icon = QIcon.fromTheme(name)
                if not icon.isNull():
                    self.setWindowIcon(icon)
                    break

        self.setup_directories()

        # Clean temporary extra TOML files
        self.cleanup_temp_toml_files()

        # Toolbar
        self.toolbar = QToolBar()
        self.toolbar.setMovable(True)
        self.toolbar.setFloatable(False)

        self.toolbar.setVisible(settings["design"].get("toolbar_visible", True))

        toolbar_position = settings["design"].get("toolbar_position", "top")

        if toolbar_position == "top":
            self.addToolBar(Qt.ToolBarArea.TopToolBarArea, self.toolbar)
        elif toolbar_position == "left":
            self.addToolBar(Qt.ToolBarArea.LeftToolBarArea, self.toolbar)
        elif toolbar_position == "right":
            self.addToolBar(Qt.ToolBarArea.RightToolBarArea, self.toolbar)
        elif toolbar_position == "bottom":
            self.addToolBar(Qt.ToolBarArea.BottomToolBarArea, self.toolbar)
        else:
            self.addToolBar(self.toolbar)  # fallback

        # MenuBar
        self.menu_bar = self.menuBar()

        # Menu INVOCATION
        self.invocation_menu = self.menu_bar.addMenu(tr("INVOCATION"))

        self.open_exe_path_action = QAction(tr("OPEN_EXEC_PATH"), self)
        self.open_exe_path_action.triggered.connect(partial(self.open_path, None, "exe"))
        self.invocation_menu.addAction(self.open_exe_path_action)

        self.open_prefix_path_action = QAction(tr("OPEN_PREFIX_PATH"), self)
        self.open_prefix_path_action.triggered.connect(partial(self.open_path, None, "prefix"))
        self.invocation_menu.addAction(self.open_prefix_path_action)

        self.run_in_prefix_action = QAction(tr("RUN_IN_PREFIX"), self)
        self.run_in_prefix_action.triggered.connect(self.run_in_prefix_dialog)
        self.invocation_menu.addAction(self.run_in_prefix_action)

        # Menu TRANSFER
        self.transfer_menu = self.menu_bar.addMenu(tr("TRANSFER"))

        self.transfer_runners_menu = QAction(tr("TRANSFER_RUNNERS"), self)
        self.transfer_runners_menu.triggered.connect(self.show_runner_transfer_dialog)
        self.transfer_menu.addAction(self.transfer_runners_menu)

        self.transfer_arts_menu = QAction(tr("TRANSFER_ARTS"), self)
        self.transfer_arts_menu.triggered.connect(self.open_transfer_arts)
        self.transfer_menu.addAction(self.transfer_arts_menu)

        # Menu MANAGE
        self.manage_menu = self.menu_bar.addMenu(tr("MANAGE"))

        self.multiple_create_action = QAction(tr("CREATE_MULTIPLE_INVOCATIONS"), self)
        self.multiple_create_action.triggered.connect(self.open_multiple_create_dialog)
        self.manage_menu.addAction(self.multiple_create_action)

        self.multiple_remove_invocations_action = QAction(tr("REMOVE_MULTIPLE_INVOCATIONS"), self)
        self.multiple_remove_invocations_action.triggered.connect(self.open_multiple_remove_invocations_dialog)
        self.manage_menu.addAction(self.multiple_remove_invocations_action)

        self.multiple_edit_invocations_action = QAction(tr("EDIT_MULTIPLE_INVOCATIONS"), self)
        self.multiple_edit_invocations_action.triggered.connect(self.open_multiple_edit_invocations_dialog)
        self.manage_menu.addAction(self.multiple_edit_invocations_action)

        self.shortcut_manager_action = QAction(tr("MANAGE_SHORTCUTS"), self)
        self.shortcut_manager_action.triggered.connect(self.open_shortcut_manager_dialog)
        self.manage_menu.addAction(self.shortcut_manager_action)

        # Menu EXTRA
        self.extra_menu = self.menu_bar.addMenu(tr("EXTRA"))

        self.settings_action = QAction(tr("ZORDEER_SETTINGS"), self)
        self.settings_action.triggered.connect(self.open_settings)
        self.extra_menu.addAction(self.settings_action)

        self.about_action = QAction(tr("ABOUT_ZORDEER"), self)
        self.about_action.triggered.connect(self.show_about)
        self.extra_menu.addAction(self.about_action)

        # Increase the size of icons
        toolbar_icon_size = settings["design"].get("toolbar_icon_size", 32)
        self.toolbar.setIconSize(QSize(toolbar_icon_size, toolbar_icon_size))

        self.run_action = QAction(QIcon.fromTheme("media-playback-start"), tr("START_INVOCATION"), self)
        self.run_action.triggered.connect(self.start_selected_invocation)
        self.toolbar.addAction(self.run_action)

        self.stop_execution_action = QAction(QIcon.fromTheme("media-playback-stop"), tr("STOP_INVOCATION"), self)
        self.stop_execution_action.triggered.connect(self.stop_execution)
        self.toolbar.addAction(self.stop_execution_action)

        self.start_random_invocation_action = QAction(QIcon.fromTheme("roll"), tr("START_RANDOM_INVOCATION"), self)
        self.start_random_invocation_action.triggered.connect(self.start_random_invocation)
        self.toolbar.addAction(self.start_random_invocation_action)

        self.add_invocation_action = QAction(QIcon.fromTheme("list-add"), tr("CREATE_INVOCATION"), self)
        self.add_invocation_action.triggered.connect(self.add_invocation)
        self.toolbar.addAction(self.add_invocation_action)

        self.edit_invocation_action = QAction(QIcon.fromTheme("document-edit"), tr("MODIFY_INVOCATION"), self)
        self.edit_invocation_action.triggered.connect(self.edit_invocation)
        self.toolbar.addAction(self.edit_invocation_action)

        self.search_action = QAction(QIcon.fromTheme("search"), tr("SEARCH"), self)
        self.search_action.triggered.connect(self.toggle_search_bar)
        self.toolbar.addAction(self.search_action)

        self.central_widget = QWidget()
        self.setCentralWidget(self.central_widget)
        self.main_layout = QVBoxLayout()
        self.central_widget.setLayout(self.main_layout)

        if not settings["design"].get("toolbar_visible", True):
            self.central_widget.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
            self.central_widget.customContextMenuRequested.connect(self.show_global_context_menu)

        self.toolbar.visibilityChanged.connect(self.save_toolbar_visibility)

        self.invocation_list_widget = QListWidget()
        self.invocation_list_widget.setSelectionMode(QAbstractItemView.SelectionMode.SingleSelection)

        self._last_selected_items = []
        self.invocation_list_widget.itemSelectionChanged.connect(self.ensure_selection)

        layout_mode = settings["design"].get("layout_mode", "classic")

        icon_width_classic = settings["design"].get("icon_width_classic", 420)
        icon_width_grid = settings["design"].get("icon_width_grid", 300)

        if layout_mode in ("list"):
            self.invocation_list_widget.setViewMode(QListWidget.ViewMode.ListMode)
            self.invocation_list_widget.setMovement(QListWidget.Movement.Static)
            self.invocation_list_widget.setResizeMode(QListWidget.ResizeMode.Adjust)
        elif layout_mode in ("grid"):
            self.invocation_list_widget.setViewMode(QListWidget.ViewMode.IconMode)
            self.invocation_list_widget.setFlow(QListView.Flow.LeftToRight)
            self.invocation_list_widget.setResizeMode(QListWidget.ResizeMode.Adjust)
            icon_width = icon_width_grid
            icon_height = int(icon_width * (620 / 1920))
            grid_width = icon_width + 5
            grid_height = icon_height + 30
            self.invocation_list_widget.setIconSize(QSize(icon_width, icon_height))
            self.invocation_list_widget.setGridSize(QSize(grid_width, grid_height))
            self.invocation_list_widget.setMovement(QListWidget.Movement.Static)
        elif layout_mode in ("classic"):
            self.invocation_list_widget.setViewMode(QListWidget.ViewMode.ListMode)
            self.invocation_list_widget.setMovement(QListWidget.Movement.Static)
            self.invocation_list_widget.setResizeMode(QListWidget.ResizeMode.Adjust)
            icon_width = icon_width_classic
            icon_height = int(icon_width * (620 / 1920))
            self.invocation_list_widget.setIconSize(QSize(icon_width, icon_height))

        self.main_layout.addWidget(self.invocation_list_widget)

        # Search bar (initially hidden)
        self.search_bar = QLineEdit()
        self.search_bar.setPlaceholderText(tr("SEARCH"))
        self.search_bar.textChanged.connect(self.filter_invocations)
        self.search_bar.setVisible(False)

        self.main_layout.insertWidget(0, self.search_bar)

        self.fix_invocation_paths()

        self.load_invocations()

        # Visibility based on Zordeer settings
        visible = settings["design"].get("search_bar_visible", False)
        self.search_bar.setVisible(visible)

        # ===== Context menu =====
        self.global_context_menu = QMenu(self)
        self.global_context_menu.clear()
        # Menu of toolbar
        self.global_context_menu.addAction(self.run_action)
        self.global_context_menu.addAction(self.stop_execution_action)
        self.global_context_menu.addAction(self.start_random_invocation_action)
        self.global_context_menu.addAction(self.add_invocation_action)
        self.global_context_menu.addAction(self.edit_invocation_action)
        self.global_context_menu.addAction(self.search_action)
        self.global_context_menu.addSeparator()

        # ===== System Tray Icon =====
        self.tray_icon = QSystemTrayIcon(self)
        self.tray_icon.setIcon(self.windowIcon())
        self.tray_icon.setToolTip(self.windowTitle())
        self.windowTitleChanged.connect(self.tray_icon.setToolTip)

        tray_menu = QMenu()

        # Run random invocation
        random_action = QAction(tr("START_RANDOM_INVOCATION"), tray_menu)
        random_action.setIcon(QIcon.fromTheme("roll"))
        random_action.triggered.connect(self.start_random_invocation)
        tray_menu.addAction(random_action)

        # Stop invocation
        tray_menu.addAction(self.stop_execution_action)

        # Show/Hide Window
        self.restore_action = QAction(tr("ZORDEER_TRAY_TOGGLE"), self)
        self.restore_action.setIcon(QIcon.fromTheme("visibility"))
        self.restore_action.triggered.connect(self.toggle_window)
        tray_menu.addAction(self.restore_action)

        # Quit
        quit_action = QAction(tr("CLOSE_ZORDEER"), self)
        quit_action.setIcon(QIcon.fromTheme("dialog-close"))
        quit_action.triggered.connect(self.close)
        tray_menu.addAction(quit_action)

        self.tray_icon.setContextMenu(tray_menu)
        self.tray_icon.show()

        start_minimized = settings["window"].get("start_minimized", False)
        if start_minimized:
            self.hide()
        elif settings["window"].get("isFullScreen", False):
            self.showFullScreen()
        elif settings["window"].get("isMaximized", False):
            self.showMaximized()
        else:
            self.show()

        atexit.register(self.kill_invocation_process_on_exit)
        self.transfer_successful = False

        self.inhibit_cookie = None

    def show_global_context_menu(self, pos):
        global_pos = self.central_widget.mapToGlobal(pos)
        self.global_context_menu.popup(global_pos)

    def save_toolbar_visibility(self, visible):
        settings = load_settings()
        settings["design"]["toolbar_visible"] = visible
        save_settings(settings)

        if not visible:
            self.central_widget.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
            self.central_widget.customContextMenuRequested.connect(self.show_global_context_menu)
        else:
            self.central_widget.setContextMenuPolicy(Qt.ContextMenuPolicy.NoContextMenu)

    def toggle_search_bar(self):
        visible = not self.search_bar.isVisible()
        self.search_bar.setVisible(visible)
        if visible:
            self.search_bar.setFocus()
            self.search_bar.selectAll()
        else:
            self.search_bar.clear()
            self.filter_invocations("")

    def ensure_selection(self):
        selected_items = self.invocation_list_widget.selectedItems()
        if not selected_items and self._last_selected_items:
            for item in self._last_selected_items:
                item.setSelected(True)
        else:
            self._last_selected_items = selected_items.copy()

    def start_random_invocation(self):
        if self.invocation_list_widget.count() == 0:
            QMessageBox.information(
                self, tr("APP_NAME"), tr("NO_INVOCATIONS_FOUND"))
            return
        idx = random.randint(0, self.invocation_list_widget.count() - 1)
        invocation_name = self.invocation_list_widget.item(idx).text()
        self.start_invocation(invocation_name)

    def toggle_window(self):
        if self.isVisible():
            self.hide()
        else:
            self.show()
            self.raise_()
            self.activateWindow()

    def closeEvent(self, event):
        settings = load_settings()
        settings["design"]["search_bar_visible"] = self.search_bar.isVisible()
        settings["design"]["toolbar_visible"] = self.toolbar.isVisible()
        area = self.toolBarArea(self.toolbar)
        if area == Qt.ToolBarArea.TopToolBarArea:
            settings["design"]["toolbar_position"] = "top"
        elif area == Qt.ToolBarArea.LeftToolBarArea:
            settings["design"]["toolbar_position"] = "left"
        elif area == Qt.ToolBarArea.RightToolBarArea:
            settings["design"]["toolbar_position"] = "right"
        elif area == Qt.ToolBarArea.BottomToolBarArea:
            settings["design"]["toolbar_position"] = "bottom"
        settings["window"]["windowSize"] = [self.size().width(), self.size().height()]
        settings["window"]["isMaximized"] = self.isMaximized()
        settings["window"]["isFullScreen"] = self.isFullScreen()
        settings["window"]["start_minimized"] = not self.isVisible()
        # Checks if the title contains the string "INVOCATION_STARTED"
        if self.windowTitle().startswith(tr("INVOCATION_STARTED", invocation_name="").split("{invocation_name}")[0].strip()):
            reply = QMessageBox.question(
                self,
                tr("APP_NAME"),
                tr("CONFIRM_CLOSE_MESSAGE"),
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )
            if reply == QMessageBox.StandardButton.Yes:
                self.stop_execution()
                save_settings(settings)
                QApplication.quit()
            else:
                event.ignore()
        else:
            save_settings(settings)
            QApplication.quit()

    def filter_invocations(self, text):
        text = text.lower()
        first_visible_item = None
        current_item = self.invocation_list_widget.currentItem()

        for i in range(self.invocation_list_widget.count()):
            item = self.invocation_list_widget.item(i)
            visible = text in item.text().lower()
            item.setHidden(not visible)

            if visible and first_visible_item is None:
                first_visible_item = item

        # If the currently selected item is no longer visible, select the first visible one
        if current_item is None or current_item.isHidden():
            if first_visible_item:
                self.invocation_list_widget.setCurrentItem(first_visible_item)

    def stop_execution(self):
        if self.inhibit_cookie is not None:
            try:
                bus = dbus.SessionBus()
                request = bus.get_object("org.freedesktop.portal.Desktop", str(self.inhibit_cookie))
                dbus.Interface(request, "org.freedesktop.portal.Request").Close()
            except:
                pass
            self.inhibit_cookie = None
        self.setWindowTitle(tr("APP_NAME"))

        # Try to kill by the real executable
        if hasattr(self, "last_executable") and self.last_executable:
            exe_name = Path(self.last_executable).name.lower()
            found = False
            for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
                try:
                    cmdline = " ".join(proc.info['cmdline'] or []).lower()
                    if exe_name in cmdline:
                        print(tr("STOP_KILL_PROCESS", pid=proc.pid, exe=exe_name))
                        try:
                            proc.kill()
                            print(tr("STOP_PROCESS_SUCCESS", pid=proc.pid))
                        except Exception as e:
                            print(tr("STOP_KILL_ERROR", pid=proc.pid, error=e))
                        found = True
                except (psutil.NoSuchProcess, psutil.AccessDenied) as e:
                    print(tr("STOP_ACCESS_ERROR", error=e))
                    continue
            if found:
                print(tr("STOP_INVOCATION_SUCCESS"))
            else:
                print(tr("STOP_NO_PROCESS_FOUND"))
        else:
            print(tr("STOP_NO_INVOCATION_ACTIVE"))

        # Clear internal references
        if hasattr(self, "invocation_process"):
            self.invocation_process = None
        if hasattr(self, "last_executable"):
            self.last_executable = None

        # Unmount/eject mounted ISO, if present
        mounted_iso_info = zordeer_dir / "config" / "mounted_iso_info.toml"

        if mounted_iso_info.exists():
            try:
                with mounted_iso_info.open("r", encoding="utf-8") as f:
                    iso_info = toml.load(f)

                loop_device = iso_info.get("loop_device")
                if loop_device:
                    # Unmount
                    result_unmount = subprocess.run(
                        ["udisksctl", "unmount", "-b", loop_device],
                        capture_output=True, text=True
                    )
                    if result_unmount.returncode != 0:
                        print(tr("ISO_UNMOUNT_FAILED", device=loop_device, error=result_unmount.stderr.strip()))

                    # Delete loop device
                    result_delete = subprocess.run(
                        ["udisksctl", "loop-delete", "-b", loop_device],
                        capture_output=True, text=True
                    )
                    if result_delete.returncode != 0:
                        print(tr("ISO_LOOP_DELETE_FAILED", device=loop_device, error=result_delete.stderr.strip()))
                    else:
                        print(tr("ISO_UNMOUNTED", device=loop_device))

            except Exception as e:
                print(tr("ISO_UNMOUNT_EXCEPTION", error=str(e)))

            finally:
                # Remove info file no matter what
                mounted_iso_info.unlink(missing_ok=True)

    def kill_invocation_process_on_exit(self):
        if self.invocation_process and self.invocation_process.poll() is None:
            print(tr("ZORDEER_CLOSED"))
            self.stop_execution()

    def setup_directories(self):
        """Creates the main Zordeer directory structure using pathlib with real folder names."""
        base = zordeer_dir
        subdirs = [
            base / "invocation",
            base / "runner",
            base / "config",
            base / "art",
            base / "umu"
        ]

        for subdir in subdirs:
            subdir.mkdir(parents=True, exist_ok=True)

    def load_invocations(self):
        """Loads invocation data from TOML files and populates the list, preserving the selection by TOML file."""

        # Save scroll position
        scroll_pos = self.invocation_list_widget.verticalScrollBar().value()

        # Save which file was selected
        selected_invocation_file = None
        current_item = self.invocation_list_widget.currentItem()
        if current_item:
            selected_invocation_file = current_item.data(Qt.ItemDataRole.UserRole)

        self.invocation_list_widget.clear()

        if not zordeer_config_dir.exists():
            return

        invocation_files = sorted(zordeer_config_dir.glob("invocation-info-*.toml"))
        
        restored_selection_item = None
        for invocation_file in invocation_files:
            try:
                with open(invocation_file, encoding="utf-8") as f:
                    invocation_data = toml.load(f)
                
                item = self.add_invocation_to_list(invocation_data)
                item.setData(Qt.ItemDataRole.UserRole, invocation_file)

                if selected_invocation_file and selected_invocation_file == invocation_file:
                    restored_selection_item = item
                    
            except (IOError, toml.TomlDecodeError) as e:
                print(tr("ERROR_LOADING_FILE", file=invocation_file, error=e))

        # Restores the selection
        if restored_selection_item:
            self.invocation_list_widget.setCurrentItem(restored_selection_item)
        else:
            if self.invocation_list_widget.count() > 0:
                self.invocation_list_widget.setCurrentRow(0)

        # Reapply the search filter
        if hasattr(self, "search_bar"):
            current_text = self.search_bar.text()
            self.filter_invocations(current_text)

        # Restore scroll position
        self.invocation_list_widget.verticalScrollBar().setValue(scroll_pos)

    def fix_invocation_paths(self):
        # Fix paths in all invocations if they don't match current zordeer_dir
        current_base = str(zordeer_dir).replace('/App/Zordeer', '')

        for toml_file in zordeer_config_dir.glob("invocation-info-*.toml"):
            try:
                with open(toml_file, 'r+', encoding='utf-8') as f:
                    data = toml.load(f)
                    modified = False
                    
                    for field in ['exec_path', 'prefix_path', 'art_path', 'gui_path']:
                        if field in data and '/App/Zordeer/' in data[field]:
                            old_base = data[field].split('/App/Zordeer/')[0]
                            if old_base != current_base:
                                data[field] = data[field].replace(old_base, current_base, 1)
                                modified = True
                    
                    if modified:
                        f.seek(0)
                        toml.dump(data, f)
                        f.truncate()
            except:
                continue

    def add_invocation(self):
        dialog = AddInvocationDialog(self)
        dialog.invocation_saved.connect(self.load_invocations)
        dialog.exec()

    def open_multiple_create_dialog(self):
        dialog = MultipleCreateInvocationsDialog(self)
        dialog.invocations_saved.connect(self.load_invocations)  # Update list
        dialog.exec()

    def open_multiple_remove_invocations_dialog(self):
        dialog = MultipleRemoveInvocationDialog(self)
        dialog.exec()

    def open_multiple_edit_invocations_dialog(self):
        dialog = MultipleEditInvocationDialog(self)
        dialog.exec()

    def open_shortcut_manager_dialog(self):
        dialog = ShortcutManager(self)
        dialog.exec()

    def edit_invocation(self):
        invocation_name = self.get_selected_invocation()
        if not invocation_name:
            QMessageBox.warning(self, tr("APP_NAME"), tr("NO_INVOCATION_SELECTED_ERROR"))
            return

        safe_invocation_name = invocation_name.replace(" ", "_").lower()
        invocation_file_path = zordeer_config_dir / f"invocation-info-{safe_invocation_name}.toml"

        try:
            with invocation_file_path.open('r', encoding='utf-8') as f:
                invocation_data = toml.load(f)
        except (IOError, toml.TomlDecodeError):
            QMessageBox.critical(self, tr("APP_NAME"), tr("INVOCATION_INFO_ERROR", name=invocation_name))
            return

        dialog = AddInvocationDialog(self, invocation_data)
        dialog.invocation_saved.connect(self.load_invocations)
        dialog.exec()

    def start_invocation(self, item_or_name):
        if self.windowTitle().startswith(tr("INVOCATION_STARTED", invocation_name="").split("{invocation_name}")[0].strip()):
            reply = QMessageBox.question(
                self,
                tr("APP_NAME"),
                tr("INVOCATION_ALREADY_ACTIVE"),
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )

            if reply == QMessageBox.StandardButton.Yes:
                self.stop_execution()
            else:
                return

        if not item_or_name:
            QMessageBox.warning(self, tr("APP_NAME"), tr("NO_INVOCATION_SELECTED_ERROR"))
            return

        # Accepts QListWidgetItem or string
        if isinstance(item_or_name, QListWidgetItem):
            invocation_name = item_or_name.text()
        else:
            invocation_name = str(item_or_name)

        print(tr("STARTING_INVOCATION", name=invocation_name))

        safe_invocation_name = invocation_name.replace(" ", "_").lower()
        invocation_file_path = zordeer_config_dir / f"invocation-info-{safe_invocation_name}.toml"

        try:
            with invocation_file_path.open('r', encoding='utf-8') as f:
                invocation_data = toml.load(f)
            print(tr("INVOCATION_INFO_LOADED", name=invocation_name))

            runner_base_path = zordeer_dir / "runner" / invocation_data['runner']
            exec_path_full = Path(invocation_data['exec_path'])
            prefix_path = Path(invocation_data['prefix_path'])

            if not exec_path_full.exists():
                QMessageBox.critical(
                    self,
                    tr("APP_NAME"),
                    tr("EXEC_PATH_NOT_FOUND", path=str(exec_path_full))
                )
                return

            if not prefix_path.exists():
                QMessageBox.critical(
                    self,
                    tr("APP_NAME"),
                    tr("PREFIX_PATH_NOT_FOUND", path=str(prefix_path))
                )
                return

            if exec_path_full.suffix.lower() not in (".exe", ".msi", ".iso"):
                if str(exec_path_full) == ".":
                    reply = QMessageBox.question(
                        self,
                        tr("APP_NAME"),
                        tr("NO_EXEC_PATH"),
                        QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
                    )
                else:
                    reply = QMessageBox.question(
                        self,
                        tr("APP_NAME"),
                        tr("EXEC_PATH_INVALID_CONFIRM", path=str(exec_path_full)),
                        QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
                    )
                if reply == QMessageBox.StandardButton.No:
                    return

            # exec_path_full is the original path of the TOML (can be .iso)
            iso_path = exec_path_full

            if iso_path.suffix.lower() == ".iso":
                mount_point = None
                loop_device = None

                # Check if the ISO is already mounted
                for line in open("/proc/mounts"):
                    dev, mnt = line.split()[:2]
                    if dev.startswith("/dev/loop") and iso_path.as_posix() in subprocess.getoutput(f"losetup {dev}"):
                        mount_point = Path(mnt)
                        loop_device = dev
                        print(tr("ISO_ALREADY_MOUNTED", mount=str(mount_point)))
                        break

                # If not mounted, create loop device and mount it
                if not mount_point:
                    # Create loop device
                    result = subprocess.run(
                        ["udisksctl", "loop-setup", "-f", str(iso_path)],
                        capture_output=True, text=True
                    )
                    if result.returncode != 0:
                        QMessageBox.critical(None, tr("APP_NAME"), tr("LOOP_DEVICE_CREATION_FAILED", error=result.stderr))
                        return

                    match = re.search(r'/dev/loop\d+', result.stdout)
                    if not match:
                        QMessageBox.critical(None, tr("APP_NAME"), tr("LOOP_DEVICE_NOT_FOUND"))
                        return
                    loop_device = match.group(0)

                    # Mount loop device
                    result_mount = subprocess.run(
                        ["udisksctl", "mount", "-b", loop_device],
                        capture_output=True, text=True
                    )
                    if result_mount.returncode != 0:
                        QMessageBox.critical(None, tr("APP_NAME"), tr("ISO_MOUNT_FAILED", error=result_mount.stderr))
                        return

                    # Get mount point
                    match = re.search(r'at (/.+)', result_mount.stdout)
                    mount_point = Path(match.group(1)) if match else None
                    if not mount_point or not mount_point.exists():
                        QMessageBox.critical(None, tr("APP_NAME"), tr("ISO_MOUNT_POINT_NOT_FOUND"))
                        return

                # Look for the .exe inside the ISO
                exe_files = []
                for _ in range(20):
                    exe_files = list(mount_point.glob("setup.exe")) or list(mount_point.rglob("*.exe"))
                    if exe_files:
                        break
                    time.sleep(0.3)
                if not exe_files:
                    QMessageBox.critical(None, tr("APP_NAME"), tr("ISO_NO_EXE_FOUND"))
                    return

                exec_path_full = exe_files[0]
                print(tr("ISO_MOUNTED_EXE_FOUND", iso=str(iso_path), exe=str(exec_path_full)))

                # Save mounted ISO info
                mounted_iso_info = zordeer_dir / "config" / "mounted_iso_info.toml"
                with mounted_iso_info.open("w", encoding="utf-8") as f:
                    toml.dump({
                        "iso_path": str(iso_path),
                        "loop_device": loop_device,
                        "mount_point": str(mount_point)
                    }, f)

            runner_name = (invocation_data.get("runner") or load_settings()["other"].get("default_runner", "")).strip()

            # Handle undefined or empty runner
            if not runner_name or runner_name.lower() == "indefinite":
                QMessageBox.warning(self, tr("APP_NAME"), tr("DEFAULT_RUNNER_INDEFINITE"))
                return

            # Check if UMU launcher is enabled
            settings = load_settings()
            umu_global = settings["other"].get("umu_global", False)
            use_umu = invocation_data.get('use_umu', False) or umu_global
            umu_version = settings["other"].get("umu_version", "").strip()

            if use_umu and runner_name.lower() != "wine":
                # Validate UMU version
                if not umu_version or umu_version.lower() == "indefinite":
                    QMessageBox.warning(self, tr("APP_NAME"), tr("DEFAULT_UMU_INDEFINITE"))
                    return

                # Get UMU path
                umu_path = zordeer_dir / "umu" / umu_version / "umu-run"
                if not umu_path.exists():
                    QMessageBox.critical(
                        self,
                        tr("APP_NAME"),
                        tr("UMU_NOT_FOUND", path=str(umu_path.parent))
                    )
                    return

                # UMU launcher command structure
                command = [str(umu_path), str(exec_path_full)]

            else:
                # Check if it's Wine.
                if runner_name.lower() == "wine":
                    wine_path = shutil.which("wine")
                    if not wine_path:
                        QMessageBox.critical(self, tr("APP_NAME"), tr("WINE_NOT_FOUND"))
                        return
                    command = [wine_path, str(exec_path_full)]
                else:
                    # Try using a custom runner
                    proton_script = zordeer_dir / "runner" / runner_name / "proton"
                    if not proton_script.exists():
                        QMessageBox.critical(
                            self,
                            tr("APP_NAME"),
                            tr("ERROR_RUNNER", path=str(proton_script.parent))
                        )
                        return

                    command = [str(proton_script), "run", str(exec_path_full)]

            # Invocation arguments
            invocation_args_str = invocation_data.get('invocation_args', '').strip()
            if invocation_args_str:
                command.extend(invocation_args_str.split())

            # Environment variables
            env = os.environ.copy()
            env['WINEPREFIX'] = str(prefix_path)

            if use_umu and runner_name.lower() != "wine":
                # Changes the folder used by UMU
                if 'XDG_DATA_HOME' not in env:
                    env['XDG_DATA_HOME'] = str(home_dir / "App" / "UMU")
                env['PROTONPATH'] = str(zordeer_dir / "runner" / runner_name)
            else:
                # Set Steam environment variables only for Proton
                if runner_name.lower() != "wine":
                    env['STEAM_COMPAT_DATA_PATH'] = str(prefix_path)
                    env['STEAM_COMPAT_CLIENT_INSTALL_PATH'] = str(zordeer_dir / ".steam" / "steam")
                    env['STEAM_EXTRA_COMPAT_TOOLS_PATHS'] = str(runner_base_path)

            # Symlink "pfx" > prefix_path (only for non-UMU)
            if not use_umu:
                pfx_symlink = prefix_path / "pfx"
                try:
                    if not pfx_symlink.exists():
                        if pfx_symlink.is_symlink():
                            pfx_symlink.unlink()
                        pfx_symlink.symlink_to(prefix_path)
                        print(tr("SYMLINK_CREATED", symlink=str(pfx_symlink), prefix=str(prefix_path)))
                except Exception as e:
                    print(tr("SYMLINK_ERROR", error=e))

            # Language configuration
            language = invocation_data.get('language', '').strip()
            locale_code = ""
            env_prefix = ["env"]
            if language:
                try:
                    if "(" in language and ")" in language:
                        locale_code = language.split("(")[1].replace(")", "").strip()
                    else:
                        locale_code = language
                    env_prefix.append(f"LC_ALL={locale_code}")
                    env_prefix.append(f"LANG={locale_code}")
                    env_prefix.append(f"LANGUAGE={locale_code}")
                except Exception as e:
                    print(tr("LANGUAGE_SET_ERROR", error=e))

            # Map to MS language code
            locale_to_ms_code = {
                "en_US.UTF-8": "ENU",
                "pt_BR.UTF-8": "PTB",
                "pt_PT.UTF-8": "PTG",
                "es_ES.UTF-8": "ESN",
                "es_MX.UTF-8": "ESM",
                "fr_FR.UTF-8": "FRA",
                "de_DE.UTF-8": "DEU",
                "it_IT.UTF-8": "ITA",
                "ru_RU.UTF-8": "RUS",
                "uk_UA.UTF-8": "UKR",
                "pl_PL.UTF-8": "PLK",
                "cs_CZ.UTF-8": "CSY",
                "sk_SK.UTF-8": "SKY",
                "hu_HU.UTF-8": "HUN",
                "ro_RO.UTF-8": "ROM",
                "nl_NL.UTF-8": "NLD",
                "sv_SE.UTF-8": "SVE",
                "nb_NO.UTF-8": "NOR",
                "da_DK.UTF-8": "DAN",
                "fi_FI.UTF-8": "FIN",
                "el_GR.UTF-8": "ELL",
                "bg_BG.UTF-8": "BGR",
                "ja_JP.UTF-8": "JPN",
                "ko_KR.UTF-8": "KOR",
                "zh_CN.UTF-8": "CHS",
                "zh_TW.UTF-8": "CHT",
                "ar_SA.UTF-8": "ARA",
                "fa_IR.UTF-8": "FAR",
                "tr_TR.UTF-8": "TRK",
                "hi_IN.UTF-8": "HIN",
                "th_TH.UTF-8": "THA",
                "he_IL.UTF-8": "HEB",
            }
            if locale_code and invocation_data.get('use_ms_language_code', False):
                ms_lang_code = locale_to_ms_code.get(locale_code)
                if ms_lang_code:
                    command.append(f"-language={ms_lang_code}")

            # FPS HUD
            show_fps = invocation_data.get('show_fps', False)
            fps_hud_type = invocation_data.get('fps_hud_type', '')
            if show_fps:
                if fps_hud_type == "FPS_DXVK_HUD":
                    env_prefix.append("DXVK_HUD=fps,gpuload,frametimes")
                elif fps_hud_type == "FPS_GALLIUM_HUD":
                    env_prefix.append("GALLIUM_HUD=fps+cpu,frametime")
                elif fps_hud_type == "FPS_MANGOHUD":
                    env_prefix.append("MANGOHUD=1")

            # OpenGL (wined3d)
            if invocation_data.get('force_opengl', False):
                env_prefix.append("PROTON_USE_WINED3D=1")

            # Extra environment variables
            env_vars_str = invocation_data.get('env_vars', '').strip()
            if env_vars_str:
                for item in env_vars_str.split():
                    if '=' in item:
                        env_prefix.append(item)

            # Prefix in the final command
            command = env_prefix + command

            # Simple debug version showing only UMU-related and important env vars
            debug_vars = []
            if use_umu and runner_name.lower() != "wine":
                debug_vars.append(f"WINEPREFIX='{env['WINEPREFIX']}'")
                if 'PROTONPATH' in env:
                    debug_vars.append(f"PROTONPATH='{env['PROTONPATH']}'")
                if 'XDG_DATA_HOME' in env:
                    debug_vars.append(f"XDG_DATA_HOME='{env['XDG_DATA_HOME']}'")
            else:
                debug_vars.append(f"WINEPREFIX='{env['WINEPREFIX']}'")
                # Only show Steam variables if they exist and runner is not Wine
                if runner_name.lower() != "wine":
                    if 'STEAM_COMPAT_DATA_PATH' in env:
                        debug_vars.append(f"STEAM_COMPAT_DATA_PATH='{env['STEAM_COMPAT_DATA_PATH']}'")
                    if 'STEAM_COMPAT_CLIENT_INSTALL_PATH' in env:
                        debug_vars.append(f"STEAM_COMPAT_CLIENT_INSTALL_PATH='{env['STEAM_COMPAT_CLIENT_INSTALL_PATH']}'")
                    if 'STEAM_EXTRA_COMPAT_TOOLS_PATHS' in env:
                        debug_vars.append(f"STEAM_EXTRA_COMPAT_TOOLS_PATHS='{env['STEAM_EXTRA_COMPAT_TOOLS_PATHS']}'")

            # Remove "env" from the beginning of command since we're showing env vars separately
            if command[0] == "env":
                command_without_env = command[1:]
            else:
                command_without_env = command

            debug_command = " ".join(debug_vars + command_without_env)
            print(tr("RUNNING_COMMAND", command=debug_command))

            self.invocation_process = subprocess.Popen(
                command,
                env=env,
                cwd=str(exec_path_full.parent),
                stdout=sys.stdout,
                stderr=sys.stderr
            )
            try:
                bus = dbus.SessionBus()
                portal = bus.get_object("org.freedesktop.portal.Desktop", "/org/freedesktop/portal/desktop")
                iface = dbus.Interface(portal, "org.freedesktop.portal.Inhibit")
                self.inhibit_cookie = iface.Inhibit("", 8, {"reason": "Zordeer invocation"})
            except:
                self.inhibit_cookie = None
            self.last_wineprefix = env.get("WINEPREFIX")
            self.last_executable = str(exec_path_full)
            self.setWindowTitle(tr("INVOCATION_STARTED", invocation_name=invocation_name))

            # Give Proton some time to spawn child processes
            time.sleep(3)

            # Capture real process
            try:
                parent = psutil.Process(self.invocation_process.pid)
                children = parent.children(recursive=True)
                if children:
                    self.real_invocation_process = children[-1]
                    print(tr("DEBUG_REAL_INVOCATION_INITIATED", pid=self.real_invocation_process.pid))
                else:
                    self.real_invocation_process = None
            except psutil.NoSuchProcess:
                self.real_invocation_process = None

        except (IOError, toml.TomlDecodeError):
            QMessageBox.critical(self, tr("APP_NAME"), tr("INVOCATION_INFO_ERROR", name=invocation_name))
        except Exception as e:
            QMessageBox.critical(self, tr("APP_NAME"), tr("INVOCATION_START_ERROR", error=str(e)))

    def start_selected_invocation(self):
        invocation_name = self.get_selected_invocation()
        self.start_invocation(invocation_name)

    def get_selected_invocation(self):
        item = self.invocation_list_widget.currentItem()
        if item:
            return item.text()
        return None

    def add_invocation_to_list(self, invocation_data):
        invocation_name = invocation_data['name']

        item = QListWidgetItem()
        item.setText(invocation_name)

        # Bold
        font = item.font()
        font.setBold(True)
        item.setFont(font)

        # Decide which image to use
        art_path_to_use = None
        layout_mode = settings["design"].get("layout_mode", "classic")

        art_path_to_use = invocation_data.get("art_path")

        # Art as an icon
        icon = None
        if art_path_to_use:
            art_file = Path(art_path_to_use)
            if art_file.exists():
                pixmap = QPixmap(str(art_file))
                if not pixmap.isNull():
                    pixmap = pixmap.scaled(
                        self.invocation_list_widget.iconSize(),
                        Qt.AspectRatioMode.KeepAspectRatio,
                        Qt.TransformationMode.SmoothTransformation
                    )
                    icon = QIcon()
                    icon.addPixmap(pixmap, QIcon.Mode.Normal, QIcon.State.Off)
                    icon.addPixmap(pixmap, QIcon.Mode.Selected, QIcon.State.Off)
                    icon.addPixmap(pixmap, QIcon.Mode.Active, QIcon.State.Off)
                    icon.addPixmap(pixmap, QIcon.Mode.Disabled, QIcon.State.Off)

        if icon is None:
            icon = self.windowIcon()

        if layout_mode not in ["list"] and icon is not None:
            item.setIcon(icon)

        self.invocation_list_widget.addItem(item)
        return item

    def show_runner_transfer_dialog(self):
        dialog = RunnerTransferDialog(self)
        dialog.exec()

    def open_transfer_arts(self):
        self.run_sgdb_auto_transfer()

    def run_sgdb_auto_transfer(self):
        def get_score(item):
            return item.get("score", 0)

        settings = load_settings()
        api_key = settings["other"].get("sgdb_apikey", "").strip()
        if not api_key:
            QMessageBox.warning(self, tr("APP_NAME"), tr("API_KEY_SAVE_FIRST"))
            return

        headers = {"Authorization": f"Bearer {api_key}"}

        if not any(zordeer_config_dir.glob("invocation-info-*.toml")):
            QMessageBox.warning(self, tr("APP_NAME"), tr("NO_INVOCATIONS_FOUND"))
            return

        # Invocations list
        invocations = []
        for toml_file in zordeer_config_dir.glob("invocation-info-*.toml"):
            try:
                with open(toml_file, "r", encoding="utf-8") as fh:
                    inv = toml.load(fh)
                inv_name = inv.get("name") or inv.get("display_name") or inv.get("id")
                art_path = inv.get("art_path", "")
                gui_path = inv.get("gui_path", "")
                # Also includes cases where paths are filled in but the files do not exist
                art_missing = not art_path or not Path(art_path).exists()
                gui_missing = not gui_path or not Path(gui_path).exists()
                if inv_name and (art_missing or gui_missing):
                    invocations.append((inv_name, toml_file))
            except Exception:
                continue

        if not invocations:
            QMessageBox.information(self, tr("APP_NAME"), tr("AUTO_TRANSFER_NO_MISSING_ARTS"))
            return

        confirm = QMessageBox.question(
            self,
            tr("APP_NAME"),
            tr("AUTO_TRANSFER_EXPLAIN"),
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.No
        )
        if confirm != QMessageBox.StandardButton.Yes:
            return

        # Create progress dialog
        progress_dialog = QProgressDialog(tr("AUTO_TRANSFER_IN_PROGRESS"), tr("CANCEL_BUTTON"), 0, 100, self)
        progress_dialog.setWindowTitle(tr("APP_NAME"))
        progress_dialog.setWindowModality(Qt.WindowModality.WindowModal)
        progress_dialog.setAutoClose(True)
        progress_dialog.setAutoReset(True)
        progress_dialog.setMinimumWidth(200)
        progress_dialog.show()

        self._cancel_auto = False
        progress_dialog.canceled.connect(lambda: setattr(self, '_cancel_auto', True))

        # Progress setup
        total = len(invocations)
        progress_dialog.setMaximum(total)
        progress_dialog.setValue(0)
        QApplication.processEvents()

        # Directories
        art_dir = zordeer_dir / "art"
        gui_dir = zordeer_dir / "art" / "gui"
        art_dir.mkdir(parents=True, exist_ok=True)
        gui_dir.mkdir(parents=True, exist_ok=True)

        completed = 0
        downloads = []  # Stores the hero and icon paths before copying

        for inv_name, toml_file in invocations:
            if self._cancel_auto or progress_dialog.wasCanceled():
                break

            hero_saved_path = None
            icon_saved_path = None
            hero_cache_path = None
            icon_cache_path = None

            try:
                # Search on SteamGridDB
                search_url = f"https://www.steamgriddb.com/api/v2/search/autocomplete/{inv_name}"
                with requests.get(search_url, headers=headers, timeout=15) as resp:
                    resp.raise_for_status()
                    data = resp.json().get("data", [])
                
                if not data:
                    completed += 1
                    progress_dialog.setValue(completed)
                    QApplication.processEvents()
                    continue

                game = data[0]
                game_id = game.get("id")
                steam_game_name = game.get("name") or str(game_id)

                # Download the hero
                try:
                    hero_url = f"https://www.steamgriddb.com/api/v2/heroes/game/{game_id}"
                    with requests.get(hero_url, headers=headers, timeout=20) as r:
                        r.raise_for_status()
                        heroes = r.json().get("data", []) or []
                except Exception:
                    heroes = []

                if heroes:
                    heroes.sort(key=get_score, reverse=True)
                    best = heroes[0]
                    img_url = (
                        best.get("thumb")
                        or best.get("thumb_url")
                        or (best.get("thumbs")[0] if isinstance(best.get("thumbs"), list) and best.get("thumbs") else None)
                        or best.get("full")
                        or best.get("url")
                    )
                    if img_url:
                        try:
                            with requests.get(img_url, timeout=20) as rr:
                                rr.raise_for_status()
                                ext = Path(img_url).suffix
                                if not ext or len(ext) > 6:
                                    ext = ".png"
                                
                                # Save to cache first
                                hero_cache_filename = heroes_cache_dir / f"{steam_game_name}_hero_{best.get('id')}{ext}"
                                with hero_cache_filename.open("wb") as fh:
                                    fh.write(rr.content)
                                hero_cache_path = hero_cache_filename
                        except Exception:
                            hero_cache_path = None

                # Download the icon
                try:
                    icon_url = f"https://www.steamgriddb.com/api/v2/icons/game/{game_id}"
                    with requests.get(icon_url, headers=headers, timeout=20) as r:
                        r.raise_for_status()
                        icons = r.json().get("data", []) or []
                except Exception:
                    icons = []

                if icons:
                    icons.sort(key=get_score, reverse=True)
                    best = icons[0]
                    img_url = (
                        best.get("thumb")
                        or best.get("thumb_url")
                        or (best.get("thumbs")[0] if isinstance(best.get("thumbs"), list) and best.get("thumbs") else None)
                        or best.get("full")
                        or best.get("url")
                    )
                    if img_url:
                        try:
                            with requests.get(img_url, timeout=20) as rr:
                                rr.raise_for_status()
                                ext = Path(img_url).suffix
                                if not ext or len(ext) > 6:
                                    ext = ".png"
                                
                                # Save to cache first
                                icon_cache_filename = icons_cache_dir / f"{steam_game_name}_icon_{best.get('id')}{ext}"
                                with icon_cache_filename.open("wb") as fh:
                                    fh.write(rr.content)
                                icon_cache_path = icon_cache_filename
                        except Exception:
                            icon_cache_path = None

                # Store for later copying
                downloads.append((inv_name, toml_file, hero_cache_path, icon_cache_path))

                # Clear large variables to free memory
                data = None
                heroes = None
                icons = None

            except Exception as e:
                print(tr("AUTO_TRANSFER_GENERAL_ERROR", inv_name=inv_name, error=str(e)))
            finally:
                completed += 1
                progress_dialog.setValue(completed)
                QApplication.processEvents()

        # After all downloads are complete, copy from cache to art/gui
        if not self._cancel_auto and not progress_dialog.wasCanceled():
            for inv_name, toml_file, hero_cache_path, icon_cache_path in downloads:
                normalized = inv_name.lower().replace(" ", "_").replace("/", "_").replace("\\", "_")
                copied_hero = False
                copied_icon = False

                try:
                    with open(toml_file, "r", encoding="utf-8") as fh:
                        inv_toml = toml.load(fh)
                except Exception:
                    inv_toml = {}

                if hero_cache_path and hero_cache_path.exists():
                    try:
                        dest = art_dir / f"{normalized}{hero_cache_path.suffix}"
                        shutil.copy2(hero_cache_path, dest)
                        inv_toml["art_path"] = str(dest)
                        copied_hero = True

                        # Delete the file from the cache folder when finished.
                        hero_cache_path.unlink()
                    except Exception:
                        copied_hero = False

                if icon_cache_path and icon_cache_path.exists():
                    try:
                        dest_icon = gui_dir / f"{normalized}{icon_cache_path.suffix}"
                        shutil.copy2(icon_cache_path, dest_icon)
                        inv_toml["gui_path"] = str(dest_icon)
                        copied_icon = True

                        # Delete the file from the cache folder when finished.
                        icon_cache_path.unlink()
                    except Exception:
                        copied_icon = False

                if copied_hero or copied_icon:
                    try:
                        with open(toml_file, "w", encoding="utf-8") as fh:
                            toml.dump(inv_toml, fh)
                    except Exception:
                        pass

        # Clear downloads list to free memory
        downloads.clear()

        if not self._cancel_auto and not progress_dialog.wasCanceled():
            QMessageBox.information(self, tr("APP_NAME"), tr("AUTO_TRANSFER_FINISHED"))

        self.load_invocations()

        progress_dialog.close()

    def run_in_prefix_dialog(self):
        invocation_name = self.get_selected_invocation()  # Use self directly
        if not invocation_name:
            QMessageBox.warning(self, tr("APP_NAME"), tr("NO_INVOCATION_SELECTED_ERROR"))
            return

        dlg = RunInPrefix(self, invocation_name)
        dlg.exec()

    def run_in_prefix(self, safe_invocation_name):
        exe_path, _ = QFileDialog.getOpenFileName(
            self,
            tr("SELECT_EXECUTABLE"),
            str(Path.home()),
            tr("EXECUTABLE_FILE_FILTER")
        )
        if not exe_path:
            return  # User canceled

        invocation_name = safe_invocation_name.replace(" ", "_").lower()
        base_file = zordeer_config_dir / f"invocation-info-{invocation_name}.toml"

        with base_file.open("r", encoding="utf-8") as f:
            base_info = toml.load(f)

        # Create temporary TOML
        temp_id = str(uuid.uuid4())[:8]
        temp_name = f"TEMP_EXEC_{temp_id}"
        safe_temp_name = temp_name.lower()
        temp_file = zordeer_config_dir / f"invocation-info-{safe_temp_name}.toml"

        temp_info = base_info.copy()
        temp_info["name"] = temp_name
        temp_info["exec_path"] = exe_path  # Update the executable

        with temp_file.open("w", encoding="utf-8") as f:
            toml.dump(temp_info, f)

        # Start as normal invocation
        self.start_invocation(temp_name)

        # Remove temp TOML after process ends
        if self.invocation_process:
            def wait_and_cleanup():
                self.invocation_process.wait()
                self.cleanup_temp_toml_files(temp_file)
            
            threading.Thread(target=wait_and_cleanup, daemon=True).start()
        else:
            self.cleanup_temp_toml_files(temp_file)

    def run_in_prefix_for_selected_invocation(self):
        invocation_name = self.get_selected_invocation()
        self.run_in_prefix(invocation_name)

    def cleanup_temp_toml_files(self):
        removed = 0
        if zordeer_config_dir.exists():
            for file in zordeer_config_dir.iterdir():
                if file.name.endswith("_ztffrip.toml"):
                    try:
                        file.unlink()
                        removed += 1
                    except Exception as e:
                        print(tr("ERROR_REMOVING_FILE", file=file.name, error=e))
        if removed > 0:
            print(tr("TEMP_FILES_REMOVED", count=removed))

    def open_path(self, safe_invocation_name=None, chosen_path="prefix"):
        if safe_invocation_name is None:
            safe_invocation_name = self.get_selected_invocation()
            if not safe_invocation_name:
                QMessageBox.warning(self, tr("APP_NAME"), tr("NO_INVOCATION_SELECTED_ERROR"))
                return 

        base_file = zordeer_dir / "config" / f"invocation-info-{safe_invocation_name.replace(' ', '_').lower()}.toml"

        if not base_file.exists():
            QMessageBox.warning(self, tr("APP_NAME"), tr("INVOCATION_INFO_ERROR"))
            return

        with base_file.open("r", encoding="utf-8") as f:
            invocation_info = toml.load(f)

        path = None
        if chosen_path == "prefix":
            path = Path(invocation_info.get("prefix_path", ""))
        elif chosen_path == "exe":
            exec_path = invocation_info.get("exec_path")
            path = Path(exec_path).parent if exec_path else None

        if path and path.exists():
            subprocess.run(["xdg-open", str(path)])
        else:
            QMessageBox.critical(
                self,
                tr("APP_NAME"),
                tr("OPEN_PATH_ERROR", path=str(path) if path else ""))

    def open_settings(self):
        dlg = SettingsDialog(self)
        dlg.exec()

    def show_about(self):
        dialog = QDialog(self)
        dialog.setWindowTitle(tr("ABOUT_ZORDEER"))
        dialog.setWindowModality(Qt.WindowModality.ApplicationModal)

        layout = QVBoxLayout(dialog)

        # Zordeer icon
        icon = self.windowIcon()
        if not icon.isNull():
            icon_label = QLabel()
            icon_label.setPixmap(icon.pixmap(64, 64))
            icon_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
            layout.addWidget(icon_label)

        # About text
        label = QLabel(tr("ABOUT_TEXT_HTML"))
        label.setWordWrap(True)
        label.setTextFormat(Qt.TextFormat.RichText)
        label.setOpenExternalLinks(True)
        label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(label)

        # Update button
        if not os.environ.get("SNAP") and os.environ.get("container") != "flatpak":
            update_button = QPushButton(tr("CHECK_UPDATE_BUTTON"))
            update_button.clicked.connect(self.check_update)
            layout.addWidget(update_button, alignment=Qt.AlignmentFlag.AlignCenter)

        dialog.exec()

    def check_update(self):
        try:
            response = requests.get("https://api.github.com/repos/Kyuyrii/Zordeer/tags", timeout=5)
            response.raise_for_status()
            tags = response.json()
            if not tags:
                QMessageBox.warning(self, tr("APP_NAME"), tr("NO_TAGS_FOUND"))
                return

            latest_tag = tags[0]["name"].lstrip("v")
            current_version = __version__

            def version_tuple(v):
                return tuple(int(x) for x in v.split("."))

            if version_tuple(current_version) >= version_tuple(latest_tag):
                QMessageBox.information(self, tr("APP_NAME"), tr("ALREADY_UPDATED"))
            else:
                reply = QMessageBox.question(
                    self,
                    tr("APP_NAME"),
                    tr("NEW_VERSION_AVAILABLE", version=latest_tag),
                    QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
                )
                if reply == QMessageBox.StandardButton.Yes:
                    subprocess.Popen(['xdg-open', 'https://github.com/Kyuyrii/Zordeer/releases'])
        except Exception as e:
            QMessageBox.warning(self, tr("APP_NAME"), tr("UPDATE_ERROR", error=e))

# ===================== SGDB: artwork worker (thread) =====================
heroes_cache_dir = XDG_CACHE_HOME / "Zordeer" /"heroes_cache"
icons_cache_dir = XDG_CACHE_HOME / "Zordeer" / "icons_cache"
heroes_cache_dir.mkdir(parents=True, exist_ok=True)
icons_cache_dir.mkdir(parents=True, exist_ok=True)

class ArtworkLoader(QThread):
    finished = pyqtSignal(list)  # List of artworks [{id, url, img_data}, ...]
    error = pyqtSignal(str)
    progress = pyqtSignal(int)   # 0 to 100%

    def __init__(self, api_key, game_id, art_type="heroes"):
        super().__init__()
        self.api_key = api_key
        self.game_id = game_id
        self.art_type = art_type  # "heroes" or "icons"

    def download_image(self, art):
        # Attempt to find the best available URL, in descending order of priority
        img_url = (
            art.get("thumb")
            or art.get("thumb_url")
            or (art.get("thumbs")[0] if isinstance(art.get("thumbs"), list) and art.get("thumbs") else None)
            or art.get("full")
            or art.get("url")
        )
        
        img_data = None
        if img_url:
            try:
                rt = requests.get(img_url, timeout=10)
                rt.raise_for_status()
                img_data = rt.content
            except Exception:
                img_data = None  # If it fails, continue
        
        return {
            "id": art.get("id"),
            "url": img_url,
            "img_data": img_data
        }

    def run(self):
        try:
            headers = {"Authorization": f"Bearer {self.api_key}"}
            url = f"https://www.steamgriddb.com/api/v2/{self.art_type}/game/{self.game_id}"
            resp = requests.get(url, headers=headers, timeout=20)
            resp.raise_for_status()
            data = resp.json().get("data", [])

            if not data:
                self.finished.emit([])
                return

            from concurrent.futures import ThreadPoolExecutor, as_completed
            
            results = [None] * len(data)
            total = len(data)
            
            with ThreadPoolExecutor(max_workers=5) as executor:
                futures = {}
                for idx, art in enumerate(data):
                    future = executor.submit(self.download_image, art)
                    futures[future] = idx
                
                completed = 0
                for future in as_completed(futures):
                    idx = futures[future]
                    results[idx] = future.result()
                    completed += 1
                    # Updates the progress bar
                    self.progress.emit(int(completed / total * 100))
            
            self.finished.emit(results)
            
        except Exception as e:
            self.error.emit(tr("ARTS_LOAD_ERROR", error=str(e)))

if __name__ == "__main__":
    # Loads settings
    settings = load_settings()
    # Uses full saved locale, or LANG defined in the module (which already has 'pt_BR.UTF-8', for example)
    current_lang = settings["design"].get("language", LANG)
    LANG = current_lang  # Update the global variable
    app = QApplication(sys.argv)

    # Load Qt translation
    translator = QTranslator()
    user_locale = LANG
    translations_path = QLibraryInfo.path(QLibraryInfo.LibraryPath.TranslationsPath)

    if translator.load(f"qt_{user_locale}", translations_path):
        app.installTranslator(translator)

    # The application ID is needed so that Wayland can find the icon.
    app_id = "io.github.kyuyrii.zordeer"
    app.setDesktopFileName(app_id)

    # Helper function to send command to already running instance
    def send_to_running_instance(message: str) -> bool:
        socket = QLocalSocket()
        socket.connectToServer("io.github.kyuyrii.zordeer")
        if socket.waitForConnected(300):
            socket.write(message.encode("utf-8"))
            socket.flush()
            socket.waitForBytesWritten(300)
            socket.disconnectFromServer()
            return True
        return False

    # Try sending --start-invocation command to existing instance
    if "--start-invocation" in sys.argv:
        try:
            idx = sys.argv.index("--start-invocation") + 1
            invocation_name = sys.argv[idx]
            if send_to_running_instance(f'--start-invocation "{invocation_name}"'):
                sys.exit(0)
        except IndexError:
            pass

    # Server for single instance
    def handle_new_connection():
        socket = window.server.nextPendingConnection()
        if not socket.waitForReadyRead(1000):
            socket.disconnectFromServer()
            return
        data = socket.readAll().data().decode("utf-8").strip()

        if data == "--heartbeat":
            socket.write(b"alive")
            socket.flush()
            socket.waitForBytesWritten(300)
            socket.disconnectFromServer()
            return

        if data.startswith("--start-invocation "):
            invocation_name = data[len("--start-invocation "):].strip('"')
            QTimer.singleShot(200, partial(window.start_invocation, invocation_name))

        socket.disconnectFromServer()

    def is_instance_alive() -> bool:
        socket = QLocalSocket()
        socket.connectToServer("io.github.kyuyrii.zordeer")
        if socket.waitForConnected(300):
            socket.write(b"--heartbeat")
            socket.flush()
            if socket.waitForReadyRead(300):
                response = socket.readAll().data().decode("utf-8").strip()
                socket.disconnectFromServer()
                if response == "alive":
                    return True
        QLocalServer.removeServer("io.github.kyuyrii.zordeer")
        return False

    # If another instance is already running, send the command to it and exit
    if is_instance_alive():
        if "--start-invocation" in sys.argv:
            try:
                idx = sys.argv.index("--start-invocation") + 1
                invocation_name = sys.argv[idx]
                send_to_running_instance(f'--start-invocation "{invocation_name}"')
            except IndexError:
                pass
        sys.exit(0)

    window = Zordeer()

    window.server_name = "io.github.kyuyrii.zordeer"
    window.server = QLocalServer(window)
    window.server.listen(window.server_name)
    window.server.newConnection.connect(handle_new_connection)

    if "--start-invocation" in sys.argv:
        try:
            idx = sys.argv.index("--start-invocation") + 1
            invocation_name = sys.argv[idx]
            QTimer.singleShot(500, partial(window.start_invocation, invocation_name))
        except IndexError:
            pass

    sys.exit(app.exec())
